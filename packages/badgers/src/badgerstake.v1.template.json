{
  "$schema": "https://libauth.org/schemas/wallet-template-v0.schema.json",
  "description": "BadgerStake: a staking contract to earn Badger tokens.",
  "name": "BadgerStake",
  "entities": {
    "covenant": {
      "description": "BadgerStake holds undistributed BadgerCoins on the MasterBadger NFT as well as staked coins.",
      "name": "Badger Vault",
      "scripts": ["unlock", "lock", "badger_stake_covenant", "administer"],
      "variables": {
        "amount": {
          "description": "Stake amount.",
          "name": "Amount",
          "type": "WalletData"
        },
        "stake_blocks": {
          "description": "The duration of the staking period (in blocks)",
          "name": "Stake Blocks",
          "type": "WalletData"
        },
        "new_fee": {
          "description": "The category of the asset being listed.",
          "name": "Asset Category",
          "type": "WalletData"
        },
        "user_pkh": {
          "description": "The key that controls user funds.",
          "name": "User",
          "type": "WalletData"
        },
        "admin_pkh": {
          "description": "The key administering this covenant.",
          "name": "Admin",
          "type": "WalletData"
        }
      }
    }
  },
  "scenarios": {
    "base": {
      "data": {
        "bytecode": {
          "stake_blocks": "5000",
          "amount": "100000000",
          "new_fee": "1000"
        }
      },
      "description": "",
      "name": "Base Scenario"
    },
    "lock": {
      "data": {
        "bytecode": {
          "stake_blocks": "5000",
          "amount": "400000",
          "new_fee": "1000",
          "user_pkh": "0xbe7f0bcf860657ce2fdb6f047141faa39e50f224"
        }
      },
      "description": "Lock coins in the Badger Vault",
      "extends": "base",
      "name": "Lock Assets",
      "transaction": {
        "inputs": [
          {
            "unlockingBytecode": ["slot"]
          },
          {}
        ],
        "outputs": [
          {
            "lockingBytecode": {
              "script": "badger_stake_covenant"
            },
            "valueSatoshis": 335000,
            "token": {
              "amount": "9223372036854412287",
              "category": "242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",
              "nft": {
                "capability": "minting",
                "commitment": "e8030000000000000000000000000000000000002770188a88f75360d1e956d7ff290ef1e0f56787"
              }
            }
          },
          {
            "lockingBytecode": {
              "script": "badger_stake_covenant"
            },
            "valueSatoshis": 400000,
            "token": {
              "amount": 20,
              "category": "242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",
              "nft": {
                "capability": "mutable",
                "commitment": "be7f0bcf860657ce2fdb6f047141faa39e50f2240000000000000000000000000000000000008813"
              }
            }
          },
          {
            "lockingBytecode": "76a914be7f0bcf860657ce2fdb6f047141faa39e50f22488ac",
            "valueSatoshis": 2713641
          }
        ],
        "version": 2
      },
      "sourceOutputs": [
        {
          "lockingBytecode": ["slot"],
          "valueSatoshis": 334000,
          "token": {
            "category": "242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",
            "amount": "9223372036854412307",
            "nft": {
              "commitment": "e8030000000000000000000000000000000000002770188a88f75360d1e956d7ff290ef1e0f56787",
              "capability": "minting"
            }
          }
        },
        {
          "lockingBytecode": "76a914be7f0bcf860657ce2fdb6f047141faa39e50f22488ac",
          "valueSatoshis": 42715641
        }
      ]
    },
    "unlock": {
      "name": "Release Assets",
      "description": "",
      "extends": "base",
      "data": {
        "bytecode": {
          "stake_blocks": "5000",
          "amount": "400000",
          "new_fee": "1000",
          "user_pkh": "0xbe7f0bcf860657ce2fdb6f047141faa39e50f224"
        }
      },
      "transaction": {
        "inputs": [
          {
            "unlockingBytecode": ["slot"],
            "sequenceNumber": 5000
          }
        ],
        "outputs": [
          {
            "lockingBytecode": "76a914be7f0bcf860657ce2fdb6f047141faa39e50f22488ac",
            "valueSatoshis": 1000,
            "token": {
              "amount": 20,
              "category": "242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7"
            }
          },
          {
            "lockingBytecode": "76a914be7f0bcf860657ce2fdb6f047141faa39e50f22488ac",
            "valueSatoshis": 1000,
            "token": {
              "category": "242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",
              "amount": 0,
              "nft": {
                "capability": "none",
                "commitment": "000014"
              }
            }
          },
          {
            "lockingBytecode": "76a914be7f0bcf860657ce2fdb6f047141faa39e50f22488ac",
            "valueSatoshis": 397000
          }
        ],
        "version": 2
      },
      "sourceOutputs": [
        {
          "lockingBytecode": ["slot"],
          "valueSatoshis": 400000,
          "token": {
            "category": "242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",
            "amount": 20,
            "nft": {
              "commitment": "be7f0bcf860657ce2fdb6f047141faa39e50f2240000000000000000000000000000000000008813",
              "capability": "mutable"
            }
          }
        }
      ]
    },
    "withdraw": {
      "description": "Administer the current fee, ",
      "extends": "base",
      "name": "Withdraw accumulated fees and adjust anti-spam fee",
      "transaction": {
        "inputs": [
          {
            "unlockingBytecode": ["slot"],
            "sequenceNumber": 10
          },
          {
            "unlockingBytecode":{
              "script":["copy"]
            }
          }
        ],
        "outputs": [
          {
            "lockingBytecode": {
              "script": "badger_stake_covenant"
            },
            "valueSatoshis": 1000,
            "token": {
              "amount": "9223372036854412287",
              "category": "242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",
              "nft": {
                "capability": "minting",
                "commitment": "e8030000000000000000000000000000000000002770188a88f75360d1e956d7ff290ef1e0f56787"
              }
            }
          },
          {
            "lockingBytecode": "76a9142770188a88f75360d1e956d7ff290ef1e0f5678788ac",
            "valueSatoshis": 330800
          }
        ],
        "version": 2
      },
      "sourceOutputs": [
        {
          "lockingBytecode": ["slot"],
          "valueSatoshis": 332000,
          "token": {
            "category": "242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",
            "amount": "9223372036854412287",
            "nft": {
              "commitment": "e8030000000000000000000000000000000000002770188a88f75360d1e956d7ff290ef1e0f56787",
              "capability": "minting"
            }
          }
        },
        {
          "lockingBytecode": "76a9142770188a88f75360d1e956d7ff290ef1e0f5678788ac",
          "valueSatoshis": 800
        }
      ]
    }
  },
  "scripts": {
    "lock": {
      "passes": ["lock"],
      "name": "0: Lock",
      "script": " <user_pkh> <stake_blocks> <amount>  OP_0",
      "unlocks": "badger_stake_covenant"
    },
    "unlock": {
      "passes": ["unlock"],
      "name": "1: Unlock",
      "script": "OP_1",
      "unlocks": "badger_stake_covenant"
    },
    "administer": {
      "passes": ["withdraw"],
      "name": "2: Administer",
      "script": "<new_fee> OP_2 ",
      "unlocks": "badger_stake_covenant"
    },
    "badger_stake_covenant": {
      "lockingType": "p2sh20",
      "name": "BadgerStake Covenant",
      "script": "\n// pragma cashscript ^0.10.0;\n\n// contract BadgerStake() {\n\n//     /////////////////////////////////////////////\n//     //inputs:\n//     //  0   masterBadger        [NFT]   (from contract)\n//     //  1   userUTXO            [BCH]   (from user)\n//     //outputs:\n//     //  0   masterBadger        [NFT]   (to contract)\n//     //  1   lockUTXO            [NFT]   (to contract)\n//     //  2   {optional} change   [BCH]   (to user)\n//     /////////////////////\n//     //parameters:\n//     //  amount: BCH amount user wants to lock up\n//     //  stakeBlocks: number of blocks to be locked up for\n//     //  pubkeyhash: a pubkeyhash, used to send the locked BCH back to the users address\n//     /////////////////////////////////////////////\n\n       OP_DUP OP_0 OP_NUMEQUAL OP_IF \n//     function lock(int amount, int stakeBlocks, bytes20 pubkeyhash) {\n\n//       // this contract must be input0\n         OP_INPUTINDEX OP_0 OP_NUMEQUALVERIFY \n//       require(this.activeInputIndex == 0);\n\n//       // must have exactly 2 inputs\n         OP_TXINPUTCOUNT OP_2 OP_NUMEQUALVERIFY \n//       require(tx.inputs.length == 2);\n\n//       // must have 3 or less outputs\n         OP_TXOUTPUTCOUNT OP_3 OP_LESSTHANOREQUAL OP_VERIFY \n//       require(tx.outputs.length <= 3);\n\n//       // cannot lock for longer than 65536 blocks\n         OP_2 OP_PICK <65536> OP_LESSTHANOREQUAL OP_VERIFY \n//       require(stakeBlocks <= 65536);\n\n//       // minimum 5000 sats to lock so have enough for unlock()\n         OP_OVER <5000> OP_GREATERTHANOREQUAL OP_VERIFY \n//       require(amount >= 5000);\n\n//       // input0 must be masterBadger NFT\n         OP_0 OP_UTXOTOKENCATEGORY <0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24> OP_2 OP_CAT OP_EQUALVERIFY\n//       require(tx.inputs[0].tokenCategory == 0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24 + 0x02);\n\n//       // input1 must be BCH with no tokens\n         OP_1 OP_UTXOTOKENCATEGORY OP_0 OP_EQUALVERIFY \n//       require(tx.inputs[1].tokenCategory == 0x);\n\n//       // provided pubkeyhash must be the pubkeyhash of input1 (users address)\n         OP_1 OP_UTXOBYTECODE <0x76a914> OP_5 OP_PICK OP_CAT <0x88ac> OP_CAT OP_EQUALVERIFY \n//       require(tx.inputs[1].lockingBytecode == new LockingBytecodeP2PKH(pubkeyhash));\n\n//       // convert stakeBlocks to bytes for inclusion into commitment\n         OP_2 OP_PICK OP_2 OP_NUM2BIN \n//       bytes stakeLength = bytes2(stakeBlocks);\n\n//       // save payout address and length of lock into output1 commitment (lockNFT)\n         OP_1 OP_OUTPUTTOKENCOMMITMENT OP_5 OP_ROLL OP_0 <18> OP_NUM2BIN OP_CAT OP_ROT OP_CAT OP_EQUALVERIFY \n//       require(tx.outputs[1].nftCommitment == pubkeyhash + bytes18(0) + stakeLength);\n\n//       // get current locking fee from masterBadger's commitment\n         OP_0 OP_UTXOTOKENCOMMITMENT OP_2 OP_SPLIT OP_DROP \n//       bytes2 stakeFee = bytes2(tx.inputs[0].nftCommitment.split(2)[0]);\n\n//       // add locking fee to current masterBadger balance\n         OP_0 OP_OUTPUTVALUE OP_0 OP_UTXOVALUE OP_ROT OP_BIN2NUM OP_ADD OP_NUMEQUALVERIFY \n//       require(tx.outputs[0].value == tx.inputs[0].value + int(stakeFee));\n\n//       // output0 sent to contract (recreate masterBadger)\n         OP_0 OP_OUTPUTBYTECODE OP_0 OP_UTXOBYTECODE OP_EQUALVERIFY \n//       require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n\n//       // carry forward masterBadger tokenCategory + capability\n         OP_0 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY OP_EQUALVERIFY \n//       require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n\n//       // carry forward masterBadger commitment\n         OP_0 OP_OUTPUTTOKENCOMMITMENT OP_0 OP_UTXOTOKENCOMMITMENT OP_EQUALVERIFY \n//       require(tx.outputs[0].nftCommitment == tx.inputs[0].nftCommitment);\n\n//       calculate amount of BadgerCoins user will earn (amount * blocks / 1BCH)\n         OP_OVER OP_3 OP_ROLL OP_MUL <100000000> OP_DIV \n//       int stakeReward = amount * stakeBlocks / 100000000;\n\n//       // require at least 1 BadgerCoin will be earned\n         OP_DUP OP_1 OP_GREATERTHANOREQUAL OP_VERIFY \n//       require(stakeReward >= 1);\n\n//       // deduct earned BadgerCoins from masterBadger\n         OP_0 OP_OUTPUTTOKENAMOUNT OP_0 OP_UTXOTOKENAMOUNT OP_2 OP_PICK OP_SUB OP_NUMEQUALVERIFY \n//       require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount - stakeReward);\n\n//       // output1 sent to contract (lockNFT)\n         OP_1 OP_OUTPUTBYTECODE OP_0 OP_UTXOBYTECODE OP_EQUALVERIFY \n//       require(tx.outputs[1].lockingBytecode == tx.inputs[0].lockingBytecode);\n\n//       // lockNFT is a mutable NFT of masterBadger categoryID\n         OP_1 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY <32> OP_SPLIT OP_DROP OP_1 OP_CAT OP_EQUALVERIFY \n//       require(tx.outputs[1].tokenCategory == tx.inputs[0].tokenCategory.split(32)[0] + 0x01);\n\n//       // lockNFT has BCH equal to users amount parameter\n         OP_1 OP_OUTPUTVALUE OP_3 OP_ROLL OP_NUMEQUALVERIFY\n//       require(tx.outputs[1].value == amount);\n\n//       // lockNFT has BadgerCoin equal to calculated amount to be earned\n         OP_1 OP_OUTPUTTOKENAMOUNT OP_NUMEQUALVERIFY \n//       require(tx.outputs[1].tokenAmount == stakeReward);\n\n//       // if output2 exists (change)\n         OP_TXOUTPUTCOUNT OP_3 OP_NUMEQUAL OP_IF \n//       if (tx.outputs.length == 3) {\n//          // change must be sent to users address\n            OP_2 OP_OUTPUTBYTECODE OP_1 OP_UTXOBYTECODE OP_EQUALVERIFY \n//          require(tx.outputs[2].lockingBytecode == tx.inputs[1].lockingBytecode);\n\n//          // change must not have tokens\n            OP_2 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUALVERIFY OP_ENDIF \n//          require(tx.outputs[2].tokenCategory == 0x);\n//       }\n//     }\n      OP_DROP OP_1 OP_ELSE \n\n//    /////////////////////////////////////////////\n//    //inputs:\n//    //  0   lockUTXO            [NFT]   (from contract)\n//    //outputs:\n//    //  0   BadgerCoins         [FUN]   (to user)\n//    //  1   Honey               [NFT]   (to user)\n//    //  2   {optional} change   [BCH]   (to user)\n//    /////////////////////////////////////////////\n      OP_DUP OP_1 OP_NUMEQUAL OP_IF \n//     function unlock() {\n\n//       // this contract must be input0\n         OP_INPUTINDEX OP_0 OP_NUMEQUALVERIFY \n//       require(this.activeInputIndex == 0);\n\n//       // must have exactly 1 input\n         OP_TXINPUTCOUNT OP_1 OP_NUMEQUALVERIFY \n//       require(tx.inputs.length == 1);\n\n//       // must have exactly 3 outputs\n         OP_TXOUTPUTCOUNT OP_3 OP_NUMEQUALVERIFY \n//       require(tx.outputs.length == 3);\n\n//       // input0 must be a lockNFT (masterBadger categoryID + mutable)\n         OP_0 OP_UTXOTOKENCATEGORY <0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24> OP_1 OP_CAT OP_EQUALVERIFY \n//       require(tx.inputs[0].tokenCategory == 0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24 + 0x01);\n\n//       // get number of blocks locked for from lockNFT's commitment\n         OP_0 OP_UTXOTOKENCOMMITMENT <38> OP_SPLIT OP_NIP \n//       bytes stakeBlocks = bytes2(tx.inputs[0].nftCommitment.split(38)[1]);\n\n//       // require the number of blocks locked for has been passed\n         OP_BIN2NUM OP_CHECKSEQUENCEVERIFY \n//       require(tx.age >= int(stakeBlocks));\n\n//       // get the pubkeyhash in lockNFT it was created with\n         OP_DROP OP_0 OP_UTXOTOKENCOMMITMENT <20> OP_SPLIT OP_DROP \n//       bytes20 payoutAddress = bytes20(tx.inputs[0].nftCommitment.split(20)[0]);\n\n//       // create the lockingBytecode for that pubkeyhash\n         <0x76a914> OP_SWAP OP_CAT <0x88ac> OP_CAT \n//       bytes payoutBytecode = new LockingBytecodeP2PKH(payoutAddress);\n\n//       // output0 (BadgerCoins) goes to the resulting wallet address (user who created the lock)\n         OP_0 OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY \n//       require(tx.outputs[0].lockingBytecode == payoutBytecode);\n\n//       // output0 is a masterBadger categoryID but no capability\n         OP_0 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY <32> OP_SPLIT OP_DROP OP_EQUALVERIFY \n//       require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory.split(32)[0]);\n\n//       // output0 has 1000 dust satoshis so it can exist\n         OP_0 OP_OUTPUTVALUE <1000> OP_NUMEQUALVERIFY \n//       require(tx.outputs[0].value == 1000);\n\n         OP_0 OP_OUTPUTTOKENAMOUNT OP_0 OP_UTXOTOKENAMOUNT OP_NUMEQUALVERIFY \n//       require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount);\n\n//       // output1 (HoneyNFT) goes to the resulting wallet address (user who created the lock)\n         OP_1 OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY \n//       require(tx.outputs[1].lockingBytecode == payoutBytecode);\n\n//       // output1 is a masterBadger categoryID but no capability\n         OP_1 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY <32> OP_SPLIT OP_DROP OP_EQUALVERIFY \n//       require(tx.outputs[1].tokenCategory == tx.inputs[0].tokenCategory.split(32)[0]);\n\n//       // output1 has 1000 satoshis so it can exist\n         OP_1 OP_OUTPUTVALUE <1000> OP_NUMEQUALVERIFY \n//       require(tx.outputs[1].value == 1000);\n\n//       // create commitment of ID0 + amount of BadgerCoins earned\n         <0x0000> OP_0 OP_UTXOTOKENAMOUNT OP_CAT \n//       bytes commitment = 0x0000 + bytes(tx.inputs[0].tokenAmount);\n\n//       // output1 has above commitment\n         OP_1 OP_OUTPUTTOKENCOMMITMENT OP_EQUALVERIFY \n//       require(tx.outputs[1].nftCommitment == commitment);\n\n//       // output2 (unlocked BCH) goes to the extracted wallet address (user who created the lock)\n         OP_2 OP_OUTPUTBYTECODE OP_EQUALVERIFY \n//       require(tx.outputs[2].lockingBytecode == payoutBytecode);\n\n//       // output2 has no tokens\n         OP_2 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUALVERIFY \n//       require(tx.outputs[2].tokenCategory == 0x);\n\n//       // output2 has original locked BCH minus 3000sats (miner fee + BadgerCoin utxo + Honey utxo)\n         OP_2 OP_OUTPUTVALUE OP_0 OP_UTXOVALUE <3000> OP_SUB OP_NUMEQUAL \n//       require(tx.outputs[2].value == tx.inputs[0].value - 3000);\n//     }\n\n//     /////////////////////////////////////////////\n//     //inputs:\n//     //  0   masterBadger        [NFT]   (from contract)\n//     //  1   adminUTXO           [BCH]   (from admin)\n//     //outputs:\n//     //  0   masterBadger        [NFT]   (to contract)\n//     //  1   withdrawUTXO        [BCH]   (to admin)\n//     /////////////////////\n//     //parameters:\n//     //  newFee: sets the masterBadger's locking fee (0 to 65536)\n//     /////////////////////////////////////////////\n      OP_NIP OP_ELSE OP_2 OP_NUMEQUALVERIFY \n//     function withdraw(int newFee) {\n\n//       // this contract must be input0\n         OP_INPUTINDEX OP_0 OP_NUMEQUALVERIFY \n//       require(this.activeInputIndex == 0);\n\n//       // must have exactly 2 inputs\n         OP_TXINPUTCOUNT OP_2 OP_NUMEQUALVERIFY \n//       require(tx.inputs.length == 2);\n\n//       // must have exactly 2 outputs\n         OP_TXOUTPUTCOUNT OP_2 OP_NUMEQUALVERIFY \n//       require(tx.outputs.length == 2);\n\n//       // input0 must be masterBadger NFT\n         OP_0 OP_UTXOTOKENCATEGORY <0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24> OP_2 OP_CAT OP_EQUALVERIFY \n//       require(tx.inputs[0].tokenCategory == 0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24 + 0x02);\n\n//       // input1 must be BCH with no tokens\n         OP_1 OP_UTXOTOKENCATEGORY OP_0 OP_EQUALVERIFY \n//       require(tx.inputs[1].tokenCategory == 0x);\n\n//       // get admins pubkeyhash stored in masterBadger commitment\n         OP_0 OP_UTXOTOKENCOMMITMENT <20> OP_SPLIT OP_NIP \n//       bytes20 adminAddress = bytes20(tx.inputs[0].nftCommitment.split(20)[1]);\n\n//       // create the lockingBytecode for that pubkeyhash\n         <0x76a914> OP_SWAP OP_CAT <0x88ac> OP_CAT \n//       bytes payoutBytecode = new LockingBytecodeP2PKH(adminAddress);\n\n//       // require the resulting lockingBytecode matches input1 (input1 is from admin address)\n         OP_1 OP_UTXOBYTECODE OP_EQUALVERIFY \n//       require(tx.inputs[1].lockingBytecode == payoutBytecode);\n\n//       // output1 has no tokens\n         OP_1 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUALVERIFY \n//       require(tx.outputs[1].tokenCategory == 0x);\n\n//       // output1 takes masterBadger's BCH balance minus 2000sats (miner fee + masterBadger dust)\n         OP_1 OP_OUTPUTVALUE OP_0 OP_UTXOVALUE OP_1 OP_UTXOVALUE OP_ADD <2000> OP_SUB OP_NUMEQUALVERIFY \n//       require(tx.outputs[1].value == tx.inputs[0].value + tx.inputs[1].value - 2000);\n\n//       // output0 sent to contract (recreate masterBadger)\n         OP_0 OP_OUTPUTBYTECODE OP_0 OP_UTXOBYTECODE OP_EQUALVERIFY \n//       require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n\n//       // masterBadger retains its tokenCategory + capability\n         OP_0 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY OP_EQUALVERIFY \n//       require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n\n//       // masterBadger set to 1000sats so it can exist\n         OP_0 OP_OUTPUTVALUE <1000> OP_NUMEQUALVERIFY \n//       require(tx.outputs[0].value == 1000);\n\n//       // masterBadger retains its remaining BadgerCoins\n         OP_0 OP_OUTPUTTOKENAMOUNT OP_0 OP_UTXOTOKENAMOUNT OP_NUMEQUALVERIFY \n//       require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount);\n\n//       // get last 38bytes of masterBadgers commitment\n         OP_0 OP_UTXOTOKENCOMMITMENT OP_2 OP_SPLIT OP_NIP \n//       bytes restCommitment = tx.inputs[0].nftCommitment.split(2)[1];\n\n//       // update masterBadger's commitment to newFee + rest of its commitment\n         OP_0 OP_OUTPUTTOKENCOMMITMENT OP_ROT OP_2 OP_NUM2BIN OP_ROT OP_CAT OP_EQUAL\n//       require(tx.outputs[0].nftCommitment == bytes2(newFee) + restCommitment);\n//    }\n   OP_ENDIF \n// }\nOP_ENDIF"
    }
  },
  "supported": ["BCH_2023_05", "BCH_2024_05", "BCH_2025_05", "BCH_SPEC"],
  "version": 0
}
