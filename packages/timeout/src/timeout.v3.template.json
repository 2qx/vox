{
  "$schema": "https://libauth.org/schemas/wallet-template-v0.schema.json",
  "description": "Timeout: a \"deadman\"-style asset vault.",
  "name": "Timeout",
  "entities": {
    "covenant": {
      "description": "Lock assets on a deadman timeout. \n\nIf assets are left dormant for too long without being refreshed, this contract allows them to be sent to a predefined receipt. Parameters of the contract are published MUST be published publicly (at some point) to allow anyone to forward the assets to the pre-defined receipt.",
      "name": "Timeout Vault",
      "scripts": [
        "timeout_covenant",
        "unlock"
      ],
      "variables": {
        "auth_category": {
          "description": "CashToken Category of the NFT series administering the timeout Vault.",
          "name": "Authentication Token Category",
          "type": "WalletData"
        },
        "timeout": {
          "description": "The relative time (in blocks) between refreshes.",
          "name": "Timeout",
          "type": "WalletData"
        },
        "recipient": {
          "description": "Where assets can be sent to when the timeout is passed.",
          "name": "Recipient",
          "type": "AddressData"
        },
        "key": {
          "description": "The private key that controls an admin wallet.",
          "name": "Key",
          "type": "HdKey"
        }
      }
    }
  },
  "scenarios": {
    "base": {
      "description": "",
      "name": "Base Scenario",
      "data": {
        "bytecode": {
          "auth_category": "0xbeefbeefbeefbeefbeefbeefbeefbeefbeefbeefbeefbeefbeefbeefbeefbeef",
          "timeout": "10",
          "recipient": "0xa914e78564d75c446f8c00c757a2bd783d30c4f0819a87"
        }
      }
    },
    "release": {
      
      "description": "Send assets to receipt without special authorization",
      "extends": "base",
      "name": "Release assets after the timeout",
      "transaction": {
        "inputs": [
          {
            "unlockingBytecode": [
              "slot"
            ],
            "sequenceNumber": 10
          }
        ],
        "outputs": [
          {
            "lockingBytecode": "a914e78564d75c446f8c00c757a2bd783d30c4f0819a87",
            "valueSatoshis": 800
          }
        ],
        "version": 2
      },
      "sourceOutputs": [
        {
          "lockingBytecode": [
            "slot"
          ],
          "valueSatoshis": 800
        }
      ]
    },
    "withdraw": {
      "description": "",
      "extends": "base",
      "name": "Withdraw with NFT",
      "transaction": {
        "inputs": [
          {
            "unlockingBytecode": {
              "script": "wallet_unlock"
            }
          },
          {
            "unlockingBytecode": [
              "slot"
            ],
            "sequenceNumber": 2
          }
        ],
        "outputs": [
          {
            "lockingBytecode": "a914000000000000000000000000000000000000000087",
            "valueSatoshis": 100000800
          }
        ],
        "version": 2
      },
      "sourceOutputs": [
        {
          "lockingBytecode": {
            "script": "wallet_lock"
          },
          "valueSatoshis": 800,
          "token": {
            "category": "efbeefbeefbeefbeefbeefbeefbeefbeefbeefbeefbeefbeefbeefbeefbeefbe",
            "nft": {
              "capability": "minting"
            }
          }
        },
        {
          "lockingBytecode": [
            "slot"
          ],
          "valueSatoshis": 100000000
        }
      ]
    }
  },
  "scripts": {
    "unlock": {
      "passes": [
        "release"
      ],
      "name": "Unlock",
      "script": "OP_0",
      "unlocks": "timeout_covenant"
    },
    "administer": {
      "passes": [
        "withdraw"
      ],
      "name": "Administer",
      "script": "OP_1",
      "unlocks": "timeout_covenant"
    },
    "timeout_covenant": {
      "lockingType": "p2sh32",
      "name": "Timeout Covenant",
      "script": "<recipient>  <timeout> <auth_category> //\n// contract Timeout(\n\n//   // Category of the authenticating baton\n//   // The auth baton is managed by the wallet of the user, \n//   // The contract is agnostic of the token paid to the receipt.\n//   bytes32 authCat,\n\n//   // length of time (blocks) to lock utxos \n//   int timeout,\n\n//   // LockingBytecode of the beneficiary, the address receiving payments\n//   bytes recipientLockingBytecode\n\n// ) {\n\n   OP_3 OP_PICK OP_0 OP_NUMEQUAL OP_IF \n  //function execute() {\n\n//  Require version 2 for BIP68 support\n    OP_TXVERSION OP_2 OP_NUMEQUALVERIFY\n//  require(tx.version == 2);\n\n//  Check that time has passed and that time locks are enabled\n    OP_SWAP OP_CHECKSEQUENCEVERIFY OP_DROP \n//  require(tx.age >= timeout, \"must satisfy age (bip68)\");\n\n//  Check that each output sends to the recipient\n    OP_INPUTINDEX OP_OUTPUTBYTECODE OP_ROT OP_EQUALVERIFY \n//  require(tx.outputs[this.activeInputIndex].lockingBytecode == recipientLockingBytecode);\n\n//  Check that each output sends the balance minus an executor allowance\n    OP_INPUTINDEX OP_OUTPUTVALUE OP_INPUTINDEX OP_UTXOVALUE <2500> OP_SUB OP_GREATERTHANOREQUAL OP_VERIFY\n//  require(tx.outputs[this.activeInputIndex].value >= tx.inputs[this.activeInputIndex].value - 2500);\n\n//  Require tokens go forward\n    OP_INPUTINDEX OP_OUTPUTTOKENAMOUNT OP_INPUTINDEX OP_UTXOTOKENAMOUNT OP_NUMEQUALVERIFY \n//  require(tx.outputs[this.activeInputIndex].tokenAmount == tx.inputs[this.activeInputIndex].tokenAmount);\n\n//  Require the token is of the same category\n    OP_INPUTINDEX OP_OUTPUTTOKENCATEGORY OP_INPUTINDEX OP_UTXOTOKENCATEGORY OP_EQUALVERIFY \n//  require(tx.outputs[this.activeInputIndex].tokenCategory == tx.inputs[this.activeInputIndex].tokenCategory, \"must be same token\");\n\n//  Require the NFT commitment is passed on, if it exists\n    OP_INPUTINDEX OP_OUTPUTTOKENCOMMITMENT OP_INPUTINDEX OP_UTXOTOKENCOMMITMENT OP_EQUAL\n// require(tx.outputs[this.activeInputIndex].nftCommitment == tx.inputs[this.activeInputIndex].nftCommitment, \"must pass NFT\");\n        \n// } \n    OP_NIP OP_NIP\n\n  // Allow refreshing, or withdraw, with the authentication baton\n     OP_ELSE OP_3 OP_ROLL OP_1 OP_NUMEQUALVERIFY \n  // function administer() {\n\n      // Authentication failed, script fails.\n         OP_0 OP_UTXOTOKENCATEGORY OP_SWAP OP_2 OP_CAT OP_EQUAL  //\n      // require(tx.inputs[0].tokenCategory == authCat + 0x02);\n      \n  // } \n  OP_NIP OP_NIP OP_ENDIF\n\n"
    },
    "wallet_unlock": {
      "name": "Unlock",
      "script": "<key.schnorr_signature.all_outputs>\n<key.public_key>",
      "unlocks": "wallet_lock"
    },
    "wallet_lock": {
      "lockingType": "standard",
      "name": "P2PKH Lock",
      "script": "OP_DUP\nOP_HASH160 <$(<key.public_key> OP_HASH160\n)> OP_EQUALVERIFY\nOP_CHECKSIG"
    }
  },
  "supported": [
    "BCH_2023_05",
    "BCH_2024_05",
    "BCH_2025_05",
    "BCH_SPEC"
  ],
  "version": 0
}