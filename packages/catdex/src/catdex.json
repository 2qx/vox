{
  "contractName": "CatDex",
  "constructorInputs": [
    {
      "name": "authCat",
      "type": "bytes32"
    },
    {
      "name": "assetCat",
      "type": "bytes32"
    }
  ],
  "abi": [
    {
      "name": "swap",
      "inputs": []
    }
  ],
  "bytecode": "OP_0 OP_UTXOTOKENCATEGORY OP_OVER OP_2 OP_CAT OP_EQUAL OP_IF OP_ELSE OP_INPUTINDEX OP_INPUTINDEX OP_2 OP_MOD OP_SUB OP_DUP OP_UTXOTOKENCATEGORY OP_2 OP_PICK OP_1 OP_CAT OP_EQUALVERIFY OP_DUP OP_OUTPUTTOKENCATEGORY OP_2 OP_PICK OP_1 OP_CAT OP_EQUALVERIFY OP_DUP OP_OUTPUTBYTECODE OP_OVER OP_UTXOBYTECODE OP_EQUALVERIFY OP_DUP OP_1ADD OP_DUP OP_OUTPUTBYTECODE OP_OVER OP_OUTPUTBYTECODE OP_EQUALVERIFY OP_DUP OP_OUTPUTTOKENAMOUNT OP_0 OP_GREATERTHAN OP_IF OP_DUP OP_OUTPUTTOKENCATEGORY OP_4 OP_PICK OP_EQUALVERIFY OP_ENDIF OP_OVER OP_UTXOTOKENCOMMITMENT OP_16 OP_SPLIT OP_OVER OP_BIN2NUM OP_OVER OP_BIN2NUM OP_4 OP_PICK OP_OUTPUTTOKENAMOUNT OP_5 OP_PICK OP_UTXOTOKENAMOUNT OP_SUB OP_2 OP_PICK OP_OVER OP_SUB OP_16 OP_NUM2BIN OP_2 OP_PICK OP_16 OP_NUM2BIN OP_CAT OP_7 OP_PICK OP_OUTPUTTOKENCOMMITMENT OP_OVER OP_EQUALVERIFY OP_OVER OP_0 OP_GREATERTHAN OP_4 OP_PICK OP_0 OP_GREATERTHAN OP_EQUALVERIFY OP_OVER OP_ABS OP_4 OP_PICK OP_ABS OP_LESSTHANOREQUAL OP_VERIFY OP_7 OP_PICK OP_OUTPUTVALUE OP_8 OP_PICK OP_UTXOVALUE OP_SUB OP_2OVER OP_SWAP OP_MUL 00e1f505 OP_DIV OP_NEGATE OP_NUMEQUALVERIFY OP_2DROP OP_2DROP OP_2DROP OP_2DROP OP_ENDIF OP_2DROP OP_1",
  "source": "//   \n// CatDex - WIP 20250115, Mock tested\n//\n//   Parameters:\n//\n//     authCat - the token category authorizing trades or transfers (owner's NFT)\n//     assetCat - the category of the fungible token being traded\n//\n\ncontract CatDex(bytes32 authCat, bytes32 assetCat){\n\n\n    function swap(){\n    \n        // If the first input has a minting baton (owner),\n        //   the spending of outputs is unrestricted. \n        // OP_0 OP_UTXOTOKENCATEGORY OP_OVER OP_2 OP_CAT OP_EQUAL OP_IF \n        if(tx.inputs[0].tokenCategory == authCat + 0x02){\n            // pass \n        }\n\n        // If the order input (even input) is a mutable auth Baton ... \n        // OP_ELSE    \n        else{\n            // Push the index of this order baton to the stack\n            // OP_INPUTINDEX OP_INPUTINDEX OP_2 OP_MOD OP_SUB \n            int orderIndex = this.activeInputIndex - (this.activeInputIndex % 2);  \n\n            // Require the order is mutable\n            // OP_DUP OP_UTXOTOKENCATEGORY OP_2 OP_PICK OP_1 OP_CAT OP_EQUALVERIFY \n            require(tx.inputs[orderIndex].tokenCategory == authCat + 0x01 );\n\n            // Require the mutable baton returns\n            // OP_DUP OP_OUTPUTTOKENCATEGORY OP_2 OP_PICK OP_1 OP_CAT OP_EQUALVERIFY \n            require(tx.outputs[orderIndex].tokenCategory == authCat + 0x01);\n\n            // Require the order baton be passed back to the contract\n            // OP_DUP OP_OUTPUTBYTECODE OP_OVER OP_UTXOBYTECODE OP_EQUALVERIFY \n            require(tx.outputs[orderIndex].lockingBytecode == \n                     tx.inputs[orderIndex].lockingBytecode);\n\n            // Get the next index of the asset thread\n            // OP_DUP OP_1ADD \n            int assetIndex = orderIndex + 1; \n\n            // Require the asset thread be sent at the current contract\n            // OP_DUP OP_OUTPUTBYTECODE OP_OVER OP_OUTPUTBYTECODE OP_EQUALVERIFY \n            require(tx.outputs[assetIndex].lockingBytecode == \n                    tx.outputs[assetIndex].lockingBytecode);                 \n                        \n            // if the amount of tokens is greater than zero,\n            // OP_DUP OP_OUTPUTTOKENAMOUNT OP_0 OP_GREATERTHAN OP_IF \n            if(tx.outputs[assetIndex].tokenAmount > 0){\n              // require the asset output contain token category specified by the order\n              // OP_DUP OP_OUTPUTTOKENCATEGORY OP_4 OP_PICK OP_EQUALVERIFY \n              require(tx.outputs[assetIndex].tokenCategory == assetCat);\n            } // OP_ENDIF \n\n            // Parse the order data from the NFT commitment\n            // OP_OVER OP_UTXOTOKENCOMMITMENT OP_16 OP_SPLIT \n            bytes quantityBin, bytes priceBin = \n                          tx.inputs[orderIndex].nftCommitment.split(16);\n\n            //  OP_OVER OP_BIN2NUM \n            int orderQuantity = int(quantityBin);  \n\n            // OP_OVER OP_BIN2NUM \n            int price = int(priceBin);\n\n            // Get the amount of the token traded\n            // OP_4 OP_PICK OP_OUTPUTTOKENAMOUNT OP_5 OP_PICK OP_UTXOTOKENAMOUNT OP_SUB \n            int tradeQuantity = tx.outputs[assetIndex].tokenAmount - \n                                 tx.inputs[assetIndex].tokenAmount;\n\n            // Verify new authCat order baton NFT commitment\n            // OP_2 OP_PICK OP_OVER OP_SUB OP_16 OP_NUM2BIN OP_2 OP_PICK OP_16 OP_NUM2BIN OP_CAT \n            bytes32 nextCommitment = bytes16(orderQuantity-tradeQuantity) + bytes16(price);\n\n            // Require updating order baton\n            // OP_7 OP_PICK OP_OUTPUTTOKENCOMMITMENT OP_OVER OP_EQUALVERIFY \n            require(tx.outputs[orderIndex].nftCommitment == nextCommitment);\n\n            // require the sign of the quantity traded is matches the order sign  \n            // OP_OVER OP_0 OP_GREATERTHAN OP_4 OP_PICK OP_0 OP_GREATERTHAN OP_EQUAL OP_VERIFY\n            require((tradeQuantity > 0 == orderQuantity > 0)); \n\n            // require the amount traded be less than (or equal to) the quantity available\n            // OP_OVER OP_ABS OP_4 OP_PICK OP_ABS OP_LESSTHANOREQUAL OP_VERIFY \n            require(abs(tradeQuantity) <= abs(orderQuantity));\n\n            // Verify the value returned with the order exceeds the quantity traded times the price.\n            // OP_7 OP_PICK OP_OUTPUTVALUE OP_8 OP_PICK OP_UTXOVALUE OP_SUB\n            //  OP_2OVER OP_SWAP OP_MUL <100_000_000> OP_DIV OP_NEGATE OP_NUMEQUALVERIFY \n            require((tx.outputs[orderIndex].value - tx.inputs[orderIndex].value) == -(tradeQuantity*price/100_000_000));\n            //\n        } // OP_2DROP OP_2DROP OP_2DROP OP_2DROP \n        //\n    } \n    // OP_ENDIF \n} \n// OP_2DROP OP_1",
  "debug": {
    "bytecode": "00ce5179527e876367c0c05297940079ce5279517e87690079d15279517e87690079cd5179c78769007951930079cd5179cd87690079d300a0630079d154798769685179cf607f5179815179815479d35579d09452795179946080527960807e5779d251798769517900a0547900a08769517990547990a1695779cc5879c69452795479950400e1f505968f9c69757575757575757568517777",
    "sourceMap": "18:21:18:22;:11::37:1;:41::48:0;;:51::55;:41:::1;:11;:56:20:9:0;24:12:96;27:29:27:50;:54::75;:78::79;:54:::1;:29::80;31:30:31:40:0;;:20::55:1;:59::66:0;;:69::73;:59:::1;:20;:12::76;35:31:35:41:0;;:20::56:1;:60::67:0;;:70::74;:60:::1;:20;:12::76;39:31:39:41:0;;:20::58:1;40:31:40:41:0;;:21::58:1;39:20;:12::60;44:29:44:39:0;;:42::43;:29:::1;48:31:48:41:0;;:20::58:1;49:31:49:41:0;;:20::58:1;48;:12::60;53:26:53:36:0;;:15::49:1;:52::53:0;:15:::1;:54:57:13:0;56:33:56:43;;:22::58:1;:62::70:0;;:22:::1;:14::72;53:54:57:13;62:36:62:46:0;;:26::61:1;:68::70:0;:26::71:1;65:36:65:47:0;;:32::48:1;68:28:68:36:0;;:24::37:1;72:43:72:53:0;;:32::66:1;73:43:73:53:0;;:33::66:1;72:32;77:45:77:58:0;;:59::72;;:45:::1;:37::73;;:84::89:0;;:76::90:1;;:37;81:31:81:41:0;;:20::56:1;:60::74:0;;:20:::1;:12::76;85:21:85:34:0;;:37::38;:21:::1;:42::55:0;;:58::59;:42:::1;:21;:12::62;89:24:89:37:0;;:20::38:1;:46::59:0;;:42::60:1;:20;:12::62;94:32:94:42:0;;:21::49:1;:62::72:0;;:52::79:1;:21;:86::99:0;;:100::105;;:86:::1;:106::117:0;:86:::1;:84::118;:20;:12::120;24::96:9;;;;;;;;;13:4:98:5;;",
    "logs": [],
    "requires": [
      {
        "ip": 24,
        "line": 31
      },
      {
        "ip": 33,
        "line": 35
      },
      {
        "ip": 41,
        "line": 39
      },
      {
        "ip": 53,
        "line": 48
      },
      {
        "ip": 66,
        "line": 56
      },
      {
        "ip": 104,
        "line": 81
      },
      {
        "ip": 114,
        "line": 85
      },
      {
        "ip": 122,
        "line": 89
      },
      {
        "ip": 139,
        "line": 94
      }
    ]
  },
  "compiler": {
    "name": "cashc",
    "version": "0.10.5"
  },
  "updatedAt": "2025-11-22T12:48:56.125Z"
}
