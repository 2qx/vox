{
  "$schema": "https://libauth.org/schemas/wallet-template-v0.schema.json",
  "description": "CatDex: a limit order CashToken exchange.",
  "name": "CatDex",
  "entities": {
    "covenant": {
      "description": "A blackboard lists limit orders and authorizes trade for a Category Decentralized Exchange.",
      "name": "CatDex Blackboard",
      "scripts": [
        "sell",
        "buy",
        "catdex_blackboard",
        "administer"
      ],
      "variables": {
        "auth_category": {
          "description": "Stake amount.",
          "name": "Authentication Token Category",
          "type": "WalletData"
        },
        "asset_category": {
          "description": "The Cashtoken Category Token ID of the asset being traded",
          "name": "Asset Token Category",
          "type": "WalletData"
        },
        "user": {
          "description": "The key that controls user funds.",
          "name": "User",
          "type": "Key"
        },
        "admin": {
          "description": "The key administering this covenant.",
          "name": "Admin",
          "type": "Key"
        }
      }
    }
  },
  "scenarios": {
    "base": {
      "data": {
        "bytecode": {
          "auth_category": "deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead",
          "asset_category": "beef00000000000000000000000000000000000000000000000000000000beef"
        }
      },
      "description": "",
      "name": "Base Scenario"
    },
    "buy": {
      "description": "Buy assets, take a sell order.",
      "extends": "base",
      "name": "Buy Assets",
      "transaction": {
        "inputs": [
          {
            "unlockingBytecode": [
              "slot"
            ]
          },
          {}
        ],
        "outputs": [
          {
            "lockingBytecode": {
              "script": "badger_stake_covenant"
            },
            "valueSatoshis": 335000,
            "token": {
              "amount": 9223372036854412000,
              "category": "0x242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",
              "nft": {
                "capability": "minting",
                "commitment": "e8030000000000000000000000000000000000002770188a88f75360d1e956d7ff290ef1e0f56787"
              }
            }
          },
          {
            "lockingBytecode": {
              "script": "badger_stake_covenant"
            },
            "valueSatoshis": 40000000,
            "token": {
              "amount": 20,
              "category": "242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",
              "nft": {
                "capability": "mutable",
                "commitment": "be7f0bcf860657ce2fdb6f047141faa39e50f2240000000000000000000000000000000000008813"
              }
            }
          },
          {
            "lockingBytecode": "user",
            "valueSatoshis": 2713641
          }
        ],
        "version": 2
      },
      "sourceOutputs": [
        {
          "lockingBytecode": [
            "slot"
          ],
          "valueSatoshis": 334000,
          "token": {
            "category": "242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",
            "amount": 9223372036854412000,
            "nft": {
              "commitment": "e8030000000000000000000000000000000000002770188a88f75360d1e956d7ff290ef1e0f56787",
              "capability": "minting"
            }
          }
        },
        {
          "lockingBytecode": {
            "script": "lock_user"
          },
          "valueSatoshis": 42715641
        }
      ]
    },
    "sell": {
      "description": "",
      "extends": "base",
      "name": "Sell Assets",
      "transaction": {
        "inputs": [
          {
            "unlockingBytecode": [
              "slot"
            ]
          }
        ],
        "outputs": [
          {
            "lockingBytecode": "a914e78564d75c446f8c00c757a2bd783d30c4f0819a87",
            "valueSatoshis": 800
          }
        ],
        "locktime": 11,
        "version": 2
      },
      "sourceOutputs": [
        {
          "lockingBytecode": [
            "slot"
          ],
          "valueSatoshis": 800,
          "token": {
            "category": "0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24",
            "amount": 9223372036854454000,
            "nft": {
              "commitment": "e8030000000000000000000000000000000000002770188a88f75360d1e956d7ff290ef1e0f56787",
              "capability": "minting"
            }
          }
        }
      ]
    },
    "withdraw": {
      "description": "",
      "extends": "base",
      "name": "Withdraw accumulated fees and adjust anti-spam fee",
      "transaction": {
        "inputs": [
          {
            "unlockingBytecode": [
              "slot"
            ],
            "sequenceNumber": 10
          }
        ],
        "outputs": [
          {
            "lockingBytecode": "a9144a08530650e861d34acee43152e54de27d1bcf8287",
            "valueSatoshis": 800
          }
        ],
        "locktime": 11,
        "version": 2
      },
      "sourceOutputs": [
        {
          "lockingBytecode": [
            "slot"
          ],
          "valueSatoshis": 800,
          "token": {
            "category": "0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead",
            "nft": {
              "capability": "minting"
            }
          }
        }
      ]
    }
  },
  "scripts": {
    "sell": {
      "passes": [
        "sell"
      ],
      "name": "Sells assets",
      "script": "",
      "unlocks": "catdex_blackboard"
    },
    "buy": {
      "passes": [
        "buy"
      ],
      "name": "Buy assets",
      "script": "",
      "unlocks": "catdex_blackboard"
    },
    "administer": {
      "passes": [
        "withdraw"
      ],
      "name": "Administer",
      "script": "",
      "unlocks": "catdex_blackboard"
    },
    "lock_user": {
      "lockingType": "standard",
      "name": "P2PKH Lock",
      "script": "OP_DUP\nOP_HASH160 <$(<user.public_key> OP_HASH160\n)> OP_EQUALVERIFY\nOP_CHECKSIG"
    },
    "catdex_blackboard": {
      "lockingType": "p2sh32",
      "name": "CatDex Blackboard",
      "script": "// pragma cashscript ^0.10.0;\n\n//\n// CatDex - A token category authorized decentralized exchange\n//\n// Trade fungible tokens at fixed prices based on orders expressed in NFT commitments\n\n//   Features:\n//   - Allow for partial order fulfillment at a fixed price,\n//   - Allow contracts with zero (0) of a specific token to acquire a position in that token\n//   - Allow contracts with some number of tokens to liquidate that position completely\n//   - Allow a minting Baton holder to withdraw, or cancel any open order, by spending/burning utxos.\n//   - Zero commission trades, although order takers pay standard transaction fees to miners.\n//   - Given a known token category, orders are discoverable with the exchange token category.\n//   - Given an exchange category, orders are indexed and retrieved by getting the NFT balance of the exchange.\n\n// Usage:\n\n//   The exchange \"owner\" creates an NFT category with a minting baton to open trade orders on their own behalf.\n\n//   An order to Bid, or Buy, an asset is created by:\n//    creating a mutable NFT with the order in the commitment\n//    where the order quantity to be bought is *positive*, and\n//    the output contains sufficient value to fulfill the entire order,\n//    then sending that output to the dex contract.\n\n//   An Ask order, or Sell, is created as above:\n//     creating a mutable NFT identical to a buy, where,\n//     the quantity available for sale is *negative*,\n//     and the order utxo will accumulate any funds from the sale of the token,\n//     after the owner sends both: the order and the tokens to the contract as two utxos.\n\n//   Order Commitments: mutable NFT commitment to trade fungible token\n  \n//      byte16(LE)<quantity>   number of tokens remaining in order\n//      byte16(LE)<price>      price per token in sats\n//      TODO: multiplier   pre-multiply the token price by some fixed constant (i.e. decimals)\n//      ===\n//      32 length\n\n//   Transaction Building Modes:\n\n//    Order Mode:\n  \n//      In \"Order mode\" outputs are submitted in pairs, with both the record for the order\n//      and the cash value moving on the even \"foot\" and the tokens trading on the odd \"foot\".\n    \n//      orderAuth     input[even] -> output[even]  - An order NFT of category AuthCat (mutable)\n//      assetVault    input[odd]  -> output[odd]   - An input or output of category AssetCat.\n\n//    Withdraw Mode:\n  \n//      Transactions with a minting NFT may withdraw all outputs from the contract.\n  \n//      Auth             input[0] -> output[0]     - Authenticating NFT of category AuthCat (minting)\n//                       input[i] -> output[*]     - Unrestricted spending\n\n//   Note: \n\n//   The exchange owner(s) holds the minting NFT baton(s), which authorizes spending funds from the exchange.\n\n//   \n// CatDex - WIP 20250115\n//\n//   Parameters:\n//\n//     authCat - the token category authorizing trades or transfers (owner's NFT)\n//     assetCat - the category of the fungible token being traded\n//\n\n<auth_category> <asset_category>\n// contract CatDex(bytes32 authCat, bytes32 assetCat){\n\n//     function swap(){\n    \n        // Set the index of the order baton related to this trade\n        OP_INPUTINDEX OP_INPUTINDEX OP_2 OP_MOD OP_SUB\n        // int orderIndex = this.activeInputIndex - (this.activeInputIndex % 2);   \n\n        // If the order input (even input) is a mutable auth Baton ... \n        OP_DUP OP_UTXOTOKENCATEGORY OP_2 OP_PICK OP_1 OP_CAT OP_EQUAL OP_IF        \n        // if(tx.inputs[orderIndex].tokenCategory == authCat + 0x01){\n\n            // Require the baton is passed back in an output of the same index with mutable capability\n            OP_DUP OP_OUTPUTTOKENCATEGORY OP_2 OP_PICK OP_1 OP_CAT OP_EQUALVERIFY\n            // require(tx.outputs[orderIndex].tokenCategory == authCat + 0x01);\n\n            // Require the order baton be passed back to the contract\n            OP_DUP OP_OUTPUTBYTECODE OP_OVER OP_UTXOBYTECODE OP_EQUALVERIFY\n            // require(tx.outputs[orderIndex].lockingBytecode == \n            //          tx.inputs[orderIndex].lockingBytecode);\n\n            // verify asset thread:\n            // - output\n            // - categoryId\n            // - qty\n            //\n\n            // Get the next index of the asset thread\n            OP_DUP OP_1ADD\n            // int assetIndex = orderIndex + 1; \n\n            // Require the asset thread be sent at the current contract\n            OP_DUP OP_OUTPUTBYTECODE OP_2 OP_PICK OP_OUTPUTBYTECODE OP_EQUALVERIFY\n            // require(tx.outputs[assetIndex].lockingBytecode == \n            //         tx.outputs[orderIndex].lockingBytecode);                 \n                        \n            // if the amount of tokens is greater than zero,\n            OP_DUP OP_OUTPUTTOKENAMOUNT OP_0 OP_GREATERTHAN OP_IF\n            // if(tx.outputs[assetIndex].tokenAmount > 0){\n              // require the asset output contain token category specified by the order\n              OP_DUP OP_OUTPUTTOKENCATEGORY OP_4 OP_PICK OP_EQUALVERIFY\n            //   require(tx.outputs[assetIndex].tokenCategory == assetCat);\n            // } \n            OP_ENDIF\n\n            // Parse the order data from the NFT commitment\n            OP_OVER OP_UTXOTOKENCOMMITMENT OP_16 OP_SPLIT\n            // bytes quantityBin, bytes priceBin = \n            //               tx.inputs[orderIndex].nftCommitment.split(16);\n\n            OP_OVER OP_BIN2NUM\n            // int orderQuantity = int(quantityBin);  \n\n            OP_OVER OP_BIN2NUM\n            // int price = int(priceBin);\n\n            // Get the amount of the token traded\n            OP_4 OP_PICK OP_OUTPUTTOKENAMOUNT \n            OP_5 OP_PICK OP_UTXOTOKENAMOUNT OP_SUB\n            // int tradeQuantity = tx.outputs[assetIndex].tokenAmount - \n            //                      tx.inputs[assetIndex].tokenAmount;\n\n            // Verify new authCat order baton NFT commitment\n            OP_2 OP_PICK OP_OVER OP_SUB OP_16 OP_NUM2BIN \n            OP_2 OP_PICK OP_16 OP_NUM2BIN OP_CAT\n            // bytes32 nextCommitment = bytes16(orderQuantity-tradeQuantity) + bytes16(price);\n\n\n            OP_7 OP_PICK OP_OUTPUTTOKENCOMMITMENT OP_OVER OP_EQUALVERIFY\n            // require(tx.outputs[orderIndex].nftCommitment == nextCommitment);\n\n            // require the sign of the quantity traded is matches the order sign  \n            OP_OVER OP_0 OP_GREATERTHAN OP_4 OP_PICK OP_0 OP_GREATERTHAN OP_EQUALVERIFY\n            // require(tradeQuantity > 0 == orderQuantity > 0); \n\n            // require the amount traded be less than (or equal to) the quantity available\n            OP_OVER OP_ABS OP_4 OP_PICK OP_ABS OP_LESSTHANOREQUAL OP_VERIFY\n            // require(\n            //     abs(tradeQuantity) <= abs(orderQuantity),\n            //     \"trade must be less than or equal to order quantity available\"\n            //     );\n\n\n            // Verify the value returned with the order exceeds the quantity traded times the price.\n            //\n            // Examples:\n            // 0 - 10,000 sats  ->  534 sats  \n            //        |-> Buy -1000 @ 10 sat\n            // 1 -      0 ft    -> 10,000 ft          534-10,000 >= -1000*10 OK\n            //\n            // 2 -  800 sats     -> 10,800 sats\n            //       |-> Sell 1000 @ 10 sat/ft\n            // 3 -  1,000 ft    -> 0 ft                   10,000 >= 1000*10 OK\n            //\n            OP_7 OP_PICK OP_OUTPUTVALUE OP_8 OP_PICK OP_UTXOVALUE OP_SUB \n            OP_2OVER OP_SWAP OP_MUL OP_NEGATE OP_GREATERTHANOREQUAL OP_VERIFY\n            // require((tx.outputs[orderIndex].value - tx.inputs[orderIndex].value) >= -(tradeQuantity*price));\n            //\n      //   } \n        OP_2DROP OP_2DROP OP_2DROP OP_DROP\n        //\n        // otherwise, if the zeroth input contains the minting baton \n        OP_ELSE\n      //   else{\n            // Authentication failed, script fails.\n            OP_0 OP_UTXOTOKENCATEGORY OP_2 OP_PICK OP_2 OP_CAT OP_EQUALVERIFY\n            // require(tx.inputs[0].tokenCategory == authCat + 0x02);\n      //   } \n        OP_ENDIF\n//     }\n    OP_ENDIF\n// } \nOP_2DROP OP_2DROP OP_1"
    }
  },
  "supported": [
    "BCH_2023_05",
    "BCH_2024_05",
    "BCH_2025_05",
    "BCH_SPEC"
  ],
  "version": 0
}