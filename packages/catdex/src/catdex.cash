//   
// CatDex - WIP 20250115, Mock tested
//
//   Parameters:
//
//     authCat - the token category authorizing trades or transfers (owner's NFT)
//     assetCat - the category of the fungible token being traded
//

contract CatDex(bytes32 authCat, bytes32 assetCat){


    function swap(){
    
        // Set the index of the order baton related to this trade
        // OP_INPUTINDEX OP_INPUTINDEX OP_2 OP_MOD OP_SUB
        int orderIndex = this.activeInputIndex - (this.activeInputIndex % 2);   

        // If the order input (even input) is a mutable auth Baton ... 
        // OP_DUP OP_UTXOTOKENCATEGORY OP_2 OP_PICK OP_1 OP_CAT OP_EQUAL OP_IF       
        if(tx.inputs[orderIndex].tokenCategory == authCat + 0x01){

            // Require the baton is passed back in an output of the same index with mutable capability
            // OP_DUP OP_OUTPUTTOKENCATEGORY OP_2 OP_PICK OP_1 OP_CAT OP_EQUALVERIFY
            require(tx.outputs[orderIndex].tokenCategory == authCat + 0x01,
            "order baton must be returned intact");

            // Require the order baton be passed back to the contract
            // OP_DUP OP_OUTPUTBYTECODE OP_OVER OP_UTXOBYTECODE OP_EQUALVERIFY
            require(tx.outputs[orderIndex].lockingBytecode == 
                     tx.inputs[orderIndex].lockingBytecode,
                     "order baton must be returned to the dex");

            // Get the next index of the asset thread
            // OP_DUP OP_1ADD
            int assetIndex = orderIndex + 1; 

            // Require the asset thread be sent at the current contract
            // OP_DUP OP_OUTPUTBYTECODE OP_2 OP_PICK OP_OUTPUTBYTECODE OP_EQUALVERIFY
            require(tx.outputs[assetIndex].lockingBytecode == 
                    tx.outputs[assetIndex].lockingBytecode,
                     "token output be returned to the dex");                 
                        
            // if the amount of tokens is greater than zero,
            // OP_DUP OP_OUTPUTTOKENAMOUNT OP_0 OP_GREATERTHAN OP_IF
            if(tx.outputs[assetIndex].tokenAmount > 0){
              // require the asset output contain token category specified by the order
              // OP_DUP OP_OUTPUTTOKENCATEGORY OP_4 OP_PICK OP_EQUALVERIFY
              require(tx.outputs[assetIndex].tokenCategory == assetCat,
                "wrong token passed as the return asset");
            } // OP_ENDIF

            // Parse the order data from the NFT commitment
            // OP_OVER OP_UTXOTOKENCOMMITMENT OP_16 OP_SPLIT
            bytes quantityBin, bytes priceBin = 
                          tx.inputs[orderIndex].nftCommitment.split(16);

            // OP_OVER OP_BIN2NUM
            int orderQuantity = int(quantityBin);  

            // OP_OVER OP_BIN2NUM
            int price = int(priceBin);

            // Get the amount of the token traded
            // OP_4 OP_PICK OP_OUTPUTTOKENAMOUNT 
            // OP_5 OP_PICK OP_UTXOTOKENAMOUNT OP_SUB
            int tradeQuantity = tx.outputs[assetIndex].tokenAmount - 
                                 tx.inputs[assetIndex].tokenAmount;

            // Verify new authCat order baton NFT commitment
            // OP_2 OP_PICK OP_OVER OP_SUB OP_16 OP_NUM2BIN 
            // OP_2 OP_PICK OP_16 OP_NUM2BIN OP_CAT
            bytes32 nextCommitment = bytes16(orderQuantity-tradeQuantity) + bytes16(price);


            // OP_7 OP_PICK OP_OUTPUTTOKENCOMMITMENT OP_OVER OP_EQUALVERIFY
            require(tx.outputs[orderIndex].nftCommitment == nextCommitment,
                "order baton data was not updated to reflect trade");

            // require the sign of the quantity traded is matches the order sign  
            // OP_OVER OP_0 OP_GREATERTHAN OP_4 OP_PICK OP_0 OP_GREATERTHAN OP_EQUALVERIFY
            require(!(tradeQuantity > 0 && orderQuantity < 0),
                "conflicting trade & order direction"); 

            // require the amount traded be less than (or equal to) the quantity available
            // OP_OVER OP_ABS OP_4 OP_PICK OP_ABS OP_LESSTHANOREQUAL OP_VERIFY
            require(
                abs(tradeQuantity) <= abs(orderQuantity),
                "trade must be less than or equal to order quantity available"
                );


            // Verify the value returned with the order exceeds the quantity traded times the price.
            // OP_7 OP_PICK OP_OUTPUTVALUE OP_8 OP_PICK OP_UTXOVALUE OP_SUB 
            // OP_2OVER OP_SWAP OP_MUL 00e1f505 OP_DIV OP_NEGATE OP_GREATERTHANOREQUAL OP_VERIFY
            require(
                (tx.outputs[orderIndex].value - tx.inputs[orderIndex].value) == -(tradeQuantity*price/100_000_000),
                "Payment for order too low"
            );
            //
        } // OP_2DROP OP_2DROP OP_2DROP OP_DROP
        //
        // otherwise, if the zeroth input contains the minting baton 
        // OP_ELSE
        else{
            // Authentication failed, script fails.
            // OP_0 OP_UTXOTOKENCATEGORY OP_2 OP_PICK OP_2 OP_CAT OP_EQUALVERIFY
            require(tx.inputs[0].tokenCategory == authCat + 0x02,
                "Authorizing order baton NFT must be passed with each trade on an even input.");
        } // OP_ENDIF
    } 
} // OP_2DROP OP_2DROP OP_1