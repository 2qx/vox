pragma cashscript ^0.10.0;

// Battery - Spawn an array of vault deploying gantries from a single utxo.
//
// 2024-08-08
// 
// Executed in block #858,444 on Aug 10, 2024
// 02eb65ab5ce602b3025bc0c139cd22709983ae1acb58f476b86d6e31dd585e55
// bitcoincash:pd3hc4smdeu4kpwyvjq645d0ts5n9wxgvp3x7gg3my65u2kkw766xxxl8wdgp
//
// From: Future Bitcoin Cash
//
// Author: 2qx <2qx_in_the_future@small.neomailbox.ch>
//
// A Battery releases a series of Gantries at small powers of 10 that 
// go on to create Futures Vaults on those respective intervals.
//
// Given a minting NFT with the commitment containing a power of 10, 
// mint a sequence of NFTs with minting capability
// sending mutable batons NFTs to the corresponding Gantry.
//
//  execute():
//
//  inputs                           outputs
//  [0] Battery + NFT 0x40420F00 10ᴇ6 ->  [0] Gantry10ᴇ6 + NFT* <startTime>
//                                    =>  [1] Battery    + NFT  0xA0860100
//
//  [0] Battery + NFT 0xA0860100 10ᴇ5 ->  [0] Gantry10ᴇ5 + NFT* <startTime>
//                                    =>  [1] Battery    + NFT  0x10270000
//
//  ... 0x10270000 10ᴇ4 ... 0xE8030000 10ᴇ3 ... 0x64000000 10ᴇ2
//
//  [0] Battery + NFT 0x<end>        ->  [0]  Gantry10ᴇ2 + NFT* <startTime>
//                                       [1]  Burn NFT, sats are unencumbered.
//                                       
//  NOTE:
//  The final production version 
//    - Swaps the order of outputs so Gantries are first.
//       (this allows the mutable gantry NFT later mint FTs)
//    - Accomodates variable length baton values, line 80
//    - Funds the gantry with sats per lines 100, 104
// 

contract Battery(

    // Correct contract initialization will have minting NFT's commitment
    // set to <step> from the NFT commitment, which will be the step set for 1st minted gantry,
    // and will then get decremented for the next one until end step is reached.

    // The end is the smallest power of 10 to create a Gantry for.
    int endStep,

    // Base time from which to calculate each Gantry's starting point, e.g.:
    // --| baseTime
    //   |------------------------------------| gantry 0 start
    //   |------------| gantry 1 start
    //   |----| gantry 2 start
    int baseTime,

    // Redeem bytecode tail of the gantry contracts
    bytes gantryReedemBytecodeTail,

    // Redeem bytecode tail of the vault contracts
    bytes vaultReedemBytecodeTail,

) {

    function execute() {

        // Get the current step, we will mint a Gantry for this step
        bytes stepBytes = tx.inputs[this.activeInputIndex].nftCommitment;
        int step = int(stepBytes);

        // Set the gantry's starting time at correct offset from baseTime
        bytes4 gantryStart = bytes4(baseTime - (baseTime % step) + step);
        require(tx.outputs[0].nftCommitment == gantryStart);

        // Construct the full redeem bytecode for the Gantry instance
        bytes gantryRedeemBytecode =
            bytes(vaultReedemBytecodeTail.length) + vaultReedemBytecodeTail +
            bytes(bytes(step).length)             + bytes(step)   + 
            gantryReedemBytecodeTail;

        require(
            // The first output must have the P2SH32 of the gantry redeem bytecode
            0xaa20 + hash256(gantryRedeemBytecode) + 0x87
            == tx.outputs[0].lockingBytecode
        );

        // Ensure that Gantry inherits a mutable NFT so that it may update the
        // commitment as it mints its Vaults.
        bytes gantryCategory =
            tx.inputs[this.activeInputIndex].tokenCategory.split(32)[0] +
            0x01;
        require(tx.outputs[0].tokenCategory == gantryCategory);

        // Exactly 2 outputs, so token state or BCH can't leak out.
        require(tx.outputs.length == 2);

        // Fund each gantry in a single utxo for about 100 years.
        require(tx.outputs[0].value > 42500000000/step);

        // Fee allowance = 1000
        require(tx.outputs[1].value >
            tx.inputs[this.activeInputIndex].value - 42500000000/step -
            1800);

        if(step > endStep) {
            // Calculate and enforce next baton's step,
            require(tx.outputs[1].nftCommitment == bytes4(step / 10));
            // token category & capability (pass on minting NFT),
            require(tx.outputs[1].tokenCategory ==
                tx.inputs[this.activeInputIndex].tokenCategory);
            // and contract code.
            require(tx.outputs[1].lockingBytecode ==
                tx.inputs[this.activeInputIndex].lockingBytecode);
        } else {
            // Burn the minting baton while allowing any remaining BCH
            // to be extracted to output 1.
            require(tx.outputs[1].tokenCategory == 0x);

            // Note: output 1 still mints a Gantry in this same TX,
            // and it will be the last one to get minted.
        }
    }
}