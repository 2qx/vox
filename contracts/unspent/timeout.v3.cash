
// Unspent Phi
//
// Timeout v3 
//
// Timeout: an automatic "deadman" switch with variable waiting period.
//
// - Allow forwarding utxos after a predefined interval (BIP68).
// - Allow chaining many utxos in parallel, with each utxo contributing to the fee.
//
// Surrounding software must enforce the timeout period doesn't exceed 65,535 blocks.
// 
// String & op_return serializations:
//
// T,3,<authCat>,<timeout>,<receiptLockingBytecode>,<contractBytecode>
// 
// 6a 047574786f
// 01 54
// 01 03
// ...
//
//
// unlocking bytecode: 5379009c63517ab275c0cd527a8769c0ccc0c602c40994a2777767537a519c6900ce517a527e87777768

contract Timeout(

  // Category of the authenticating baton
  // The auth baton is managed by the wallet of the user, 
  // The contract is agnostic of the token paid to the receipt.
  bytes32 authCat,

  // length of time (blocks) to lock utxos 
  int timeout,

  // LockingBytecode of the beneficiary, the address receiving payments
  bytes recipientLockingBytecode

) {

  // OP_3 OP_PICK OP_0 OP_NUMEQUAL OP_IF 
  function execute() {

    // Require version 2 for BIP68 support
    // OP_TXVERSION OP_2 OP_NUMEQUALVERIFY
    require(tx.version == 2);

    // Check that time has passed and that time locks are enabled
    // OP_SWAP OP_CHECKSEQUENCEVERIFY OP_DROP 
    require(tx.age >= timeout, "must satisfy age (bip68)");

    // Check that each output sends to the recipient
    // OP_INPUTINDEX OP_OUTPUTBYTECODE OP_ROT OP_EQUALVERIFY 
    require(
        tx.outputs[this.activeInputIndex].lockingBytecode == 
        recipientLockingBytecode, "must pay receipt"
    );

    // Check that each output sends the balance minus an executor allowance
    // OP_INPUTINDEX OP_OUTPUTVALUE 
    // OP_INPUTINDEX OP_UTXOVALUE c409 OP_SUB OP_GREATERTHANOREQUAL 
    require(
        tx.outputs[this.activeInputIndex].value >= 
        tx.inputs[this.activeInputIndex].value - 2500, 
        "executor fee too high"
        );

    // Require tokens go forward
    // OP_INPUTINDEX OP_OUTPUTTOKENAMOUNT OP_INPUTINDEX OP_UTXOTOKENAMOUNT OP_NUMEQUALVERIFY 
    require(
        tx.outputs[this.activeInputIndex].tokenAmount == 
        tx.inputs[this.activeInputIndex].tokenAmount, 
        "must pass tokens"
        );

    // OP_INPUTINDEX OP_OUTPUTTOKENCATEGORY OP_INPUTINDEX OP_UTXOTOKENCATEGORY OP_EQUALVERIFY 
    require(
        tx.outputs[this.activeInputIndex].tokenCategory == 
        tx.inputs[this.activeInputIndex].tokenCategory, 
        "must be same token"
        );

    // OP_INPUTINDEX OP_OUTPUTTOKENCOMMITMENT OP_INPUTINDEX OP_UTXOTOKENCOMMITMENT OP_EQUAL
    require(
        tx.outputs[this.activeInputIndex].nftCommitment == 
        tx.inputs[this.activeInputIndex].nftCommitment, 
        "must pass NFT"
        );
        
  } // OP_NIP OP_NIP

  // Allow refreshing, or withdraw, with the authentication baton
  //  OP_ELSE OP_3 OP_ROLL OP_1 OP_NUMEQUALVERIFY 
  function administer() {

      // Authentication failed, script fails.
      // OP_0 OP_UTXOTOKENCATEGORY OP_SWAP OP_2 OP_CAT OP_EQUAL  //
      require(tx.inputs[0].tokenCategory == authCat + 0x02);
      
  } // OP_NIP OP_NIP OP_ENDIF

}