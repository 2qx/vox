{"version":3,"file":"CQVT_UhJ.js","sources":["../../../../../../../../node_modules/.pnpm/@electrum-cash+network@4.1.1_patch_hash=f7b2ff0ce9059e21d0dfacaf7f7db0c1c5e4577b1d6e7a96b6203dd195fbbc08/node_modules/@electrum-cash/network/dist/index.mjs"],"sourcesContent":["import $dvphU$electrumcashdebuglogs from \"@electrum-cash/debug-logs\";\nimport {EventEmitter as $dvphU$EventEmitter} from \"eventemitter3\";\nimport {Mutex as $dvphU$Mutex} from \"async-mutex\";\nimport {ElectrumWebSocket as $dvphU$ElectrumWebSocket} from \"@electrum-cash/web-socket\";\nimport {parse as $dvphU$parse, parseNumberAndBigInt as $dvphU$parseNumberAndBigInt} from \"lossless-json\";\n\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n\n\nclass $24139611f53a54b8$export$5d955335434540c6 {\n    /**\n\t * Helper function that builds an Electrum request object.\n\t *\n\t * @param method     - method to call.\n\t * @param parameters - method parameters for the call.\n\t * @param requestId  - unique string or number referencing this request.\n\t *\n\t * @returns a properly formatted Electrum request string.\n\t */ static buildRequestObject(method, parameters, requestId) {\n        // Return the formatted request object.\n        // NOTE: Electrum either uses JsonRPC strictly or loosely.\n        //       If we specify protocol identifier without being 100% compliant, we risk being disconnected/blacklisted.\n        //       For this reason, we omit the protocol identifier to avoid issues.\n        return JSON.stringify({\n            method: method,\n            params: parameters,\n            id: requestId\n        });\n    }\n    /**\n\t * Constant used to verify if a provided string is a valid version number.\n\t *\n\t * @returns a regular expression that matches valid version numbers.\n\t */ static get versionRegexp() {\n        return /^\\d+(\\.\\d+)+$/;\n    }\n    /**\n\t * Constant used to separate statements/messages in a stream of data.\n\t *\n\t * @returns the delimiter used by Electrum to separate statements.\n\t */ static get statementDelimiter() {\n        return \"\\n\";\n    }\n}\n\n\nvar $e83d2e7688025acd$exports = {};\n\n$parcel$export($e83d2e7688025acd$exports, \"isVersionRejected\", () => $e83d2e7688025acd$export$e1f38ab2b4ebdde6);\n$parcel$export($e83d2e7688025acd$exports, \"isVersionNegotiated\", () => $e83d2e7688025acd$export$9598f0c76aa41d73);\nconst $e83d2e7688025acd$export$e1f38ab2b4ebdde6 = function(object) {\n    return \"error\" in object;\n};\nconst $e83d2e7688025acd$export$9598f0c76aa41d73 = function(object) {\n    return \"software\" in object && \"protocol\" in object;\n};\n\n\n// Acceptable parameter types for RPC messages\nconst $abcb763a48577a1e$export$d73a2e87a509880 = function(message) {\n    return \"id\" in message && \"error\" in message;\n};\nconst $abcb763a48577a1e$export$81276773828ff315 = function(message) {\n    return \"id\" in message && \"result\" in message;\n};\nconst $abcb763a48577a1e$export$280de919a0cf6928 = function(message) {\n    return !(\"id\" in message) && \"method\" in message;\n};\nconst $abcb763a48577a1e$export$94e3360fcddccc76 = function(message) {\n    return \"id\" in message && \"method\" in message;\n};\n\n\n\nvar $db7c797e63383364$exports = {};\n\n$parcel$export($db7c797e63383364$exports, \"ConnectionStatus\", () => $db7c797e63383364$export$7516420eb880ab68);\n// Disable indent rule for this file because it is broken (https://github.com/typescript-eslint/typescript-eslint/issues/1824)\n/* eslint-disable @typescript-eslint/indent */ /**\n * Enum that denotes the connection status of an ElectrumConnection.\n * @enum {number}\n * @property {0} DISCONNECTED    The connection is disconnected.\n * @property {1} AVAILABLE       The connection is connected.\n * @property {2} DISCONNECTING   The connection is disconnecting.\n * @property {3} CONNECTING      The connection is connecting.\n * @property {4} RECONNECTING    The connection is restarting.\n */ var $db7c797e63383364$export$7516420eb880ab68;\n(function(ConnectionStatus) {\n    ConnectionStatus[ConnectionStatus[\"DISCONNECTED\"] = 0] = \"DISCONNECTED\";\n    ConnectionStatus[ConnectionStatus[\"CONNECTED\"] = 1] = \"CONNECTED\";\n    ConnectionStatus[ConnectionStatus[\"DISCONNECTING\"] = 2] = \"DISCONNECTING\";\n    ConnectionStatus[ConnectionStatus[\"CONNECTING\"] = 3] = \"CONNECTING\";\n    ConnectionStatus[ConnectionStatus[\"RECONNECTING\"] = 4] = \"RECONNECTING\";\n})($db7c797e63383364$export$7516420eb880ab68 || ($db7c797e63383364$export$7516420eb880ab68 = {}));\n\n\n\nclass $ff134c9a9e1f7361$export$de0f57fc22079b5e extends (0, $dvphU$EventEmitter) {\n    /**\n\t * Sets up network configuration for an Electrum client connection.\n\t *\n\t * @param application       - your application name, used to identify to the electrum host.\n\t * @param version           - protocol version to use with the host.\n\t * @param socketOrHostname  - pre-configured electrum socket or fully qualified domain name or IP number of the host\n\t * @param options           - ...\n\t *\n\t * @throws {Error} if `version` is not a valid version string.\n\t */ constructor(application, version, socketOrHostname, options){\n        // Initialize the event emitter.\n        super();\n        this.application = application;\n        this.version = version;\n        this.socketOrHostname = socketOrHostname;\n        this.options = options;\n        this.status = (0, $db7c797e63383364$export$7516420eb880ab68).DISCONNECTED;\n        this.verifications = [];\n        this.messageBuffer = \"\";\n        // Check if the provided version is a valid version number.\n        if (!(0, $24139611f53a54b8$export$5d955335434540c6).versionRegexp.test(version)) // Throw an error since the version number was not valid.\n        throw new Error(`Provided version string (${version}) is not a valid protocol version number.`);\n        // If a hostname was provided..\n        if (typeof socketOrHostname === \"string\") // Use a web socket with default parameters.\n        this.socket = new (0, $dvphU$ElectrumWebSocket)(socketOrHostname);\n        else // Use the provided socket.\n        this.socket = socketOrHostname;\n        // Set up handlers for connection and disconnection.\n        this.socket.on(\"connected\", this.onSocketConnect.bind(this));\n        this.socket.on(\"disconnected\", this.onSocketDisconnect.bind(this));\n        // Set up handler for incoming data.\n        this.socket.on(\"data\", this.parseMessageChunk.bind(this));\n        // Handle visibility changes when run in a browser environment.\n        if (typeof document !== \"undefined\") document.addEventListener(\"visibilitychange\", this.handleVisibilityChange.bind(this));\n        // Handle network connection changes when run in a browser environment.\n        if (typeof window !== \"undefined\") {\n            window.addEventListener(\"online\", this.handleNetworkChange.bind(this));\n            window.addEventListener(\"offline\", this.handleNetworkChange.bind(this));\n        }\n    }\n    // Expose hostIdentifier from the socket.\n    get hostIdentifier() {\n        return this.socket.hostIdentifier;\n    }\n    // Expose port from the socket.\n    get encrypted() {\n        return this.socket.encrypted;\n    }\n    /**\n\t * Assembles incoming data into statements and hands them off to the message parser.\n\t *\n\t * @param data - data to append to the current message buffer, as a string.\n\t *\n\t * @throws {SyntaxError} if the passed statement parts are not valid JSON.\n\t */ parseMessageChunk(data) {\n        // Update the timestamp for when we last received data.\n        this.lastReceivedTimestamp = Date.now();\n        // Emit a notification indicating that the connection has received data.\n        this.emit(\"received\");\n        // Clear and remove all verification timers.\n        this.verifications.forEach((timer)=>clearTimeout(timer));\n        this.verifications.length = 0;\n        // Add the message to the current message buffer.\n        this.messageBuffer += data;\n        // Check if the new message buffer contains the statement delimiter.\n        while(this.messageBuffer.includes((0, $24139611f53a54b8$export$5d955335434540c6).statementDelimiter)){\n            // Split message buffer into statements.\n            const statementParts = this.messageBuffer.split((0, $24139611f53a54b8$export$5d955335434540c6).statementDelimiter);\n            // For as long as we still have statements to parse..\n            while(statementParts.length > 1){\n                // Move the first statement to its own variable.\n                const currentStatementList = String(statementParts.shift());\n                // Parse the statement into an object or list of objects.\n                let statementList = (0, $dvphU$parse)(currentStatementList, null, this.options.useBigInt ? (0, $dvphU$parseNumberAndBigInt) : parseFloat);\n                // Wrap the statement in an array if it is not already a batched statement list.\n                if (!Array.isArray(statementList)) statementList = [\n                    statementList\n                ];\n                // For as long as there is statements in the result set..\n                while(statementList.length > 0){\n                    // Move the first statement from the batch to its own variable.\n                    const currentStatement = statementList.shift();\n                    // If the current statement is a subscription notification..\n                    if ((0, $abcb763a48577a1e$export$280de919a0cf6928)(currentStatement)) {\n                        // Emit the notification for handling higher up in the stack.\n                        this.emit(\"response\", currentStatement);\n                        continue;\n                    }\n                    // If the current statement is a version negotiation response..\n                    if (currentStatement.id === \"versionNegotiation\") {\n                        if ((0, $abcb763a48577a1e$export$d73a2e87a509880)(currentStatement)) // Then emit a failed version negotiation response signal.\n                        this.emit(\"version\", {\n                            error: currentStatement.error\n                        });\n                        else {\n                            // Extract the software and protocol version reported.\n                            const [software, protocol] = currentStatement.result;\n                            // Emit a successful version negotiation response signal.\n                            this.emit(\"version\", {\n                                software: software,\n                                protocol: protocol\n                            });\n                        }\n                        continue;\n                    }\n                    // If the current statement is a keep-alive response..\n                    if (currentStatement.id === \"keepAlive\") continue;\n                    // Emit the statements for handling higher up in the stack.\n                    this.emit(\"response\", currentStatement);\n                }\n            }\n            // Store the remaining statement as the current message buffer.\n            this.messageBuffer = statementParts.shift() || \"\";\n        }\n    }\n    /**\n\t * Sends a keep-alive message to the host.\n\t *\n\t * @returns true if the ping message was fully flushed to the socket, false if\n\t * part of the message is queued in the user memory\n\t */ ping() {\n        // Write a log message.\n        (0, $dvphU$electrumcashdebuglogs).ping(`Sending keep-alive ping to '${this.hostIdentifier}'`);\n        // Craft a keep-alive message.\n        const message = (0, $24139611f53a54b8$export$5d955335434540c6).buildRequestObject(\"server.ping\", [], \"keepAlive\");\n        // Send the keep-alive message.\n        const status = this.send(message);\n        // Return the ping status.\n        return status;\n    }\n    /**\n\t * Initiates the network connection negotiates a protocol version. Also emits the 'connect' signal if successful.\n\t *\n\t * @throws {Error} if the socket connection fails.\n\t * @returns a promise resolving when the connection is established\n\t */ async connect() {\n        // If we are already connected return true.\n        if (this.status === (0, $db7c797e63383364$export$7516420eb880ab68).CONNECTED) return;\n        // Indicate that the connection is connecting\n        this.status = (0, $db7c797e63383364$export$7516420eb880ab68).CONNECTING;\n        // Emit a connect event now that the connection is being set up.\n        this.emit(\"connecting\");\n        // Define a function to wrap connection as a promise.\n        const connectionResolver = (resolve, reject)=>{\n            const rejector = (error)=>{\n                // Set the status back to disconnected\n                this.status = (0, $db7c797e63383364$export$7516420eb880ab68).DISCONNECTED;\n                // Emit a connect event indicating that we failed to connect.\n                this.emit(\"disconnected\");\n                // Reject with the error as reason\n                reject(error);\n            };\n            // Replace previous error handlers to reject the promise on failure.\n            this.socket.removeAllListeners(\"error\");\n            this.socket.once(\"error\", rejector);\n            // Define a function to wrap version negotiation as a callback.\n            const versionNegotiator = ()=>{\n                // Write a log message to show that we have started version negotiation.\n                (0, $dvphU$electrumcashdebuglogs).network(`Requesting protocol version ${this.version} with '${this.hostIdentifier}'.`);\n                // remove the one-time error handler since no error was detected.\n                this.socket.removeListener(\"error\", rejector);\n                // Build a version negotiation message.\n                const versionMessage = (0, $24139611f53a54b8$export$5d955335434540c6).buildRequestObject(\"server.version\", [\n                    this.application,\n                    this.version\n                ], \"versionNegotiation\");\n                // Define a function to wrap version validation as a function.\n                const versionValidator = (version)=>{\n                    // Check if version negotiation failed.\n                    if ((0, $e83d2e7688025acd$export$e1f38ab2b4ebdde6)(version)) {\n                        // Disconnect from the host.\n                        this.disconnect(true);\n                        // Declare an error message.\n                        const errorMessage = \"unsupported protocol version.\";\n                        // Log the error.\n                        (0, $dvphU$electrumcashdebuglogs).errors(`Failed to connect with ${this.hostIdentifier} due to ${errorMessage}`);\n                        // Reject the connection with false since version negotiation failed.\n                        reject(errorMessage);\n                    } else if (version.protocol !== this.version && `${version.protocol}.0` !== this.version && `${version.protocol}.0.0` !== this.version) {\n                        // Disconnect from the host.\n                        this.disconnect(true);\n                        // Declare an error message.\n                        const errorMessage = `incompatible protocol version negotiated (${version.protocol} !== ${this.version}).`;\n                        // Log the error.\n                        (0, $dvphU$electrumcashdebuglogs).errors(`Failed to connect with ${this.hostIdentifier} due to ${errorMessage}`);\n                        // Reject the connection with false since version negotiation failed.\n                        reject(errorMessage);\n                    } else {\n                        // Write a log message.\n                        (0, $dvphU$electrumcashdebuglogs).network(`Negotiated protocol version ${version.protocol} with '${this.hostIdentifier}', powered by ${version.software}.`);\n                        // Set connection status to connected\n                        this.status = (0, $db7c797e63383364$export$7516420eb880ab68).CONNECTED;\n                        // Emit a connect event now that the connection is usable.\n                        this.emit(\"connected\");\n                        // Resolve the connection promise since we successfully connected and negotiated protocol version.\n                        resolve();\n                    }\n                };\n                // Listen for version negotiation once.\n                this.once(\"version\", versionValidator);\n                // Send the version negotiation message.\n                this.send(versionMessage);\n            };\n            // Prepare the version negotiation.\n            this.socket.once(\"connected\", versionNegotiator);\n            // Set up handler for network errors.\n            this.socket.on(\"error\", this.onSocketError.bind(this));\n            // Connect to the server.\n            this.socket.connect();\n        };\n        // Wait until connection is established and version negotiation succeeds.\n        await new Promise(connectionResolver);\n    }\n    /**\n\t * Restores the network connection.\n\t */ async reconnect() {\n        // If a reconnect timer is set, remove it\n        await this.clearReconnectTimer();\n        // Write a log message.\n        (0, $dvphU$electrumcashdebuglogs).network(`Trying to reconnect to '${this.hostIdentifier}'..`);\n        // Set the status to reconnecting for more accurate log messages.\n        this.status = (0, $db7c797e63383364$export$7516420eb880ab68).RECONNECTING;\n        // Emit a connect event now that the connection is usable.\n        this.emit(\"reconnecting\");\n        // Disconnect the underlying socket.\n        this.socket.disconnect();\n        try {\n            // Try to connect again.\n            await this.connect();\n        } catch (error) {\n        // Do nothing as the error should be handled via the disconnect and error signals.\n        }\n    }\n    /**\n\t * Removes the current reconnect timer.\n\t */ clearReconnectTimer() {\n        // If a reconnect timer is set, remove it\n        if (this.reconnectTimer) clearTimeout(this.reconnectTimer);\n        // Reset the timer reference.\n        this.reconnectTimer = undefined;\n    }\n    /**\n\t * Removes the current keep-alive timer.\n\t */ clearKeepAliveTimer() {\n        // If a keep-alive timer is set, remove it\n        if (this.keepAliveTimer) clearTimeout(this.keepAliveTimer);\n        // Reset the timer reference.\n        this.keepAliveTimer = undefined;\n    }\n    /**\n\t * Initializes the keep alive timer loop.\n\t */ setupKeepAliveTimer() {\n        // If the keep-alive timer loop is not currently set up..\n        if (!this.keepAliveTimer) // Set a new keep-alive timer.\n        this.keepAliveTimer = setTimeout(this.ping.bind(this), this.options.sendKeepAliveIntervalInMilliSeconds);\n    }\n    /**\n\t * Tears down the current connection and removes all event listeners on disconnect.\n\t *\n\t * @param force       - disconnect even if the connection has not been fully established yet.\n\t * @param intentional - update connection state if disconnect is intentional.\n\t *\n\t * @returns true if successfully disconnected, or false if there was no connection.\n\t */ async disconnect(force = false, intentional = true) {\n        // Return early when there is nothing to disconnect from\n        if (this.status === (0, $db7c797e63383364$export$7516420eb880ab68).DISCONNECTED && !force) // Return false to indicate that there was nothing to disconnect from.\n        return false;\n        // Update connection state if the disconnection is intentional.\n        // NOTE: The state is meant to represent what the client is requesting, but\n        //       is used internally to handle visibility changes in browsers to ensure functional reconnection.\n        if (intentional) // Set connection status to null to indicate tear-down is currently happening.\n        this.status = (0, $db7c797e63383364$export$7516420eb880ab68).DISCONNECTING;\n        // Emit a connect event to indicate that we are disconnecting.\n        this.emit(\"disconnecting\");\n        // If a keep-alive timer is set, remove it.\n        await this.clearKeepAliveTimer();\n        // If a reconnect timer is set, remove it\n        await this.clearReconnectTimer();\n        const disconnectResolver = (resolve)=>{\n            // Resolve to true after the connection emits a disconnect\n            this.once(\"disconnected\", ()=>resolve(true));\n            // Close the connection on the socket level.\n            this.socket.disconnect();\n        };\n        // Return true to indicate that we disconnected.\n        return new Promise(disconnectResolver);\n    }\n    /**\n\t * Updates the connection state based on browser reported connectivity.\n\t *\n\t * Most modern browsers are able to provide information on the connection state\n\t * which allows for significantly faster response times to network changes compared\n\t * to waiting for network requests to fail.\n\t *\n\t * When available, we make use of this to fail early to provide a better user experience.\n\t */ async handleNetworkChange() {\n        // Do nothing if we do not have the navigator available.\n        if (typeof window.navigator === \"undefined\") return;\n        // Attempt to reconnect to the network now that we may be online again.\n        if (window.navigator.onLine === true) this.reconnect();\n        // Disconnected from the network so that cleanup can happen while we're offline.\n        if (window.navigator.onLine !== true) {\n            const forceDisconnect = true;\n            const isUnintended = false;\n            this.disconnect(forceDisconnect, isUnintended);\n        }\n    }\n    /**\n\t * Updates connection state based on application visibility.\n\t *\n\t * Some browsers will disconnect network connections when the browser is out of focus,\n\t * which would normally cause our reconnect-on-timeout routines to trigger, but that\n\t * results in a poor user experience since the events are not handled consistently\n\t * and sometimes it can take some time after restoring focus to the browser.\n\t *\n\t * By manually disconnecting when this happens we prevent the default reconnection routines\n\t * and make the behavior consistent across browsers.\n\t */ async handleVisibilityChange() {\n        // Disconnect when application is removed from focus.\n        if (document.visibilityState === \"hidden\") {\n            const forceDisconnect = true;\n            const isUnintended = false;\n            this.disconnect(forceDisconnect, isUnintended);\n        }\n        // Reconnect when application is returned to focus.\n        if (document.visibilityState === \"visible\") this.reconnect();\n    }\n    /**\n\t * Sends an arbitrary message to the server.\n\t *\n\t * @param message - json encoded request object to send to the server, as a string.\n\t *\n\t * @returns true if the message was fully flushed to the socket, false if part of the message\n\t * is queued in the user memory\n\t */ send(message) {\n        // Remove the current keep-alive timer if it exists.\n        this.clearKeepAliveTimer();\n        // Get the current timestamp in milliseconds.\n        const currentTime = Date.now();\n        // Follow up and verify that the message got sent..\n        const verificationTimer = setTimeout(this.verifySend.bind(this, currentTime), this.socket.timeout);\n        // Store the verification timer locally so that it can be cleared when data has been received.\n        this.verifications.push(verificationTimer);\n        // Set a new keep-alive timer.\n        this.setupKeepAliveTimer();\n        // Write the message to the network socket.\n        return this.socket.write(message + (0, $24139611f53a54b8$export$5d955335434540c6).statementDelimiter);\n    }\n    // --- Event managers. --- //\n    /**\n\t * Marks the connection as timed out and schedules reconnection if we have not\n\t * received data within the expected time frame.\n\t */ verifySend(sentTimestamp) {\n        // If we haven't received any data since we last sent data out..\n        if (Number(this.lastReceivedTimestamp) < sentTimestamp) {\n            // If this connection is already disconnected, we do not change anything\n            if (this.status === (0, $db7c797e63383364$export$7516420eb880ab68).DISCONNECTED || this.status === (0, $db7c797e63383364$export$7516420eb880ab68).DISCONNECTING) // debug.warning(`Tried to verify already disconnected connection to '${this.hostIdentifier}'`);\n            return;\n            // Remove the current keep-alive timer if it exists.\n            this.clearKeepAliveTimer();\n            // Write a notification to the logs.\n            (0, $dvphU$electrumcashdebuglogs).network(`Connection to '${this.hostIdentifier}' timed out.`);\n            // Close the connection to avoid re-use.\n            // NOTE: This initiates reconnection routines if the connection has not\n            //       been marked as intentionally disconnected.\n            this.socket.disconnect();\n        }\n    }\n    /**\n\t * Updates the connection status when a connection is confirmed.\n\t */ onSocketConnect() {\n        // If a reconnect timer is set, remove it.\n        this.clearReconnectTimer();\n        // Set up the initial timestamp for when we last received data from the server.\n        this.lastReceivedTimestamp = Date.now();\n        // Set up the initial keep-alive timer.\n        this.setupKeepAliveTimer();\n        // Clear all temporary error listeners.\n        this.socket.removeAllListeners(\"error\");\n        // Set up handler for network errors.\n        this.socket.on(\"error\", this.onSocketError.bind(this));\n    }\n    /**\n\t * Updates the connection status when a connection is ended.\n\t */ onSocketDisconnect() {\n        // Remove the current keep-alive timer if it exists.\n        this.clearKeepAliveTimer();\n        // If this is a connection we're trying to tear down..\n        if (this.status === (0, $db7c797e63383364$export$7516420eb880ab68).DISCONNECTING) {\n            // Mark the connection as disconnected.\n            this.status = (0, $db7c797e63383364$export$7516420eb880ab68).DISCONNECTED;\n            // Send a disconnect signal higher up the stack.\n            this.emit(\"disconnected\");\n            // If a reconnect timer is set, remove it.\n            this.clearReconnectTimer();\n            // Remove all event listeners\n            this.removeAllListeners();\n            // Write a log message.\n            (0, $dvphU$electrumcashdebuglogs).network(`Disconnected from '${this.hostIdentifier}'.`);\n        } else {\n            // If this is for an established connection..\n            if (this.status === (0, $db7c797e63383364$export$7516420eb880ab68).CONNECTED) // Write a notification to the logs.\n            (0, $dvphU$electrumcashdebuglogs).errors(`Connection with '${this.hostIdentifier}' was closed, trying to reconnect in ${this.options.reconnectAfterMilliSeconds / 1000} seconds.`);\n            // Mark the connection as disconnected for now..\n            this.status = (0, $db7c797e63383364$export$7516420eb880ab68).DISCONNECTED;\n            // Send a disconnect signal higher up the stack.\n            this.emit(\"disconnected\");\n            // If we don't have a pending reconnection timer..\n            if (!this.reconnectTimer) // Attempt to reconnect after one keep-alive duration.\n            this.reconnectTimer = setTimeout(this.reconnect.bind(this), this.options.reconnectAfterMilliSeconds);\n        }\n    }\n    /**\n\t * Notify administrator of any unexpected errors.\n\t */ onSocketError(error) {\n        // Report a generic error if no error information is present.\n        // NOTE: When using WSS, the error event explicitly\n        //       only allows to send a \"simple\" event without data.\n        //       https://stackoverflow.com/a/18804298\n        if (typeof error === \"undefined\") // Do nothing, and instead rely on the socket disconnect event for further information.\n        return;\n        // Log the error, as there is nothing we can do to actually handle it.\n        (0, $dvphU$electrumcashdebuglogs).errors(`Network error ('${this.hostIdentifier}'): `, error);\n    }\n}\n\n\n\n// Define number of milliseconds per second for legibility.\nconst $d801b1f9b7fc3074$var$MILLI_SECONDS_PER_SECOND = 1000;\nconst $d801b1f9b7fc3074$export$5ba3a4134d0d751d = {\n    // By default, all numbers including integers are parsed as regular JavaScript numbers.\n    useBigInt: false,\n    // Send a ping message every seconds, to detect network problem as early as possible.\n    sendKeepAliveIntervalInMilliSeconds: 1 * $d801b1f9b7fc3074$var$MILLI_SECONDS_PER_SECOND,\n    // Try to reconnect 5 seconds after unintentional disconnects.\n    reconnectAfterMilliSeconds: 5 * $d801b1f9b7fc3074$var$MILLI_SECONDS_PER_SECOND,\n    // Try to detect stale connections 5 seconds after every send.\n    verifyConnectionTimeoutInMilliSeconds: 5 * $d801b1f9b7fc3074$var$MILLI_SECONDS_PER_SECOND\n};\n\n\n\n\n\n\n/**\n * High-level Electrum client that lets applications send requests and subscribe to notification events from a server.\n */ class $558b46d3f899ced5$var$ElectrumClient extends (0, $dvphU$EventEmitter) {\n    /**\n\t * Number corresponding to the underlying connection status.\n\t */ get status() {\n        return this.connection.status;\n    }\n    /**\n\t * Initializes an Electrum client.\n\t *\n\t * @param application       - your application name, used to identify to the electrum host.\n\t * @param version           - protocol version to use with the host.\n\t * @param socketOrHostname  - pre-configured electrum socket or fully qualified domain name or IP number of the host\n\t * @param options           - ...\n\t *\n\t * @throws {Error} if `version` is not a valid version string.\n\t */ constructor(application, version, socketOrHostname, options = {}){\n        // Initialize the event emitter.\n        super();\n        this.application = application;\n        this.version = version;\n        this.socketOrHostname = socketOrHostname;\n        this.options = options;\n        this.subscriptionMethods = {};\n        this.requestId = 0;\n        this.requestResolvers = {};\n        this.connectionLock = new (0, $dvphU$Mutex)();\n        // Update default options with the provided values.\n        const networkOptions = {\n            ...(0, $d801b1f9b7fc3074$export$5ba3a4134d0d751d),\n            ...options\n        };\n        // Set up a connection to an electrum server.\n        this.connection = new (0, $ff134c9a9e1f7361$export$de0f57fc22079b5e)(application, version, socketOrHostname, networkOptions);\n    }\n    // Expose hostIdentifier from the connection.\n    get hostIdentifier() {\n        return this.connection.hostIdentifier;\n    }\n    // Expose port from the connection.\n    get encrypted() {\n        return this.connection.encrypted;\n    }\n    /**\n\t * Connects to the remote server.\n\t *\n\t * @throws {Error} if the socket connection fails.\n\t * @returns a promise resolving when the connection is established.\n\t */ async connect() {\n        // Create a lock so that multiple connects/disconnects cannot race each other.\n        const unlock = await this.connectionLock.acquire();\n        try {\n            // If we are already connected, do not attempt to connect again.\n            if (this.connection.status === (0, $db7c797e63383364$export$7516420eb880ab68).CONNECTED) return;\n            // Listen for parsed statements.\n            this.connection.on(\"response\", this.response.bind(this));\n            // Hook up handles for the connected and disconnected events.\n            this.connection.on(\"connected\", this.resubscribeOnConnect.bind(this));\n            this.connection.on(\"disconnected\", this.onConnectionDisconnect.bind(this));\n            // Relay connecting and reconnecting events.\n            this.connection.on(\"connecting\", this.handleConnectionStatusChanges.bind(this, \"connecting\"));\n            this.connection.on(\"disconnecting\", this.handleConnectionStatusChanges.bind(this, \"disconnecting\"));\n            this.connection.on(\"reconnecting\", this.handleConnectionStatusChanges.bind(this, \"reconnecting\"));\n            // Hook up client metadata gathering functions.\n            this.connection.on(\"version\", this.storeSoftwareVersion.bind(this));\n            this.connection.on(\"received\", this.updateLastReceivedTimestamp.bind(this));\n            // Relay error events.\n            this.connection.on(\"error\", this.emit.bind(this, \"error\"));\n            // Connect with the server.\n            await this.connection.connect();\n        } finally{\n            unlock();\n        }\n    }\n    /**\n\t * Disconnects from the remote server and removes all event listeners/subscriptions and open requests.\n\t *\n\t * @param force               - disconnect even if the connection has not been fully established yet.\n\t * @param retainSubscriptions - retain subscription data so they will be restored on reconnection.\n\t *\n\t * @returns true if successfully disconnected, or false if there was no connection.\n\t */ async disconnect(force = false, retainSubscriptions = false) {\n        if (!retainSubscriptions) {\n            // Cancel all event listeners.\n            this.removeAllListeners();\n            // Remove all subscription data\n            this.subscriptionMethods = {};\n        }\n        // Disconnect from the remote server.\n        return this.connection.disconnect(force);\n    }\n    /**\n\t * Calls a method on the remote server with the supplied parameters.\n\t *\n\t * @param method     - name of the method to call.\n\t * @param parameters - one or more parameters for the method.\n\t *\n\t * @throws {Error} if the client is disconnected.\n\t * @returns a promise that resolves with the result of the method or an Error.\n\t */ async request(method, ...parameters) {\n        // If we are not connected to a server..\n        if (this.connection.status !== (0, $db7c797e63383364$export$7516420eb880ab68).CONNECTED) // Reject the request with a disconnected error message.\n        throw new Error(`Unable to send request to a disconnected server '${this.hostIdentifier}'.`);\n        // Increase the request ID by one.\n        this.requestId += 1;\n        // Store a copy of the request id.\n        const id = this.requestId;\n        // Format the arguments as an electrum request object.\n        const message = (0, $24139611f53a54b8$export$5d955335434540c6).buildRequestObject(method, parameters, id);\n        // Define a function to wrap the request in a promise.\n        const requestResolver = (resolve)=>{\n            // Add a request resolver for this promise to the list of requests.\n            this.requestResolvers[id] = (error, data)=>{\n                // If the resolution failed..\n                if (error) // Resolve the promise with the error for the application to handle.\n                resolve(error);\n                else // Resolve the promise with the request results.\n                resolve(data);\n            };\n            // Send the request message to the remote server.\n            this.connection.send(message);\n        };\n        // Write a log message.\n        (0, $dvphU$electrumcashdebuglogs).network(`Sending request '${method}' to '${this.hostIdentifier}'`);\n        // return a promise to deliver results later.\n        return new Promise(requestResolver);\n    }\n    /**\n\t * Subscribes to the method and payload at the server.\n\t *\n\t * @remarks the response for the subscription request is issued as a notification event.\n\t *\n\t * @param method     - one of the subscribable methods the server supports.\n\t * @param parameters - one or more parameters for the method.\n\t *\n\t * @throws {Error} if the client is disconnected.\n\t * @returns a promise resolving when the subscription is established.\n\t */ async subscribe(method, ...parameters) {\n        // Initialize an empty list of subscription payloads, if needed.\n        if (!this.subscriptionMethods[method]) this.subscriptionMethods[method] = new Set();\n        // Store the subscription parameters to track what data we have subscribed to.\n        this.subscriptionMethods[method].add(JSON.stringify(parameters));\n        // Send initial subscription request.\n        const requestData = await this.request(method, ...parameters);\n        // If the request failed, throw it as an error.\n        if (requestData instanceof Error) throw requestData;\n        // If the request returned more than one data point..\n        if (Array.isArray(requestData)) // .. throw an error, as this breaks our expectation for subscriptions.\n        throw new Error(\"Subscription request returned an more than one data point.\");\n        // Construct a notification structure to package the initial result as a notification.\n        const notification = {\n            jsonrpc: \"2.0\",\n            method: method,\n            params: [\n                ...parameters,\n                requestData\n            ]\n        };\n        // Manually emit an event for the initial response.\n        this.emit(\"notification\", notification);\n        // Try to update the chain height.\n        this.updateChainHeightFromHeadersNotifications(notification);\n    }\n    /**\n\t * Unsubscribes to the method at the server and removes any callback functions\n\t * when there are no more subscriptions for the method.\n\t *\n\t * @param method     - a previously subscribed to method.\n\t * @param parameters - one or more parameters for the method.\n\t *\n\t * @throws {Error} if no subscriptions exist for the combination of the provided `method` and `parameters.\n\t * @throws {Error} if the client is disconnected.\n\t * @returns a promise resolving when the subscription is removed.\n\t */ async unsubscribe(method, ...parameters) {\n        // Throw an error if the client is disconnected.\n        if (this.connection.status !== (0, $db7c797e63383364$export$7516420eb880ab68).CONNECTED) throw new Error(`Unable to send unsubscribe request to a disconnected server '${this.hostIdentifier}'.`);\n        // If this method has no subscriptions..\n        if (!this.subscriptionMethods[method]) // Reject this promise with an explanation.\n        throw new Error(`Cannot unsubscribe from '${method}' since the method has no subscriptions.`);\n        // Pack up the parameters as a long string.\n        const subscriptionParameters = JSON.stringify(parameters);\n        // If the method payload could not be located..\n        if (!this.subscriptionMethods[method].has(subscriptionParameters)) // Reject this promise with an explanation.\n        throw new Error(`Cannot unsubscribe from '${method}' since it has no subscription with the given parameters.`);\n        // Remove this specific subscription payload from internal tracking.\n        this.subscriptionMethods[method].delete(subscriptionParameters);\n        // Send unsubscription request to the server\n        // NOTE: As a convenience we allow users to define the method as the subscribe or unsubscribe version.\n        await this.request(method.replace(\".subscribe\", \".unsubscribe\"), ...parameters);\n        // Write a log message.\n        (0, $dvphU$electrumcashdebuglogs).client(`Unsubscribed from '${String(method)}' for the '${subscriptionParameters}' parameters.`);\n    }\n    /**\n\t * Restores existing subscriptions without updating status or triggering manual callbacks.\n\t *\n\t * @throws {Error} if subscription data cannot be found for all stored event names.\n\t * @throws {Error} if the client is disconnected.\n\t * @returns a promise resolving to true when the subscriptions are restored.\n\t *\n\t * @ignore\n\t */ async resubscribeOnConnect() {\n        // Write a log message.\n        (0, $dvphU$electrumcashdebuglogs).client(`Connected to '${this.hostIdentifier}'.`);\n        // Synchronize with the underlying connection status.\n        this.handleConnectionStatusChanges(\"connected\");\n        // Initialize an empty list of resubscription promises.\n        const resubscriptionPromises = [];\n        // For each method we have a subscription for..\n        for(const method in this.subscriptionMethods){\n            // .. and for each parameter we have previously been subscribed to..\n            for (const parameterJSON of this.subscriptionMethods[method].values()){\n                // restore the parameters from JSON.\n                const parameters = JSON.parse(parameterJSON);\n                // Send a subscription request.\n                resubscriptionPromises.push(this.subscribe(method, ...parameters));\n            }\n            // Wait for all re-subscriptions to complete.\n            await Promise.all(resubscriptionPromises);\n        }\n        // Write a log message if there was any subscriptions to restore.\n        if (resubscriptionPromises.length > 0) (0, $dvphU$electrumcashdebuglogs).client(`Restored ${resubscriptionPromises.length} previous subscriptions for '${this.hostIdentifier}'`);\n    }\n    /**\n\t * Parser messages from the remote server to resolve request promises and emit subscription events.\n\t *\n\t * @param message - the response message\n\t *\n\t * @throws {Error} if the message ID does not match an existing request.\n\t * @ignore\n\t */ response(message) {\n        // If the received message is a notification, we forward it to all event listeners\n        if ((0, $abcb763a48577a1e$export$280de919a0cf6928)(message)) {\n            // Write a log message.\n            (0, $dvphU$electrumcashdebuglogs).client(`Received notification for '${message.method}' from '${this.hostIdentifier}'`);\n            // Forward the message content to all event listeners.\n            this.emit(\"notification\", message);\n            // Try to update the chain height.\n            this.updateChainHeightFromHeadersNotifications(message);\n            // Return since it does not have an associated request resolver\n            return;\n        }\n        // If the response ID is null we cannot use it to index our request resolvers\n        if (message.id === null) // Throw an internal error, this should not happen.\n        throw new Error(\"Internal error: Received an RPC response with ID null.\");\n        // Look up which request promise we should resolve this.\n        const requestResolver = this.requestResolvers[message.id];\n        // If we do not have a request resolver for this response message..\n        if (!requestResolver) {\n            // Log that a message was ignored since the request has already been rejected.\n            (0, $dvphU$electrumcashdebuglogs).warning(`Ignoring response #${message.id} as the request has already been rejected.`);\n            // Return as this has now been fully handled.\n            return;\n        }\n        // Remove the promise from the request list.\n        delete this.requestResolvers[message.id];\n        // If the message contains an error..\n        if ((0, $abcb763a48577a1e$export$d73a2e87a509880)(message)) // Forward the message error to the request resolver and omit the `result` parameter.\n        requestResolver(new Error(message.error.message));\n        else {\n            // Forward the message content to the request resolver and omit the `error` parameter\n            // (by setting it to undefined).\n            requestResolver(undefined, message.result);\n            // Attempt to extract genesis hash from feature requests.\n            this.storeGenesisHashFromFeaturesResponse(message);\n        }\n    }\n    /**\n\t * Callback function that is called when connection to the Electrum server is lost.\n\t * Aborts all active requests with an error message indicating that connection was lost.\n\t *\n\t * @ignore\n\t */ async onConnectionDisconnect() {\n        // Loop over active requests\n        for(const resolverId in this.requestResolvers){\n            // Extract request resolver for readability\n            const requestResolver = this.requestResolvers[resolverId];\n            // Resolve the active request with an error indicating that the connection was lost.\n            requestResolver(new Error(\"Connection lost\"));\n            // Remove the promise from the request list.\n            delete this.requestResolvers[resolverId];\n        }\n        // Synchronize with the underlying connection status.\n        this.handleConnectionStatusChanges(\"disconnected\");\n    }\n    /**\n\t * Stores the server provider software version field on successful version negotiation.\n\t *\n\t * @ignore\n\t */ async storeSoftwareVersion(versionStatement) {\n        // TODO: handle failed version negotiation better.\n        if (versionStatement.error) // Do nothing.\n        return;\n        // Store the software version.\n        this.software = versionStatement.software;\n    }\n    /**\n\t * Updates the last received timestamp.\n\t *\n\t * @ignore\n\t */ async updateLastReceivedTimestamp() {\n        // Update the timestamp for when we last received data.\n        this.lastReceivedTimestamp = Date.now();\n    }\n    /**\n\t * Checks if the provided message is a response to a headers subscription,\n\t * and if so updates the locally stored chain height value for this client.\n\t *\n\t * @ignore\n\t */ async updateChainHeightFromHeadersNotifications(message) {\n        // If the message is a notification for a new chain height..\n        if (message.method === \"blockchain.headers.subscribe\") // ..also store the updated chain height locally.\n        this.chainHeight = message.params[0].height;\n    }\n    /**\n\t * Checks if the provided message is a response to a server.features request,\n\t * and if so stores the genesis hash for this client locally.\n\t *\n\t * @ignore\n\t */ async storeGenesisHashFromFeaturesResponse(message) {\n        try {\n            // If the message is a response to a features request..\n            if (typeof message.result.genesis_hash !== \"undefined\") // ..store the genesis hash locally.\n            this.genesisHash = message.result.genesis_hash;\n        } catch (error) {\n        // Do nothing.\n        }\n    }\n    /**\n\t * Helper function to synchronize state and events with the underlying connection.\n\t */ async handleConnectionStatusChanges(eventName) {\n        // Re-emit the event.\n        this.emit(eventName);\n    }\n}\nvar // Export the client.\n$558b46d3f899ced5$export$2e2bcd8739ae039 = $558b46d3f899ced5$var$ElectrumClient;\n\n\n\n\n\n\nexport {$558b46d3f899ced5$export$2e2bcd8739ae039 as ElectrumClient, $e83d2e7688025acd$export$e1f38ab2b4ebdde6 as isVersionRejected, $e83d2e7688025acd$export$9598f0c76aa41d73 as isVersionNegotiated, $db7c797e63383364$export$7516420eb880ab68 as ConnectionStatus};\n//# sourceMappingURL=index.mjs.map\n"],"names":["$parcel$export","e","n","v","s","$24139611f53a54b8$export$5d955335434540c6","method","parameters","requestId","$e83d2e7688025acd$exports","$e83d2e7688025acd$export$e1f38ab2b4ebdde6","$e83d2e7688025acd$export$9598f0c76aa41d73","object","$abcb763a48577a1e$export$d73a2e87a509880","message","$abcb763a48577a1e$export$280de919a0cf6928","$db7c797e63383364$exports","$db7c797e63383364$export$7516420eb880ab68","ConnectionStatus","$ff134c9a9e1f7361$export$de0f57fc22079b5e","$dvphU$EventEmitter","application","version","socketOrHostname","options","$dvphU$ElectrumWebSocket","data","timer","statementParts","currentStatementList","statementList","$dvphU$parse","$dvphU$parseNumberAndBigInt","currentStatement","software","protocol","$dvphU$electrumcashdebuglogs","connectionResolver","resolve","reject","rejector","error","versionNegotiator","versionMessage","versionValidator","errorMessage","force","intentional","disconnectResolver","currentTime","verificationTimer","sentTimestamp","$d801b1f9b7fc3074$var$MILLI_SECONDS_PER_SECOND","$d801b1f9b7fc3074$export$5ba3a4134d0d751d","$558b46d3f899ced5$var$ElectrumClient","$dvphU$Mutex","networkOptions","unlock","retainSubscriptions","id","requestResolver","requestData","notification","subscriptionParameters","resubscriptionPromises","parameterJSON","resolverId","versionStatement","eventName","$558b46d3f899ced5$export$2e2bcd8739ae039"],"mappings":"qEAOA,SAASA,EAAeC,EAAGC,EAAGC,EAAGC,EAAG,CAClC,OAAO,eAAeH,EAAGC,EAAG,CAAC,IAAKC,EAAG,IAAKC,EAAG,WAAY,GAAM,aAAc,EAAI,CAAC,CACpF,CAIA,MAAMC,CAA0C,CAS3C,OAAO,mBAAmBC,EAAQC,EAAYC,EAAW,CAKtD,OAAO,KAAK,UAAU,CAClB,OAAQF,EACR,OAAQC,EACR,GAAIC,CAChB,CAAS,CACT,CAKK,WAAW,eAAgB,CACxB,MAAO,eACf,CAKK,WAAW,oBAAqB,CAC7B,MAAO;AAAA,CACf,CACA,CAGA,IAAIC,EAA4B,CAAE,EAElCT,EAAeS,EAA2B,oBAAqB,IAAMC,CAAyC,EAC9GV,EAAeS,EAA2B,sBAAuB,IAAME,CAAyC,EAChH,MAAMD,EAA4C,SAASE,EAAQ,CAC/D,MAAO,UAAWA,CACtB,EACMD,EAA4C,SAASC,EAAQ,CAC/D,MAAO,aAAcA,GAAU,aAAcA,CACjD,EAIMC,EAA2C,SAASC,EAAS,CAC/D,MAAO,OAAQA,GAAW,UAAWA,CACzC,EAIMC,EAA4C,SAASD,EAAS,CAChE,MAAO,EAAE,OAAQA,IAAY,WAAYA,CAC7C,EAOA,IAAIE,EAA4B,CAAE,EAElChB,EAAegB,EAA2B,mBAAoB,IAAMC,CAAyC,EAUtG,IAACA,GACP,SAASC,EAAkB,CACxBA,EAAiBA,EAAiB,aAAkB,CAAC,EAAI,eACzDA,EAAiBA,EAAiB,UAAe,CAAC,EAAI,YACtDA,EAAiBA,EAAiB,cAAmB,CAAC,EAAI,gBAC1DA,EAAiBA,EAAiB,WAAgB,CAAC,EAAI,aACvDA,EAAiBA,EAAiB,aAAkB,CAAC,EAAI,cAC7D,GAAGD,IAA8CA,EAA4C,CAAA,EAAG,EAIhG,MAAME,UAAsDC,CAAqB,CAU5E,YAAYC,EAAaC,EAASC,EAAkBC,EAAQ,CAWzD,GATA,MAAO,EACP,KAAK,YAAcH,EACnB,KAAK,QAAUC,EACf,KAAK,iBAAmBC,EACxB,KAAK,QAAUC,EACf,KAAK,OAAaP,EAA2C,aAC7D,KAAK,cAAgB,CAAE,EACvB,KAAK,cAAgB,GAEjB,CAAKZ,EAA2C,cAAc,KAAKiB,CAAO,EAC9E,MAAM,IAAI,MAAM,4BAA4BA,CAAO,2CAA2C,EAE1F,OAAOC,GAAqB,SAChC,KAAK,OAAS,IAAQE,EAA0BF,CAAgB,EAEhE,KAAK,OAASA,EAEd,KAAK,OAAO,GAAG,YAAa,KAAK,gBAAgB,KAAK,IAAI,CAAC,EAC3D,KAAK,OAAO,GAAG,eAAgB,KAAK,mBAAmB,KAAK,IAAI,CAAC,EAEjE,KAAK,OAAO,GAAG,OAAQ,KAAK,kBAAkB,KAAK,IAAI,CAAC,EAEpD,OAAO,SAAa,KAAa,SAAS,iBAAiB,mBAAoB,KAAK,uBAAuB,KAAK,IAAI,CAAC,EAErH,OAAO,OAAW,MAClB,OAAO,iBAAiB,SAAU,KAAK,oBAAoB,KAAK,IAAI,CAAC,EACrE,OAAO,iBAAiB,UAAW,KAAK,oBAAoB,KAAK,IAAI,CAAC,EAElF,CAEI,IAAI,gBAAiB,CACjB,OAAO,KAAK,OAAO,cAC3B,CAEI,IAAI,WAAY,CACZ,OAAO,KAAK,OAAO,SAC3B,CAOK,kBAAkBG,EAAM,CAWrB,IATA,KAAK,sBAAwB,KAAK,IAAK,EAEvC,KAAK,KAAK,UAAU,EAEpB,KAAK,cAAc,QAASC,GAAQ,aAAaA,CAAK,CAAC,EACvD,KAAK,cAAc,OAAS,EAE5B,KAAK,eAAiBD,EAEhB,KAAK,cAAc,SAAarB,EAA2C,kBAAkB,GAAE,CAEjG,MAAMuB,EAAiB,KAAK,cAAc,MAAUvB,EAA2C,kBAAkB,EAEjH,KAAMuB,EAAe,OAAS,GAAE,CAE5B,MAAMC,EAAuB,OAAOD,EAAe,MAAK,CAAE,EAE1D,IAAIE,EAAoBC,EAAcF,EAAsB,KAAM,KAAK,QAAQ,UAAgBG,EAA+B,UAAU,EAMxI,IAJK,MAAM,QAAQF,CAAa,IAAGA,EAAgB,CAC/CA,CACH,GAEKA,EAAc,OAAS,GAAE,CAE3B,MAAMG,EAAmBH,EAAc,MAAO,EAE9C,GAAQf,EAA2CkB,CAAgB,EAAG,CAElE,KAAK,KAAK,WAAYA,CAAgB,EACtC,QACxB,CAEoB,GAAIA,EAAiB,KAAO,qBAAsB,CAC9C,GAAQpB,EAA0CoB,CAAgB,EAClE,KAAK,KAAK,UAAW,CACjB,MAAOA,EAAiB,KACpD,CAAyB,MACI,CAED,KAAM,CAACC,EAAUC,CAAQ,EAAIF,EAAiB,OAE9C,KAAK,KAAK,UAAW,CACjB,SAAUC,EACV,SAAUC,CAC1C,CAA6B,CAC7B,CACwB,QACxB,CAEwBF,EAAiB,KAAO,aAE5B,KAAK,KAAK,WAAYA,CAAgB,CAC1D,CACA,CAEY,KAAK,cAAgBL,EAAe,MAAO,GAAI,EAC3D,CACA,CAMK,MAAO,CAEAQ,EAA8B,KAAK,+BAA+B,KAAK,cAAc,GAAG,EAE5F,MAAMtB,EAAcT,EAA2C,mBAAmB,cAAe,CAAE,EAAE,WAAW,EAIhH,OAFe,KAAK,KAAKS,CAAO,CAGxC,CAMK,MAAM,SAAU,CAEb,GAAI,KAAK,SAAeG,EAA2C,UAAW,OAE9E,KAAK,OAAaA,EAA2C,WAE7D,KAAK,KAAK,YAAY,EAEtB,MAAMoB,EAAqB,CAACC,EAASC,IAAS,CAC1C,MAAMC,EAAYC,GAAQ,CAEtB,KAAK,OAAaxB,EAA2C,aAE7D,KAAK,KAAK,cAAc,EAExBsB,EAAOE,CAAK,CACf,EAED,KAAK,OAAO,mBAAmB,OAAO,EACtC,KAAK,OAAO,KAAK,QAASD,CAAQ,EAElC,MAAME,EAAoB,IAAI,CAEtBN,EAA8B,QAAQ,+BAA+B,KAAK,OAAO,UAAU,KAAK,cAAc,IAAI,EAEtH,KAAK,OAAO,eAAe,QAASI,CAAQ,EAE5C,MAAMG,EAAqBtC,EAA2C,mBAAmB,iBAAkB,CACvG,KAAK,YACL,KAAK,OACR,EAAE,oBAAoB,EAEjBuC,EAAoBtB,GAAU,CAEhC,GAAQZ,EAA2CY,CAAO,EAAG,CAEzD,KAAK,WAAW,EAAI,EAEpB,MAAMuB,EAAe,gCAEjBT,EAA8B,OAAO,0BAA0B,KAAK,cAAc,WAAWS,CAAY,EAAE,EAE/GN,EAAOM,CAAY,CAC3C,SAA+BvB,EAAQ,WAAa,KAAK,SAAW,GAAGA,EAAQ,QAAQ,OAAS,KAAK,SAAW,GAAGA,EAAQ,QAAQ,SAAW,KAAK,QAAS,CAEpI,KAAK,WAAW,EAAI,EAEpB,MAAMuB,EAAe,6CAA6CvB,EAAQ,QAAQ,QAAQ,KAAK,OAAO,KAElGc,EAA8B,OAAO,0BAA0B,KAAK,cAAc,WAAWS,CAAY,EAAE,EAE/GN,EAAOM,CAAY,CAC3C,MAE4BT,EAA8B,QAAQ,+BAA+Bd,EAAQ,QAAQ,UAAU,KAAK,cAAc,iBAAiBA,EAAQ,QAAQ,GAAG,EAE1J,KAAK,OAAaL,EAA2C,UAE7D,KAAK,KAAK,WAAW,EAErBqB,EAAS,CAEhB,EAED,KAAK,KAAK,UAAWM,CAAgB,EAErC,KAAK,KAAKD,CAAc,CAC3B,EAED,KAAK,OAAO,KAAK,YAAaD,CAAiB,EAE/C,KAAK,OAAO,GAAG,QAAS,KAAK,cAAc,KAAK,IAAI,CAAC,EAErD,KAAK,OAAO,QAAS,CACxB,EAED,MAAM,IAAI,QAAQL,CAAkB,CAC5C,CAGK,MAAM,WAAY,CAEf,MAAM,KAAK,oBAAqB,EAE5BD,EAA8B,QAAQ,2BAA2B,KAAK,cAAc,KAAK,EAE7F,KAAK,OAAanB,EAA2C,aAE7D,KAAK,KAAK,cAAc,EAExB,KAAK,OAAO,WAAY,EACxB,GAAI,CAEA,MAAM,KAAK,QAAS,CACvB,MAAe,CAExB,CACA,CAGK,qBAAsB,CAEf,KAAK,gBAAgB,aAAa,KAAK,cAAc,EAEzD,KAAK,eAAiB,MAC9B,CAGK,qBAAsB,CAEf,KAAK,gBAAgB,aAAa,KAAK,cAAc,EAEzD,KAAK,eAAiB,MAC9B,CAGK,qBAAsB,CAEd,KAAK,iBACV,KAAK,eAAiB,WAAW,KAAK,KAAK,KAAK,IAAI,EAAG,KAAK,QAAQ,mCAAmC,EAC/G,CAQK,MAAM,WAAW6B,EAAQ,GAAOC,EAAc,GAAM,CAEjD,GAAI,KAAK,SAAe9B,EAA2C,cAAgB,CAAC6B,EACpF,MAAO,GAIHC,IACJ,KAAK,OAAa9B,EAA2C,eAE7D,KAAK,KAAK,eAAe,EAEzB,MAAM,KAAK,oBAAqB,EAEhC,MAAM,KAAK,oBAAqB,EAChC,MAAM+B,EAAsBV,GAAU,CAElC,KAAK,KAAK,eAAgB,IAAIA,EAAQ,EAAI,CAAC,EAE3C,KAAK,OAAO,WAAY,CAC3B,EAED,OAAO,IAAI,QAAQU,CAAkB,CAC7C,CASK,MAAM,qBAAsB,CAErB,OAAO,OAAO,UAAc,MAE5B,OAAO,UAAU,SAAW,IAAM,KAAK,UAAW,EAElD,OAAO,UAAU,SAAW,IAG5B,KAAK,WAAW,GAAiB,EAAY,EAEzD,CAWK,MAAM,wBAAyB,CAExB,SAAS,kBAAoB,UAG7B,KAAK,WAAW,GAAiB,EAAY,EAG7C,SAAS,kBAAoB,WAAW,KAAK,UAAW,CACpE,CAQK,KAAKlC,EAAS,CAEX,KAAK,oBAAqB,EAE1B,MAAMmC,EAAc,KAAK,IAAK,EAExBC,EAAoB,WAAW,KAAK,WAAW,KAAK,KAAMD,CAAW,EAAG,KAAK,OAAO,OAAO,EAEjG,YAAK,cAAc,KAAKC,CAAiB,EAEzC,KAAK,oBAAqB,EAEnB,KAAK,OAAO,MAAMpC,EAAcT,EAA2C,kBAAkB,CAC5G,CAKK,WAAW8C,EAAe,CAEvB,GAAI,OAAO,KAAK,qBAAqB,EAAIA,EAAe,CAEpD,GAAI,KAAK,SAAelC,EAA2C,cAAgB,KAAK,SAAeA,EAA2C,cAClJ,OAEA,KAAK,oBAAqB,EAEtBmB,EAA8B,QAAQ,kBAAkB,KAAK,cAAc,cAAc,EAI7F,KAAK,OAAO,WAAY,CACpC,CACA,CAGK,iBAAkB,CAEf,KAAK,oBAAqB,EAE1B,KAAK,sBAAwB,KAAK,IAAK,EAEvC,KAAK,oBAAqB,EAE1B,KAAK,OAAO,mBAAmB,OAAO,EAEtC,KAAK,OAAO,GAAG,QAAS,KAAK,cAAc,KAAK,IAAI,CAAC,CAC7D,CAGK,oBAAqB,CAElB,KAAK,oBAAqB,EAEtB,KAAK,SAAenB,EAA2C,eAE/D,KAAK,OAAaA,EAA2C,aAE7D,KAAK,KAAK,cAAc,EAExB,KAAK,oBAAqB,EAE1B,KAAK,mBAAoB,EAErBmB,EAA8B,QAAQ,sBAAsB,KAAK,cAAc,IAAI,IAGnF,KAAK,SAAenB,EAA2C,WAC/DmB,EAA8B,OAAO,oBAAoB,KAAK,cAAc,wCAAwC,KAAK,QAAQ,2BAA6B,GAAI,WAAW,EAEjL,KAAK,OAAanB,EAA2C,aAE7D,KAAK,KAAK,cAAc,EAEnB,KAAK,iBACV,KAAK,eAAiB,WAAW,KAAK,UAAU,KAAK,IAAI,EAAG,KAAK,QAAQ,0BAA0B,GAE/G,CAGK,cAAcwB,EAAO,CAKd,OAAOA,EAAU,KAGjBL,EAA8B,OAAO,mBAAmB,KAAK,cAAc,OAAQK,CAAK,CACpG,CACA,CAKA,MAAMW,EAAiD,IACjDC,EAA4C,CAE9C,UAAW,GAEX,oCAAqC,EAAID,EAEzC,2BAA4B,EAAIA,EAEhC,sCAAuC,EAAIA,CAC/C,EASI,MAAME,UAAiDlC,CAAqB,CAG3E,IAAI,QAAS,CACV,OAAO,KAAK,WAAW,MAC/B,CAUK,YAAYC,EAAaC,EAASC,EAAkBC,EAAU,CAAA,EAAG,CAE9D,MAAO,EACP,KAAK,YAAcH,EACnB,KAAK,QAAUC,EACf,KAAK,iBAAmBC,EACxB,KAAK,QAAUC,EACf,KAAK,oBAAsB,CAAE,EAC7B,KAAK,UAAY,EACjB,KAAK,iBAAmB,CAAE,EAC1B,KAAK,eAAiB,IAAQ+B,EAE9B,MAAMC,EAAiB,CACnB,GAAOH,EACP,GAAG7B,CACN,EAED,KAAK,WAAa,IAAQL,EAA2CE,EAAaC,EAASC,EAAkBiC,CAAc,CACnI,CAEI,IAAI,gBAAiB,CACjB,OAAO,KAAK,WAAW,cAC/B,CAEI,IAAI,WAAY,CACZ,OAAO,KAAK,WAAW,SAC/B,CAMK,MAAM,SAAU,CAEb,MAAMC,EAAS,MAAM,KAAK,eAAe,QAAS,EAClD,GAAI,CAEA,GAAI,KAAK,WAAW,SAAexC,EAA2C,UAAW,OAEzF,KAAK,WAAW,GAAG,WAAY,KAAK,SAAS,KAAK,IAAI,CAAC,EAEvD,KAAK,WAAW,GAAG,YAAa,KAAK,qBAAqB,KAAK,IAAI,CAAC,EACpE,KAAK,WAAW,GAAG,eAAgB,KAAK,uBAAuB,KAAK,IAAI,CAAC,EAEzE,KAAK,WAAW,GAAG,aAAc,KAAK,8BAA8B,KAAK,KAAM,YAAY,CAAC,EAC5F,KAAK,WAAW,GAAG,gBAAiB,KAAK,8BAA8B,KAAK,KAAM,eAAe,CAAC,EAClG,KAAK,WAAW,GAAG,eAAgB,KAAK,8BAA8B,KAAK,KAAM,cAAc,CAAC,EAEhG,KAAK,WAAW,GAAG,UAAW,KAAK,qBAAqB,KAAK,IAAI,CAAC,EAClE,KAAK,WAAW,GAAG,WAAY,KAAK,4BAA4B,KAAK,IAAI,CAAC,EAE1E,KAAK,WAAW,GAAG,QAAS,KAAK,KAAK,KAAK,KAAM,OAAO,CAAC,EAEzD,MAAM,KAAK,WAAW,QAAS,CAC3C,QAAiB,CACLwC,EAAQ,CACpB,CACA,CAQK,MAAM,WAAWX,EAAQ,GAAOY,EAAsB,GAAO,CAC1D,OAAKA,IAED,KAAK,mBAAoB,EAEzB,KAAK,oBAAsB,CAAE,GAG1B,KAAK,WAAW,WAAWZ,CAAK,CAC/C,CASK,MAAM,QAAQxC,KAAWC,EAAY,CAElC,GAAI,KAAK,WAAW,SAAeU,EAA2C,UAC9E,MAAM,IAAI,MAAM,oDAAoD,KAAK,cAAc,IAAI,EAE3F,KAAK,WAAa,EAElB,MAAM0C,EAAK,KAAK,UAEV7C,EAAcT,EAA2C,mBAAmBC,EAAQC,EAAYoD,CAAE,EAElGC,EAAmBtB,GAAU,CAE/B,KAAK,iBAAiBqB,CAAE,EAAI,CAAClB,EAAOf,IAAO,CAGvCY,EADIG,GAGIf,CAFK,CAGhB,EAED,KAAK,WAAW,KAAKZ,CAAO,CAC/B,EAED,OAAIsB,EAA8B,QAAQ,oBAAoB9B,CAAM,SAAS,KAAK,cAAc,GAAG,EAE5F,IAAI,QAAQsD,CAAe,CAC1C,CAWK,MAAM,UAAUtD,KAAWC,EAAY,CAE/B,KAAK,oBAAoBD,CAAM,IAAG,KAAK,oBAAoBA,CAAM,EAAI,IAAI,KAE9E,KAAK,oBAAoBA,CAAM,EAAE,IAAI,KAAK,UAAUC,CAAU,CAAC,EAE/D,MAAMsD,EAAc,MAAM,KAAK,QAAQvD,EAAQ,GAAGC,CAAU,EAE5D,GAAIsD,aAAuB,MAAO,MAAMA,EAExC,GAAI,MAAM,QAAQA,CAAW,EAC7B,MAAM,IAAI,MAAM,4DAA4D,EAE5E,MAAMC,EAAe,CACjB,QAAS,MACT,OAAQxD,EACR,OAAQ,CACJ,GAAGC,EACHsD,CAChB,CACS,EAED,KAAK,KAAK,eAAgBC,CAAY,EAEtC,KAAK,0CAA0CA,CAAY,CACnE,CAWK,MAAM,YAAYxD,KAAWC,EAAY,CAEtC,GAAI,KAAK,WAAW,SAAeU,EAA2C,UAAW,MAAM,IAAI,MAAM,gEAAgE,KAAK,cAAc,IAAI,EAEhM,GAAI,CAAC,KAAK,oBAAoBX,CAAM,EACpC,MAAM,IAAI,MAAM,4BAA4BA,CAAM,0CAA0C,EAE5F,MAAMyD,EAAyB,KAAK,UAAUxD,CAAU,EAExD,GAAI,CAAC,KAAK,oBAAoBD,CAAM,EAAE,IAAIyD,CAAsB,EAChE,MAAM,IAAI,MAAM,4BAA4BzD,CAAM,2DAA2D,EAE7G,KAAK,oBAAoBA,CAAM,EAAE,OAAOyD,CAAsB,EAG9D,MAAM,KAAK,QAAQzD,EAAO,QAAQ,aAAc,cAAc,EAAG,GAAGC,CAAU,EAE1E6B,EAA8B,OAAO,sBAAsB,OAAO9B,CAAM,CAAC,cAAcyD,CAAsB,eAAe,CACxI,CASK,MAAM,sBAAuB,CAEtB3B,EAA8B,OAAO,iBAAiB,KAAK,cAAc,IAAI,EAEjF,KAAK,8BAA8B,WAAW,EAE9C,MAAM4B,EAAyB,CAAE,EAEjC,UAAU1D,KAAU,KAAK,oBAAoB,CAEzC,UAAW2D,KAAiB,KAAK,oBAAoB3D,CAAM,EAAE,SAAS,CAElE,MAAMC,EAAa,KAAK,MAAM0D,CAAa,EAE3CD,EAAuB,KAAK,KAAK,UAAU1D,EAAQ,GAAGC,CAAU,CAAC,CACjF,CAEY,MAAM,QAAQ,IAAIyD,CAAsB,CACpD,CAEYA,EAAuB,OAAS,GAAO5B,EAA8B,OAAO,YAAY4B,EAAuB,MAAM,gCAAgC,KAAK,cAAc,GAAG,CACvL,CAQK,SAASlD,EAAS,CAEf,GAAQC,EAA2CD,CAAO,EAAG,CAErDsB,EAA8B,OAAO,8BAA8BtB,EAAQ,MAAM,WAAW,KAAK,cAAc,GAAG,EAEtH,KAAK,KAAK,eAAgBA,CAAO,EAEjC,KAAK,0CAA0CA,CAAO,EAEtD,MACZ,CAEQ,GAAIA,EAAQ,KAAO,KACnB,MAAM,IAAI,MAAM,wDAAwD,EAExE,MAAM8C,EAAkB,KAAK,iBAAiB9C,EAAQ,EAAE,EAExD,GAAI,CAAC8C,EAAiB,CAEdxB,EAA8B,QAAQ,sBAAsBtB,EAAQ,EAAE,4CAA4C,EAEtH,MACZ,CAEQ,OAAO,KAAK,iBAAiBA,EAAQ,EAAE,EAE/BD,EAA0CC,CAAO,EACzD8C,EAAgB,IAAI,MAAM9C,EAAQ,MAAM,OAAO,CAAC,GAI5C8C,EAAgB,OAAW9C,EAAQ,MAAM,EAEzC,KAAK,qCAAqCA,CAAO,EAE7D,CAMK,MAAM,wBAAyB,CAE5B,UAAUoD,KAAc,KAAK,iBAAiB,CAE1C,MAAMN,EAAkB,KAAK,iBAAiBM,CAAU,EAExDN,EAAgB,IAAI,MAAM,iBAAiB,CAAC,EAE5C,OAAO,KAAK,iBAAiBM,CAAU,CACnD,CAEQ,KAAK,8BAA8B,cAAc,CACzD,CAKK,MAAM,qBAAqBC,EAAkB,CAEtCA,EAAiB,QAGrB,KAAK,SAAWA,EAAiB,SACzC,CAKK,MAAM,6BAA8B,CAEjC,KAAK,sBAAwB,KAAK,IAAK,CAC/C,CAMK,MAAM,0CAA0CrD,EAAS,CAElDA,EAAQ,SAAW,iCACvB,KAAK,YAAcA,EAAQ,OAAO,CAAC,EAAE,OAC7C,CAMK,MAAM,qCAAqCA,EAAS,CACjD,GAAI,CAEI,OAAOA,EAAQ,OAAO,aAAiB,MAC3C,KAAK,YAAcA,EAAQ,OAAO,aACrC,MAAe,CAExB,CACA,CAGK,MAAM,8BAA8BsD,EAAW,CAE5C,KAAK,KAAKA,CAAS,CAC3B,CACA,CACG,IACHC,EAA2Cf","x_google_ignoreList":[0]}