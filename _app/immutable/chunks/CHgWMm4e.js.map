{"version":3,"file":"CHgWMm4e.js","sources":["../../../../../../../../node_modules/.pnpm/@bitauth+libauth@3.1.0-next.8/node_modules/@bitauth/libauth/build/lib/compiler/standard/p2pkh.js","../../../../../../../../node_modules/.pnpm/@bitauth+libauth@3.1.0-next.8/node_modules/@bitauth/libauth/build/lib/compiler/p2pkh-utils.js"],"sourcesContent":["/**\n * A standard single-factor wallet template that uses\n * Pay-to-Public-Key-Hash (P2PKH), the most common authentication scheme in use\n * on the network.\n *\n * This P2PKH template uses BCH Schnorr signatures, reducing the size of\n * transactions.\n *\n * Note, this wallet template uses only a single `Key`. For HD key\n * support, see {@link walletTemplateP2pkhHd}.\n */\nexport const walletTemplateP2pkhNonHd = {\n    $schema: 'https://libauth.org/schemas/wallet-template-v0.schema.json',\n    description: 'A standard single-factor wallet template that uses Pay-to-Public-Key-Hash (P2PKH), the most common authentication scheme in use on the network.\\n\\nThis P2PKH template uses BCH Schnorr signatures, reducing the size of transactions.',\n    entities: {\n        owner: {\n            description: 'The individual who can spend from this wallet.',\n            name: 'Owner',\n            scripts: ['lock', 'unlock'],\n            variables: {\n                key: {\n                    description: 'The private key that controls this wallet.',\n                    name: 'Key',\n                    type: 'Key',\n                },\n            },\n        },\n    },\n    name: 'Single Signature (P2PKH)',\n    scripts: {\n        lock: {\n            lockingType: 'standard',\n            name: 'P2PKH Lock',\n            script: 'OP_DUP\\nOP_HASH160 <$(<key.public_key> OP_HASH160\\n)> OP_EQUALVERIFY\\nOP_CHECKSIG',\n        },\n        unlock: {\n            name: 'Unlock',\n            script: '<key.schnorr_signature.all_outputs>\\n<key.public_key>',\n            unlocks: 'lock',\n        },\n    },\n    supported: [\n        'BCH_2020_05',\n        'BCH_2021_05',\n        'BCH_2022_05',\n        'BCH_2023_05',\n        'BCH_2024_05',\n        'BCH_2025_05',\n        'BCH_2026_05',\n        'BCH_SPEC',\n    ],\n};\n/**\n * A standard single-factor wallet template that uses\n * Pay-to-Public-Key-Hash (P2PKH), the most common authentication scheme in use\n * on the network.\n *\n * This P2PKH template uses BCH Schnorr signatures, reducing the size of\n * transactions.\n *\n * Because the template uses a Hierarchical Deterministic (HD) key, it also\n * supports watch-only clients.\n */\nexport const walletTemplateP2pkh = {\n    $schema: 'https://libauth.org/schemas/wallet-template-v0.schema.json',\n    description: 'A standard single-factor wallet template that uses Pay-to-Public-Key-Hash (P2PKH), the most common authentication scheme in use on the network.\\n\\nThis P2PKH template uses BCH Schnorr signatures, reducing the size of transactions. Because the template uses a Hierarchical Deterministic (HD) key, it also supports watch-only clients.',\n    entities: {\n        owner: {\n            description: 'The individual who can spend from this wallet.',\n            name: 'Owner',\n            scripts: ['lock', 'unlock'],\n            variables: {\n                key: {\n                    description: 'The private key that controls this wallet.',\n                    name: 'Key',\n                    type: 'HdKey',\n                },\n            },\n        },\n    },\n    name: 'Single Signature (P2PKH)',\n    scripts: {\n        lock: {\n            lockingType: 'standard',\n            name: 'P2PKH Lock',\n            script: 'OP_DUP\\nOP_HASH160 <$(<key.public_key> OP_HASH160\\n)> OP_EQUALVERIFY\\nOP_CHECKSIG',\n        },\n        unlock: {\n            name: 'Unlock',\n            script: '<key.schnorr_signature.all_outputs>\\n<key.public_key>',\n            unlocks: 'lock',\n        },\n    },\n    supported: [\n        'BCH_2020_05',\n        'BCH_2021_05',\n        'BCH_2022_05',\n        'BCH_2023_05',\n        'BCH_2024_05',\n        'BCH_2025_05',\n        'BCH_2026_05',\n        'BCH_SPEC',\n    ],\n};\n//# sourceMappingURL=p2pkh.js.map","import { lockingBytecodeToCashAddress } from '../address/address.js';\nimport { formatError } from '../format/format.js';\nimport { stringifyErrors } from '../language/language.js';\nimport { walletTemplateToCompilerBch } from './compiler-bch/compiler-bch.js';\nimport { walletTemplateP2pkh, walletTemplateP2pkhNonHd, } from './standard/standard.js';\nexport var P2pkhUtilityError;\n(function (P2pkhUtilityError) {\n    P2pkhUtilityError[\"hdPrivateKeyToP2pkhLockingBytecodeCompilation\"] = \"P2PKH utility error: could not derive P2PKH locking bytecode from the provided HD private key.\";\n    P2pkhUtilityError[\"hdPublicKeyToP2pkhLockingBytecodeCompilation\"] = \"P2PKH utility error: could not derive P2PKH locking bytecode from the provided HD public key.\";\n    P2pkhUtilityError[\"privateKeyToP2pkhLockingBytecodeCompilation\"] = \"P2PKH utility error: could not derive P2PKH locking bytecode from the provided private key.\";\n    P2pkhUtilityError[\"publicKeyToP2pkhLockingBytecodeCompilation\"] = \"P2PKH utility error: could not derive P2PKH locking bytecode from the provided public key.\";\n})(P2pkhUtilityError || (P2pkhUtilityError = {}));\n/**\n * Derive the P2PKH locking bytecode of the provided private key.\n *\n * Note that this function defaults to throwing an error if provided with an\n * invalid private key. To handle errors in a type-safe way, set `throwErrors`\n * to `false`.\n *\n * To derive the resulting CashAddress, use\n * {@link privateKeyToP2pkhCashAddress}. For HD private keys, use\n * {@link hdPrivateKeyToP2pkhLockingBytecode}. For the public key equivalent,\n * see {@link publicKeyToP2pkhLockingBytecode}.\n */\nexport const privateKeyToP2pkhLockingBytecode = ({ privateKey, throwErrors = true, }) => {\n    const compiler = walletTemplateToCompilerBch(walletTemplateP2pkhNonHd);\n    const lockingBytecode = compiler.generateBytecode({\n        data: { keys: { privateKeys: { key: privateKey } } },\n        scriptId: 'lock',\n    });\n    if (!lockingBytecode.success) {\n        return formatError(P2pkhUtilityError.privateKeyToP2pkhLockingBytecodeCompilation, stringifyErrors(lockingBytecode.errors), throwErrors);\n    }\n    return lockingBytecode.bytecode;\n};\n/**\n * Derive the P2PKH locking bytecode of the provided public key.\n *\n * Note that this function defaults to throwing an error if provided with an\n * invalid public key. To handle errors in a type-safe way, set `throwErrors`\n * to `false`.\n *\n * To derive the resulting CashAddress, use {@link publicKeyToP2pkhCashAddress}.\n * For HD public keys, use {@link hdPublicKeyToP2pkhLockingBytecode}. For the\n * private key equivalent, see {@link privateKeyToP2pkhLockingBytecode}.\n */\nexport const publicKeyToP2pkhLockingBytecode = ({ publicKey, throwErrors = true, }) => {\n    const compiler = walletTemplateToCompilerBch(walletTemplateP2pkhNonHd);\n    const lockingBytecode = compiler.generateBytecode({\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        data: { bytecode: { 'key.public_key': publicKey } },\n        scriptId: 'lock',\n    });\n    if (!lockingBytecode.success) {\n        return formatError(P2pkhUtilityError.publicKeyToP2pkhLockingBytecodeCompilation, stringifyErrors(lockingBytecode.errors), throwErrors);\n    }\n    return lockingBytecode.bytecode;\n};\n/**\n * Derive the P2PKH locking bytecode at the provided path and address index of\n * the provided HD private key.\n *\n * Note that this function defaults to throwing an error if provided with an\n * invalid HD private key or derivation path. To handle errors in a type-safe\n * way, set `throwErrors` to `false`.\n *\n * To derive the resulting CashAddress, use\n * {@link hdPrivateKeyToP2pkhCashAddress}. For non-HD private keys, use\n * {@link privateKeyToP2pkhLockingBytecode}. For the HD public key equivalent,\n * see {@link hdPublicKeyToP2pkhLockingBytecode}.\n */\nexport const hdPrivateKeyToP2pkhLockingBytecode = ({ addressIndex, hdPrivateKey, privateDerivationPath = 'i', throwErrors = true, }) => {\n    const template = structuredClone(walletTemplateP2pkh);\n    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data, @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n    template.entities.owner.variables.key.privateDerivationPath =\n        privateDerivationPath;\n    const compiler = walletTemplateToCompilerBch(template);\n    const lockingBytecode = compiler.generateBytecode({\n        data: { hdKeys: { addressIndex, hdPrivateKeys: { owner: hdPrivateKey } } },\n        scriptId: 'lock',\n    });\n    if (!lockingBytecode.success) {\n        return formatError(P2pkhUtilityError.hdPrivateKeyToP2pkhLockingBytecodeCompilation, stringifyErrors(lockingBytecode.errors), throwErrors);\n    }\n    return lockingBytecode.bytecode;\n};\n/**\n * Derive the P2PKH locking bytecode at the provided index of the provided HD\n * public key.\n *\n * Note that this function defaults to throwing an error if provided with an\n * invalid HD public key. To handle errors in a type-safe way, set `throwErrors`\n * to `false`.\n *\n * To derive the resulting CashAddress, use\n * {@link hdPublicKeyToP2pkhCashAddress}. For non-HD public keys, use\n * {@link publicKeyToP2pkhLockingBytecode}. For the HD private key equivalent,\n * see {@link hdPrivateKeyToP2pkhLockingBytecode}.\n */\nexport const hdPublicKeyToP2pkhLockingBytecode = ({ addressIndex, hdPublicKey, hdPublicKeyDerivationPath = '', throwErrors = true, publicDerivationPath = 'i', }) => {\n    const template = structuredClone(walletTemplateP2pkh);\n    /* eslint-disable functional/no-expression-statements, functional/immutable-data, @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access */\n    template.entities.owner.variables.key.publicDerivationPath =\n        publicDerivationPath;\n    template.entities.owner.variables.key.hdPublicKeyDerivationPath =\n        hdPublicKeyDerivationPath;\n    template.entities.owner.variables.key.privateDerivationPath =\n        hdPublicKeyDerivationPath === ''\n            ? publicDerivationPath\n            : `${hdPublicKeyDerivationPath}/${publicDerivationPath}`;\n    /* eslint-enable functional/no-expression-statements, functional/immutable-data, @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access */\n    const compiler = walletTemplateToCompilerBch(template);\n    const lockingBytecode = compiler.generateBytecode({\n        data: { hdKeys: { addressIndex, hdPublicKeys: { owner: hdPublicKey } } },\n        scriptId: 'lock',\n    });\n    if (!lockingBytecode.success) {\n        return formatError(P2pkhUtilityError.hdPublicKeyToP2pkhLockingBytecodeCompilation, stringifyErrors(lockingBytecode.errors), throwErrors);\n    }\n    return lockingBytecode.bytecode;\n};\n/**\n * Derive the P2PKH address of the provided private key.\n *\n * Note that this function defaults to throwing an error if provided with an\n * invalid private key. To handle errors in a type-safe way, set `throwErrors`\n * to `false`.\n *\n * To derive only the locking bytecode, use\n * {@link privateKeyToP2pkhLockingBytecode}. For HD private keys, use\n * {@link hdPrivateKeyToP2pkhCashAddress}. For the public key equivalent,\n * see {@link publicKeyToP2pkhCashAddress}.\n */\nexport const privateKeyToP2pkhCashAddress = ({ privateKey, prefix = 'bitcoincash', throwErrors = true, tokenSupport = false, }) => {\n    const bytecode = privateKeyToP2pkhLockingBytecode({\n        privateKey,\n        throwErrors,\n    });\n    if (typeof bytecode === 'string') {\n        return formatError(bytecode, undefined, throwErrors);\n    }\n    return lockingBytecodeToCashAddress({\n        bytecode,\n        prefix,\n        tokenSupport,\n    });\n};\n/**\n * Derive the P2PKH address of the provided public key.\n *\n * Note that this function defaults to throwing an error if provided with an\n * invalid public key. To handle errors in a type-safe way, set `throwErrors`\n * to `false`.\n *\n * To derive only the locking bytecode, use\n * {@link publicKeyToP2pkhLockingBytecode}. For HD public keys, use\n * {@link hdPublicKeyToP2pkhCashAddress}. For the private key equivalent,\n * see {@link privateKeyToP2pkhCashAddress}.\n */\nexport const publicKeyToP2pkhCashAddress = ({ publicKey, prefix = 'bitcoincash', throwErrors = true, tokenSupport = false, }) => {\n    const bytecode = publicKeyToP2pkhLockingBytecode({\n        publicKey,\n        throwErrors,\n    });\n    if (typeof bytecode === 'string') {\n        return formatError(bytecode, undefined, throwErrors);\n    }\n    return lockingBytecodeToCashAddress({\n        bytecode,\n        prefix,\n        tokenSupport,\n    });\n};\n/**\n * Derive the P2PKH address at the provided index of the provided HD\n * private key.\n *\n * Note that this function defaults to throwing an error if provided with an\n * invalid HD private key or derivation path. To handle errors in a type-safe\n * way, set `throwErrors` to `false`.\n *\n * To derive only the locking bytecode, use\n * {@link hdPrivateKeyToP2pkhLockingBytecode}. For non-HD private keys, use\n * {@link privateKeyToP2pkhCashAddress}. For the HD public key equivalent,\n * see {@link hdPublicKeyToP2pkhCashAddress}.\n */\nexport const hdPrivateKeyToP2pkhCashAddress = ({ addressIndex, hdPrivateKey, prefix = 'bitcoincash', privateDerivationPath = 'i', throwErrors = true, tokenSupport = false, }) => {\n    const bytecode = hdPrivateKeyToP2pkhLockingBytecode({\n        addressIndex,\n        hdPrivateKey,\n        privateDerivationPath,\n        throwErrors,\n    });\n    if (typeof bytecode === 'string') {\n        return formatError(bytecode, undefined, throwErrors);\n    }\n    return lockingBytecodeToCashAddress({\n        bytecode,\n        prefix,\n        tokenSupport,\n    });\n};\n/**\n * Derive the P2PKH address at the provided index of the provided HD\n * public key.\n *\n * Note that this function defaults to throwing an error if provided with an\n * invalid HD public key. To handle errors in a type-safe way, set `throwErrors`\n * to `false`.\n *\n * To derive only the locking bytecode, use\n * {@link hdPublicKeyToP2pkhLockingBytecode}. For non-HD public keys, use\n * {@link publicKeyToP2pkhCashAddress}. For the HD private key equivalent,\n * see {@link hdPrivateKeyToP2pkhCashAddress}.\n */\nexport const hdPublicKeyToP2pkhCashAddress = ({ addressIndex, hdPublicKey, hdPublicKeyDerivationPath = '', prefix = 'bitcoincash', publicDerivationPath = 'i', throwErrors = true, tokenSupport = false, }) => {\n    const bytecode = hdPublicKeyToP2pkhLockingBytecode({\n        addressIndex,\n        hdPublicKey,\n        hdPublicKeyDerivationPath,\n        publicDerivationPath,\n        throwErrors,\n    });\n    if (typeof bytecode === 'string') {\n        return formatError(bytecode, undefined, throwErrors);\n    }\n    return lockingBytecodeToCashAddress({\n        bytecode,\n        prefix,\n        tokenSupport,\n    });\n};\n//# sourceMappingURL=p2pkh-utils.js.map"],"names":["walletTemplateP2pkhNonHd","walletTemplateP2pkh","P2pkhUtilityError","publicKeyToP2pkhLockingBytecode","publicKey","throwErrors","lockingBytecode","walletTemplateToCompilerBch","formatError","stringifyErrors","hdPrivateKeyToP2pkhLockingBytecode","addressIndex","hdPrivateKey","privateDerivationPath","template","publicKeyToP2pkhCashAddress","prefix","tokenSupport","bytecode","lockingBytecodeToCashAddress"],"mappings":"uDAWY,MAACA,EAA2B,CACpC,QAAS,6DACT,YAAa;AAAA;AAAA,qFACb,SAAU,CACN,MAAO,CACH,YAAa,iDACb,KAAM,QACN,QAAS,CAAC,OAAQ,QAAQ,EAC1B,UAAW,CACP,IAAK,CACD,YAAa,6CACb,KAAM,MACN,KAAM,KACT,CACJ,CACJ,CACJ,EACD,KAAM,2BACN,QAAS,CACL,KAAM,CACF,YAAa,WACb,KAAM,aACN,OAAQ;AAAA;AAAA;AAAA,YACX,EACD,OAAQ,CACJ,KAAM,SACN,OAAQ;AAAA,kBACR,QAAS,MACZ,CACJ,EACD,UAAW,CACP,cACA,cACA,cACA,cACA,cACA,cACA,cACA,UACH,CACL,EAYaC,EAAsB,CAC/B,QAAS,6DACT,YAAa;AAAA;AAAA,2LACb,SAAU,CACN,MAAO,CACH,YAAa,iDACb,KAAM,QACN,QAAS,CAAC,OAAQ,QAAQ,EAC1B,UAAW,CACP,IAAK,CACD,YAAa,6CACb,KAAM,MACN,KAAM,OACT,CACJ,CACJ,CACJ,EACD,KAAM,2BACN,QAAS,CACL,KAAM,CACF,YAAa,WACb,KAAM,aACN,OAAQ;AAAA;AAAA;AAAA,YACX,EACD,OAAQ,CACJ,KAAM,SACN,OAAQ;AAAA,kBACR,QAAS,MACZ,CACJ,EACD,UAAW,CACP,cACA,cACA,cACA,cACA,cACA,cACA,cACA,UACH,CACL,EClGO,IAAIC,GACV,SAAUA,EAAmB,CAC1BA,EAAkB,8CAAmD,iGACrEA,EAAkB,6CAAkD,gGACpEA,EAAkB,4CAAiD,8FACnEA,EAAkB,2CAAgD,4FACtE,GAAGA,IAAsBA,EAAoB,CAAA,EAAG,EAmCzC,MAAMC,EAAkC,CAAC,CAAE,UAAAC,EAAW,YAAAC,EAAc,EAAI,IAAQ,CAEnF,MAAMC,EADWC,EAA4BP,CAAwB,EACpC,iBAAiB,CAE9C,KAAM,CAAE,SAAU,CAAE,iBAAkBI,CAAS,CAAI,EACnD,SAAU,MAClB,CAAK,EACD,OAAKE,EAAgB,QAGdA,EAAgB,SAFZE,EAAYN,EAAkB,2CAA4CO,EAAgBH,EAAgB,MAAM,EAAGD,CAAW,CAG7I,EAcaK,EAAqC,CAAC,CAAE,aAAAC,EAAc,aAAAC,EAAc,sBAAAC,EAAwB,IAAK,YAAAR,EAAc,MAAY,CACpI,MAAMS,EAAW,gBAAgBb,CAAmB,EAEpDa,EAAS,SAAS,MAAM,UAAU,IAAI,sBAClCD,EAEJ,MAAMP,EADWC,EAA4BO,CAAQ,EACpB,iBAAiB,CAC9C,KAAM,CAAE,OAAQ,CAAE,aAAAH,EAAc,cAAe,CAAE,MAAOC,CAAY,EAAM,EAC1E,SAAU,MAClB,CAAK,EACD,OAAKN,EAAgB,QAGdA,EAAgB,SAFZE,EAAYN,EAAkB,8CAA+CO,EAAgBH,EAAgB,MAAM,EAAGD,CAAW,CAGhJ,EA0EaU,EAA8B,CAAC,CAAE,UAAAX,EAAW,OAAAY,EAAS,cAAe,YAAAX,EAAc,GAAM,aAAAY,EAAe,MAAa,CAC7H,MAAMC,EAAWf,EAAgC,CAC7C,UAAAC,EACA,YAAAC,CACR,CAAK,EACD,OAAI,OAAOa,GAAa,SACbV,EAAYU,EAAU,OAAWb,CAAW,EAEhDc,EAA6B,CAChC,SAAAD,EACA,OAAAF,EACA,aAAAC,CACR,CAAK,CACL","x_google_ignoreList":[0,1]}