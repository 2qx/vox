{"version":3,"file":"DXTZjuH7.js","sources":["../../../../../../../../node_modules/.pnpm/svelte@5.33.18/node_modules/svelte/src/internal/client/dom/blocks/await.js","../../../../../../../future/out/auth.js","../../../../../../../future/out/coupon.js","../../../../../../../future/out/vault.js","../../../../../../../future/out/util.js","../../../../../../../future/out/channel.js"],"sourcesContent":["/** @import { Effect, Source, TemplateNode } from '#client' */\nimport { DEV } from 'esm-env';\nimport { is_promise } from '../../../shared/utils.js';\nimport { block, branch, pause_effect, resume_effect } from '../../reactivity/effects.js';\nimport { internal_set, mutable_source, source } from '../../reactivity/sources.js';\nimport { flushSync, set_active_effect, set_active_reaction } from '../../runtime.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport { queue_micro_task } from '../task.js';\nimport { HYDRATION_START_ELSE, UNINITIALIZED } from '../../../../constants.js';\nimport {\n\tcomponent_context,\n\tis_runes,\n\tset_component_context,\n\tset_dev_current_component_function\n} from '../../context.js';\n\nconst PENDING = 0;\nconst THEN = 1;\nconst CATCH = 2;\n\n/**\n * @template V\n * @param {TemplateNode} node\n * @param {(() => Promise<V>)} get_input\n * @param {null | ((anchor: Node) => void)} pending_fn\n * @param {null | ((anchor: Node, value: Source<V>) => void)} then_fn\n * @param {null | ((anchor: Node, error: unknown) => void)} catch_fn\n * @returns {void}\n */\nexport function await_block(node, get_input, pending_fn, then_fn, catch_fn) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\tvar runes = is_runes();\n\tvar active_component_context = component_context;\n\n\t/** @type {any} */\n\tvar component_function = DEV ? component_context?.function : null;\n\n\t/** @type {V | Promise<V> | typeof UNINITIALIZED} */\n\tvar input = UNINITIALIZED;\n\n\t/** @type {Effect | null} */\n\tvar pending_effect;\n\n\t/** @type {Effect | null} */\n\tvar then_effect;\n\n\t/** @type {Effect | null} */\n\tvar catch_effect;\n\n\tvar input_source = (runes ? source : mutable_source)(/** @type {V} */ (undefined));\n\tvar error_source = (runes ? source : mutable_source)(undefined);\n\tvar resolved = false;\n\n\t/**\n\t * @param {PENDING | THEN | CATCH} state\n\t * @param {boolean} restore\n\t */\n\tfunction update(state, restore) {\n\t\tresolved = true;\n\n\t\tif (restore) {\n\t\t\tset_active_effect(effect);\n\t\t\tset_active_reaction(effect); // TODO do we need both?\n\t\t\tset_component_context(active_component_context);\n\t\t\tif (DEV) set_dev_current_component_function(component_function);\n\t\t}\n\n\t\ttry {\n\t\t\tif (state === PENDING && pending_fn) {\n\t\t\t\tif (pending_effect) resume_effect(pending_effect);\n\t\t\t\telse pending_effect = branch(() => pending_fn(anchor));\n\t\t\t}\n\n\t\t\tif (state === THEN && then_fn) {\n\t\t\t\tif (then_effect) resume_effect(then_effect);\n\t\t\t\telse then_effect = branch(() => then_fn(anchor, input_source));\n\t\t\t}\n\n\t\t\tif (state === CATCH && catch_fn) {\n\t\t\t\tif (catch_effect) resume_effect(catch_effect);\n\t\t\t\telse catch_effect = branch(() => catch_fn(anchor, error_source));\n\t\t\t}\n\n\t\t\tif (state !== PENDING && pending_effect) {\n\t\t\t\tpause_effect(pending_effect, () => (pending_effect = null));\n\t\t\t}\n\n\t\t\tif (state !== THEN && then_effect) {\n\t\t\t\tpause_effect(then_effect, () => (then_effect = null));\n\t\t\t}\n\n\t\t\tif (state !== CATCH && catch_effect) {\n\t\t\t\tpause_effect(catch_effect, () => (catch_effect = null));\n\t\t\t}\n\t\t} finally {\n\t\t\tif (restore) {\n\t\t\t\tif (DEV) set_dev_current_component_function(null);\n\t\t\t\tset_component_context(null);\n\t\t\t\tset_active_reaction(null);\n\t\t\t\tset_active_effect(null);\n\n\t\t\t\t// without this, the DOM does not update until two ticks after the promise\n\t\t\t\t// resolves, which is unexpected behaviour (and somewhat irksome to test)\n\t\t\t\tflushSync();\n\t\t\t}\n\t\t}\n\t}\n\n\tvar effect = block(() => {\n\t\tif (input === (input = get_input())) return;\n\n\t\t/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\t// @ts-ignore coercing `anchor` to a `Comment` causes TypeScript and Prettier to fight\n\t\tlet mismatch = hydrating && is_promise(input) === (anchor.data === HYDRATION_START_ELSE);\n\n\t\tif (mismatch) {\n\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh\n\t\t\tanchor = remove_nodes();\n\n\t\t\tset_hydrate_node(anchor);\n\t\t\tset_hydrating(false);\n\t\t\tmismatch = true;\n\t\t}\n\n\t\tif (is_promise(input)) {\n\t\t\tvar promise = input;\n\n\t\t\tresolved = false;\n\n\t\t\tpromise.then(\n\t\t\t\t(value) => {\n\t\t\t\t\tif (promise !== input) return;\n\t\t\t\t\t// we technically could use `set` here since it's on the next microtick\n\t\t\t\t\t// but let's use internal_set for consistency and just to be safe\n\t\t\t\t\tinternal_set(input_source, value);\n\t\t\t\t\tupdate(THEN, true);\n\t\t\t\t},\n\t\t\t\t(error) => {\n\t\t\t\t\tif (promise !== input) return;\n\t\t\t\t\t// we technically could use `set` here since it's on the next microtick\n\t\t\t\t\t// but let's use internal_set for consistency and just to be safe\n\t\t\t\t\tinternal_set(error_source, error);\n\t\t\t\t\tupdate(CATCH, true);\n\t\t\t\t\tif (!catch_fn) {\n\t\t\t\t\t\t// Rethrow the error if no catch block exists\n\t\t\t\t\t\tthrow error_source.v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (hydrating) {\n\t\t\t\tif (pending_fn) {\n\t\t\t\t\tpending_effect = branch(() => pending_fn(anchor));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Wait a microtask before checking if we should show the pending state as\n\t\t\t\t// the promise might have resolved by the next microtask.\n\t\t\t\tqueue_micro_task(() => {\n\t\t\t\t\tif (!resolved) update(PENDING, true);\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tinternal_set(input_source, input);\n\t\t\tupdate(THEN, false);\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\n\t\t// Set the input to something else, in order to disable the promise callbacks\n\t\treturn () => (input = UNINITIALIZED);\n\t});\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n","import template_json from './template.v2.json' with { type: \"json\" };\nimport { getLibauthCompiler } from '@unspent/tau';\nexport default class Future {\n    static compiler = getLibauthCompiler(template_json);\n}\n//# sourceMappingURL=auth.js.map","import { bigIntToVmNumber, CashAddressNetworkPrefix, lockingBytecodeToCashAddress, } from \"@bitauth/libauth\";\nimport Future from './auth.js';\nexport class Coupon {\n    static compiler = Future.compiler;\n    amount = 1000000;\n    lock = new Uint8Array(0);\n    static unlockingScript = \"00cc00c694a16900c788c08bc39c\";\n    /**\n     * Return the address for a Coupon\n     *\n     *\n     * @param amount - the threshold amount (sats) to redeem coupon\n     * @param lock - the vault locking bytecode\n     * @param network - the network prefix\n     */\n    static getAddress(amount, lock, network = CashAddressNetworkPrefix.mainnet) {\n        let lockingBytecode = this.getLockingBytecode(amount, lock);\n        let result = lockingBytecodeToCashAddress({ bytecode: lockingBytecode, prefix: network, tokenSupport: false });\n        if (typeof result === 'string')\n            throw (result);\n        return result.address;\n    }\n    /**\n     * Return the unlockingBytecode for a Coupon\n     *\n     *\n     * @param amount - the threshold amount (sats) to redeem coupon\n     * @param lock - the vault locking bytecode\n     */\n    static getUnlockingBytecode(amount, lock) {\n        const bytecodeResult = this.compiler.generateBytecode({\n            data: {\n                \"bytecode\": {\n                    \"amount\": bigIntToVmNumber(BigInt(amount)),\n                    \"lock\": lock,\n                }\n            },\n            scriptId: 'coupon_unlock',\n        });\n        if (!bytecodeResult.success) {\n            /* c8 ignore next */\n            throw new Error('Failed to generate bytecode, script: FutureChan, ' + JSON.stringify(bytecodeResult, null, '  '));\n        }\n        return bytecodeResult.bytecode.slice(1);\n    }\n    /**\n     * Return the lockingBytecode for a Coupon\n     *\n     *\n     * @param amount - the threshold amount (sats) to redeem coupon\n     * @param lock - the Vault locking bytecode\n     */\n    static getLockingBytecode(amount, lock) {\n        const bytecodeResult = this.compiler.generateBytecode({\n            data: {\n                \"bytecode\": {\n                    \"amount\": bigIntToVmNumber(BigInt(amount)),\n                    \"lock\": lock,\n                }\n            },\n            scriptId: 'coupon_lock',\n        });\n        if (!bytecodeResult.success) {\n            /* c8 ignore next */\n            throw new Error('Failed to generate bytecode, script: FutureChan, ' + JSON.stringify(bytecodeResult, null, '  '));\n        }\n        return bytecodeResult.bytecode;\n    }\n}\n//# sourceMappingURL=coupon.js.map","import { bigIntToVmNumber, CashAddressNetworkPrefix, lockingBytecodeToCashAddress } from \"@bitauth/libauth\";\nimport { Coupon } from './coupon.js';\nimport Future from './auth.js';\nexport class Vault {\n    static compiler = Future.compiler;\n    locktime = 0;\n    //static unlockingScript = \"c0d3c0d0a06376b17568c0cec0d188c0cdc0c788c0d0c0c693c0d3c0cc939c77\"\n    /**\n     * Return the token address for a Vault\n     *\n     *\n     * @param time - block time of the vault lock\n     * @param network - cashaddress network prefix\n     */\n    static getAddress(time, network = CashAddressNetworkPrefix.mainnet, tokenSupport = true) {\n        let lockingBytecode = this.getLockingBytecode(time);\n        let result = lockingBytecodeToCashAddress({ bytecode: lockingBytecode, prefix: network, tokenSupport: tokenSupport });\n        if (typeof result === 'string')\n            throw (result);\n        return result.address;\n    }\n    /**\n     * Return the coupon for a Vault at specified amount\n     *\n     *\n     * @param amount - the threshold amount (sats) to redeem coupon\n     * @param time - block time of the vault lock\n     */\n    static getCoupon(amount, time, network = CashAddressNetworkPrefix.mainnet) {\n        return Coupon.getAddress(amount, this.getLockingBytecode(time), network);\n    }\n    /**\n     * Return the coupon for a Vault at specified amount\n     *\n     *\n     * @param amount - the threshold amount (sats) to redeem coupon\n     * @param time - block time of the vault lock\n     */\n    static getCouponLockingBytecode(amount, time) {\n        return Coupon.getLockingBytecode(amount, this.getLockingBytecode(time));\n    }\n    /**\n     * Return the unlockingBytecode for a Vault\n     *\n     *\n     * @param time - block time of the vault lock\n     */\n    static getUnlockingBytecode(time) {\n        const bytecodeResult = this.compiler.generateBytecode({\n            data: {\n                \"bytecode\": {\n                    \"locktime\": bigIntToVmNumber(BigInt(time)),\n                }\n            },\n            scriptId: 'vault_unlock',\n        });\n        if (!bytecodeResult.success) {\n            /* c8 ignore next */\n            throw new Error('Failed to generate bytecode, script: FutureChan, ' + JSON.stringify(bytecodeResult, null, '  '));\n        }\n        return bytecodeResult.bytecode.slice(1);\n    }\n    /**\n     * Return the lockingBytecode for a Vault\n     *\n     *\n     * @param time - block time of the vault lock\n     */\n    static getLockingBytecode(time) {\n        const bytecodeResult = this.compiler.generateBytecode({\n            data: {\n                \"bytecode\": {\n                    \"locktime\": bigIntToVmNumber(BigInt(time)),\n                }\n            },\n            scriptId: 'vault_lock',\n        });\n        if (!bytecodeResult.success) {\n            /* c8 ignore next */\n            throw new Error('Failed to generate bytecode, script: , ' + JSON.stringify(bytecodeResult, null, '  '));\n        }\n        return bytecodeResult.bytecode;\n    }\n}\n//# sourceMappingURL=vault.js.map","import { hexToBin, utf8ToBin } from \"@bitauth/libauth\";\nexport function toBin(input) {\n    if (!input)\n        return new Uint8Array(0);\n    const data = input.replace(/^0x/, \"\");\n    const encode = data === input ? utf8ToBin : hexToBin;\n    return encode(data);\n}\n//# sourceMappingURL=util.js.map","import template from './template.v2.json' with { type: \"json\" };\nimport packageInfo from '../package.json' with { type: \"json\" };\nimport { bigIntToVmNumber, binToHex, binToUtf8, createVirtualMachineBCH, deriveHdPublicKey, disassembleBytecodeBCH, generateTransaction, hdPrivateKeyToP2pkhLockingBytecode, hexToBin, swapEndianness, verifyTransactionTokens, hash256, decodeTransactionBCH, utf8ToBin, encodeDataPush } from \"@bitauth/libauth\";\nimport { getTransactionFees, getAddress, getLibauthCompiler, getScriptHash, sumSourceOutputValue, sumOutputValue } from '@unspent/tau';\nimport { Vault } from './vault.js';\nimport { toBin } from './util.js';\nconst BIP68_MASK = 2147483648;\nexport class Post {\n    hash;\n    auth;\n    height;\n    sequence;\n    body;\n    likes;\n    dislikes;\n    ref;\n    error;\n    constructor({ hash = \"\", auth = \"\", height = -1, sequence = -1, body = \"\", likes = 0, dislikes = 0, ref = \"\", error = \"\" }) {\n        this.hash = hash;\n        this.auth = auth;\n        this.height = height;\n        this.sequence = sequence > BIP68_MASK ? sequence - BIP68_MASK : sequence;\n        this.body = body;\n        this.likes = likes;\n        this.dislikes = dislikes;\n        this.ref = ref;\n        this.error = error;\n    }\n}\nexport function parseUsername(commitment) {\n    const commitmentBin = hexToBin(commitment);\n    const commitmentAsm = disassembleBytecodeBCH(commitmentBin);\n    const unameHex = commitmentAsm.split(\" \").pop().substring(2);\n    return binToUtf8(hexToBin(unameHex));\n}\nfunction parsePostTransaction(channelLock, height, hash, transaction) {\n    if (!transaction)\n        return;\n    let tx = decodeTransactionBCH(hexToBin(transaction));\n    if (typeof tx == \"string\")\n        return new Post({ height: height, hash: hash, error: tx });\n    if (!tx.outputs[0].token)\n        return;\n    if (!tx.outputs[0].token.nft)\n        return new Post({ height: height, hash: hash, error: \"no nft on first output\" });\n    if (!tx.outputs[0].token.nft.commitment)\n        return new Post({ height: height, hash: hash, error: \"no nft commitment first output\" });\n    let body = \"\";\n    let ref = \"\";\n    let like = 0;\n    let dislike = 0;\n    const code = tx.outputs\n        .filter(o => binToHex(o.lockingBytecode) == channelLock)\n        .filter(o => o.token)\n        .filter(o => o.token?.nft)\n        .map(o => {\n        return binToHex(o.token?.nft?.commitment);\n    });\n    if (!code)\n        return;\n    if (!code[0])\n        return;\n    // V0\n    if (code[0].slice(0, 8) == \"6a025630\")\n        body = code.map(c => binToUtf8(hexToBin(c.slice(10)))).join(\"\");\n    // V+\n    if (code[0].slice(0, 8) == \"6a0256b2\") {\n        ref = code[0].slice(10);\n        like = 1;\n    }\n    // V-\n    if (code[0].slice(0, 8) == \"6a02562d\") {\n        ref = code[0].slice(10);\n        dislike = 1;\n    }\n    return new Post({\n        hash: hash,\n        auth: binToHex(tx.outputs[0]?.token?.category),\n        body: body,\n        height: height,\n        sequence: tx.inputs[0]?.sequenceNumber,\n        ref: ref,\n        likes: like,\n        dislikes: dislike,\n    });\n}\nfunction chunks(arr, len) {\n    var chunks = [], i = 0, n = arr.length;\n    while (i < n) {\n        chunks.push(arr.slice(i, i += len));\n    }\n    return chunks;\n}\nconst blockSort = (a, b) => {\n    if (b <= 0 && a > 0) {\n        return -1;\n    }\n    else if (b > 0 && a > 0) {\n        return Math.sign(a - b);\n    }\n    else {\n        return Math.sign(b - a);\n    }\n};\n/**\n * Build a list of top level posts given a list of transactions\n *\n * @param prefix - cashaddress prefix.\n * @throws {Error} if transaction generation fails.\n * @returns a cashaddress.\n */\nexport function buildChannel(history, transactions, channel) {\n    const channelLock = binToHex(Channel.getLockingBytecode(channel));\n    // build a map of transactions by hash\n    const transactionMap = new Map(transactions.map(tx => [swapEndianness(binToHex(hash256(hexToBin(tx)))), tx]));\n    // Assuming a sorted list of transactions by block height\n    let posts = history\n        .map(h => {\n        return parsePostTransaction(channelLock, h.height, h.tx_hash, transactionMap.get(h.tx_hash));\n    })\n        .filter(p => p != undefined);\n    let likeOccurances = posts.filter(p => p.likes == 1).map(p => { return p.ref; });\n    let likes = likeOccurances.reduce((acc, e) => acc.set(e, (acc.get(e) || 0) + 1), new Map());\n    for (const post of posts) {\n        post.likes = likes.get(post.hash) ? likes.get(post.hash) : 0;\n    }\n    posts = posts.sort((a, b) => {\n        if (b.height === a.height) {\n            return Math.sign(a.sequence - b.sequence);\n        }\n        else if (b.height <= 0 && a.height <= 0) {\n            return Math.sign(a.sequence - b.sequence);\n        }\n        else\n            return blockSort(a.height, b.height);\n    });\n    return posts.filter(p => p.body != \"\");\n}\nexport class Channel {\n    static USER_AGENT = packageInfo.name;\n    static tokenAware = true;\n    static template = template;\n    static compiler = getLibauthCompiler(this.template);\n    static vm = createVirtualMachineBCH();\n    static getLockingBytecode(channel) {\n        const lockingBytecodeResult = this.compiler.generateBytecode({\n            data: {\n                \"bytecode\": {\n                    \"channel\": toBin(channel)\n                }\n            },\n            scriptId: 'channel_lock',\n        });\n        if (!lockingBytecodeResult.success) {\n            /* c8 ignore next */\n            throw new Error('Failed to generate bytecode, script: , ' + JSON.stringify(lockingBytecodeResult, null, '  '));\n        }\n        return lockingBytecodeResult.bytecode;\n    }\n    static getScriptHash(channel, reversed = true) {\n        return getScriptHash(this.getLockingBytecode(channel), reversed);\n    }\n    /**\n     * Get cashaddress\n     *\n     * @param prefix - cashaddress prefix.\n     * @throws {Error} if transaction generation fails.\n     * @returns a cashaddress.\n     */\n    static getAddress(channel = \"\", prefix = \"bitcoincash\") {\n        return getAddress(this.getLockingBytecode(channel), prefix, this.tokenAware);\n    }\n    static getInputs(channel, utxos, now, edit = false) {\n        return utxos.map(u => this.getInput(channel, u, now, edit));\n    }\n    static getInput(channel, utxo, now, edit = false) {\n        let scriptId = edit ? 'edit_message' : 'process_message';\n        const sequence = (now - utxo.height) >= 1000 ? 1000 : 0;\n        return {\n            outpointIndex: utxo.tx_pos,\n            outpointTransactionHash: hexToBin(utxo.tx_hash),\n            // \n            sequenceNumber: sequence,\n            unlockingBytecode: {\n                compiler: this.compiler,\n                script: scriptId,\n                data: {\n                    \"bytecode\": {\n                        \"channel\": toBin(channel),\n                        \"locktime\": bigIntToVmNumber(BigInt((Number(utxo.value) / 10) * 1000))\n                    }\n                },\n                valueSatoshis: BigInt(utxo.value),\n                token: utxo.token_data ? {\n                    category: hexToBin(utxo.token_data.category),\n                    amount: BigInt(utxo.token_data.amount),\n                    nft: utxo.token_data.nft ? {\n                        commitment: hexToBin(utxo.token_data.nft.commitment),\n                        capability: utxo.token_data.nft.capability,\n                    } : undefined\n                } : undefined\n            },\n        };\n    }\n    static getSourceOutputs(channel, utxos) {\n        return utxos.map(u => this.getSourceOutput(channel, u));\n    }\n    static getSourceOutput(channel, utxo) {\n        return {\n            outpointIndex: utxo.tx_pos,\n            outpointTransactionHash: hexToBin(utxo.tx_hash),\n            // \n            sequenceNumber: 1,\n            unlockingBytecode: Uint8Array.from([]),\n            lockingBytecode: this.getLockingBytecode(channel),\n            valueSatoshis: BigInt(utxo.value),\n        };\n    }\n    static getWalletSourceOutput(utxo, key) {\n        const lockingBytecode = key ? hdPrivateKeyToP2pkhLockingBytecode({\n            addressIndex: 0,\n            hdPrivateKey: key\n        }) : Uint8Array.from(Array(33));\n        return {\n            lockingBytecode: lockingBytecode,\n            valueSatoshis: BigInt(utxo.value),\n            token: utxo.token_data ? {\n                category: hexToBin(utxo.token_data.category),\n                amount: BigInt(utxo.token_data.amount),\n                nft: utxo.token_data.nft ? {\n                    commitment: hexToBin(utxo.token_data.nft.commitment),\n                    capability: utxo.token_data.nft.capability,\n                } : undefined\n            } : undefined\n        };\n    }\n    static getCouponOutputs(utxos, now) {\n        return utxos.map(u => this.getCouponOutput(u, now)).filter(u => u !== undefined);\n    }\n    static getCouponOutput(utxo, now) {\n        let futureTime = Math.floor(utxo.value / 10) * 1000;\n        // if the utxo was underfunded, clear it without generating a coupon.\n        let isSpam = ((futureTime - utxo.height) < 1000);\n        let isPremature = (now - utxo.height) < 1000;\n        let outputValue = isPremature ? utxo.value * 10 : utxo.value;\n        // A non matching output value indicates the message is spam\n        outputValue = isSpam ? utxo.value - 1 : outputValue;\n        let couponThreshold = isPremature ? 100_000_000 : 10_000_000;\n        couponThreshold = isSpam ? 10_000_000 : couponThreshold;\n        let bytecode = Vault.getCouponLockingBytecode(couponThreshold, futureTime);\n        return {\n            lockingBytecode: bytecode,\n            valueSatoshis: BigInt(outputValue),\n        };\n    }\n    static getWalletInputs(utxos, key, sequence) {\n        return utxos.map((u) => this.getWalletInput(u, key, sequence));\n    }\n    static getWalletInput(utxo, privateKey, sequence, addressIndex = 0) {\n        let unlockingData = privateKey ? {\n            compiler: this.compiler,\n            data: {\n                hdKeys: {\n                    addressIndex: addressIndex,\n                    hdPrivateKeys: {\n                        'wallet': privateKey\n                    },\n                }\n            },\n            script: 'wallet_unlock',\n            valueSatoshis: BigInt(utxo.value),\n        } : Uint8Array.from(Array());\n        //@ts-ignore\n        unlockingData.token = utxo.token_data ? {\n            category: hexToBin(utxo.token_data.category),\n            amount: utxo.token_data.amount,\n            nft: utxo.token_data.nft ? {\n                commitment: hexToBin(utxo.token_data.nft.commitment),\n                capability: utxo.token_data.nft.capability,\n            } : undefined\n        } : undefined;\n        return {\n            outpointIndex: utxo.tx_pos,\n            outpointTransactionHash: hexToBin(utxo.tx_hash),\n            sequenceNumber: sequence ? sequence + BIP68_MASK : sequence,\n            unlockingBytecode: unlockingData,\n        };\n    }\n    static getChannelMessageOutputs(channel, message, auth, couponValue) {\n        const binaryMessage = utf8ToBin(message);\n        let chunked = [...chunks(binaryMessage, 32).map((m) => \"6a025630\" + binToHex(encodeDataPush(m)))];\n        return chunked.map((m) => {\n            return {\n                lockingBytecode: this.getLockingBytecode(channel),\n                valueSatoshis: BigInt(couponValue),\n                token: {\n                    amount: 0n,\n                    category: hexToBin(auth.token_data.category),\n                    nft: {\n                        capability: 'mutable',\n                        commitment: hexToBin(m)\n                    }\n                }\n            };\n        });\n    }\n    static getLikeOutput(channel, postId, auth, couponValue) {\n        let m = \"6a0256B2\" + binToHex(encodeDataPush(hexToBin(postId)));\n        return {\n            lockingBytecode: this.getLockingBytecode(channel),\n            valueSatoshis: BigInt(couponValue),\n            token: {\n                amount: 0n,\n                category: hexToBin(auth.token_data.category),\n                nft: {\n                    capability: 'none',\n                    commitment: hexToBin(m)\n                }\n            }\n        };\n    }\n    static getChangeOutput(auth, changeAmount, privateKey, addressIndex = 0) {\n        const lockingBytecode = privateKey ? {\n            compiler: this.compiler,\n            data: {\n                hdKeys: {\n                    addressIndex: addressIndex,\n                    hdPublicKeys: {\n                        'wallet': deriveHdPublicKey(privateKey).hdPublicKey\n                    },\n                },\n            },\n            script: 'wallet_lock'\n        } : Uint8Array.from(Array(33));\n        return {\n            lockingBytecode: lockingBytecode,\n            valueSatoshis: changeAmount,\n            token: {\n                amount: 0n,\n                category: hexToBin(auth.token_data.category),\n                nft: {\n                    capability: \"minting\",\n                    commitment: hexToBin(auth.token_data?.nft?.commitment)\n                }\n            }\n        };\n    }\n    /**\n     * Clear a channel message.\n     *\n     * Messages may be cleared based on different conditions:\n     *\n     * 1. Messages that are older than 1000 blocks can be turned into 10M coupons\n     * 1. Messages that are not older than 1000 blocks can be into 100M coupons\n     * 1. Messages that were insufficiently funded may be taken at will without generating a coupon.\n     *\n     * @param channel - channel identifier.\n     * @param utxos - utxos held by the channel to drop.\n     * @param auth - utxo paying transaction fees.\n     * @param key - private key to sign transaction wallet inputs.\n     * @param now - current timestamp, in blocks.\n     * @param extraUtxos - wallet utxos for extra fees.\n     * @param fee - network fee to pay, default 1 sat per byte.\n     *\n     * @throws {Error} if transaction generation fails.\n     * @returns a transaction template.\n     */\n    static clear(channel, utxos, auth, key, now, extraUtxos, fee = 1) {\n        const inputs = [];\n        const outputs = [];\n        const sourceOutputs = [];\n        let config = {\n            locktime: now,\n            version: 2,\n            inputs,\n            outputs\n        };\n        let walletUtxos = [auth];\n        if (extraUtxos)\n            walletUtxos.push(...extraUtxos);\n        config.inputs.push(...this.getInputs(channel, utxos, now));\n        config.inputs.push(...this.getWalletInputs(walletUtxos, key));\n        config.outputs.push(...this.getCouponOutputs(utxos, now));\n        sourceOutputs.push(...this.getSourceOutputs(channel, utxos));\n        sourceOutputs.push(this.getWalletSourceOutput(auth, key));\n        let valueIn = sumSourceOutputValue(sourceOutputs);\n        let valueOut = sumOutputValue(config.outputs);\n        let change = valueIn - valueOut;\n        config.outputs.push(this.getChangeOutput(auth, change, key));\n        return this.buildAndValidateTransaction(config, sourceOutputs, fee);\n    }\n    /**\n     * Create (or edit) a post.\n     *\n     * @param channel - channel identifier.\n     * @param message - full post message.\n     * @param auth - utxo paying transaction fees.\n     * @param couponAmount - amount to pay message (per commitment).\n     * @param key - private key to sign transaction wallet inputs.\n     * @param prevUtxos - post utxos to edit.\n     * @param fee - network fee to pay, default 1 sat per byte.\n     *\n     * @throws {Error} if transaction generation fails.\n     * @returns a transaction template.\n     */\n    static post(channel, message, auth, couponAmount, key, sequence, prevUtxos, fee = 1) {\n        const inputs = [];\n        const outputs = [];\n        const sourceOutputs = [];\n        let config = {\n            locktime: 0,\n            version: 2,\n            inputs,\n            outputs\n        };\n        let walletUtxos = [auth];\n        if (prevUtxos)\n            walletUtxos.push(...prevUtxos);\n        config.inputs.push(...this.getWalletInputs(walletUtxos, key, sequence));\n        config.outputs.push(...this.getChannelMessageOutputs(channel, message, auth, couponAmount));\n        sourceOutputs.push(this.getWalletSourceOutput(auth, key));\n        let valueIn = sumSourceOutputValue(sourceOutputs);\n        let change = valueIn - BigInt(config.outputs.length * couponAmount);\n        config.outputs.push(this.getChangeOutput(auth, change, key));\n        return this.buildAndValidateTransaction(config, sourceOutputs, fee);\n    }\n    /**\n    * Like a post.\n    *\n    * @param channel - channel identifier.\n    * @param postId - transaction id of the post being liked.\n    * @param auth - utxo paying transaction fees.\n    * @param couponAmount - amount to pay message (per commitment).\n    * @param key - private key to sign transaction wallet inputs.\n    * @param fee - network fee to pay, default 1 sat per byte.\n    *\n    * @throws {Error} if transaction generation fails.\n    * @returns a transaction template.\n    */\n    static like(channel, postId, auth, couponAmount, key, fee = 1) {\n        const inputs = [];\n        const outputs = [];\n        const sourceOutputs = [];\n        let config = {\n            locktime: 0,\n            version: 2,\n            inputs,\n            outputs\n        };\n        let walletUtxos = [auth];\n        config.inputs.push(...this.getWalletInputs(walletUtxos, key));\n        config.outputs.push(this.getLikeOutput(channel, postId, auth, couponAmount));\n        sourceOutputs.push(this.getWalletSourceOutput(auth, key));\n        let valueIn = sumSourceOutputValue(sourceOutputs);\n        let change = valueIn - BigInt(config.outputs.length * couponAmount);\n        config.outputs.push(this.getChangeOutput(auth, change, key));\n        return this.buildAndValidateTransaction(config, sourceOutputs, fee);\n    }\n    static buildAndValidateTransaction(config, sourceOutputs, fee = 1) {\n        let result = generateTransaction(config);\n        if (!result.success)\n            throw new Error('generate transaction failed!, errors: ' + JSON.stringify(result.errors, null, '  '));\n        const estimatedFee = getTransactionFees(result.transaction, fee);\n        const lastIdx = config.outputs.length - 1;\n        config.outputs[lastIdx].valueSatoshis = config.outputs[lastIdx].valueSatoshis - estimatedFee;\n        result = generateTransaction(config);\n        if (!result.success)\n            throw new Error('generate transaction failed!, errors: ' + JSON.stringify(result.errors, null, '  '));\n        const transaction = result.transaction;\n        const tokenValidationResult = verifyTransactionTokens(transaction, sourceOutputs);\n        if (tokenValidationResult !== true && fee > 0)\n            throw tokenValidationResult;\n        let verify = this.vm.verify({\n            sourceOutputs: sourceOutputs,\n            transaction: transaction,\n        });\n        return {\n            sourceOutputs: sourceOutputs,\n            transaction: transaction,\n            verify: verify\n        };\n    }\n}\n//# sourceMappingURL=channel.js.map"],"names":["PENDING","THEN","CATCH","await_block","node","get_input","pending_fn","then_fn","catch_fn","hydrating","hydrate_next","anchor","runes","is_runes","active_component_context","component_context","input","UNINITIALIZED","pending_effect","then_effect","catch_effect","input_source","source","mutable_source","error_source","resolved","update","state","restore","set_active_effect","effect","set_active_reaction","set_component_context","resume_effect","branch","pause_effect","flushSync","block","mismatch","is_promise","HYDRATION_START_ELSE","remove_nodes","set_hydrate_node","set_hydrating","promise","value","internal_set","error","queue_micro_task","hydrate_node","Future","getLibauthCompiler","template_json","Coupon","amount","lock","network","CashAddressNetworkPrefix","lockingBytecode","result","lockingBytecodeToCashAddress","bytecodeResult","bigIntToVmNumber","Vault","time","tokenSupport","toBin","data","utf8ToBin","hexToBin","BIP68_MASK","Post","hash","auth","height","sequence","body","likes","dislikes","ref","parseUsername","commitment","commitmentBin","unameHex","disassembleBytecodeBCH","binToUtf8","parsePostTransaction","channelLock","transaction","tx","decodeTransactionBCH","like","dislike","code","o","binToHex","c","chunks","arr","len","i","n","blockSort","a","b","buildChannel","history","transactions","channel","Channel","transactionMap","swapEndianness","hash256","posts","h","p","acc","e","post","packageInfo","template","createVirtualMachineBCH","lockingBytecodeResult","reversed","getScriptHash","prefix","getAddress","utxos","now","edit","u","utxo","scriptId","key","hdPrivateKeyToP2pkhLockingBytecode","futureTime","isSpam","isPremature","outputValue","couponThreshold","privateKey","addressIndex","unlockingData","message","couponValue","binaryMessage","m","encodeDataPush","postId","changeAmount","deriveHdPublicKey","extraUtxos","fee","inputs","outputs","sourceOutputs","config","walletUtxos","valueIn","sumSourceOutputValue","valueOut","sumOutputValue","change","couponAmount","prevUtxos","generateTransaction","estimatedFee","getTransactionFees","lastIdx","tokenValidationResult","verifyTransactionTokens","verify"],"mappings":"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","x_google_ignoreList":[0]}