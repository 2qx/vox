import{a5 as z,d as tt,h as g,i as et,aI as M,H as nt,m as at,e as ot,n as F,$ as S,z as N,B as D,A as Y,N as st,o as ct,a2 as w,a1 as H,aJ as x,Q as it,u as A,v as I,w as b,aE as ut}from"./4Ej_4qXs.js";import{g as G,C as L,l as W,i as m,u as J,j as l,k as Ot,m as rt,o as lt,p as h,q as Q,r as Pt,s as B,t as _t,v as X,w as dt,x as pt,y as Tt,z as ht,A as Et,B as Z,D as Ut}from"./zIYK9qkZ.js";import{h as mt}from"./DeOyqwJy.js";const C=0,k=1,v=2;function Dt(O,t,e,n,a){g&&et();var o=O,i=z(),r=it,s=S,c,u,P,_=(i?D:Y)(void 0),d=(i?D:Y)(void 0),E=!1;function T(p,U){E=!0,U&&(w(V),H(V),x(r));try{p===C&&e&&(c?A(c):c=I(()=>e(o))),p===k&&n&&(u?A(u):u=I(()=>n(o,_))),p===v&&a&&(P?A(P):P=I(()=>a(o,d))),p!==C&&c&&b(c,()=>c=null),p!==k&&u&&b(u,()=>u=null),p!==v&&P&&b(P,()=>P=null)}finally{U&&(x(null),H(null),w(null),ut())}}var V=tt(()=>{if(s===(s=t()))return;let p=g&&M(s)===(o.data===nt);if(p&&(o=at(),ot(o),F(!1),p=!0),M(s)){var U=s;E=!1,U.then(f=>{U===s&&(N(_,f),T(k,!0))},f=>{if(U===s&&(N(d,f),T(v,!0),!a))throw d.v}),g?e&&(c=I(()=>e(o))):st(()=>{E||T(C,!0)})}else N(_,s),T(k,!1);return p&&F(!0),()=>s=S});g&&(o=ct)}const gt="https://libauth.org/schemas/wallet-template-v0.schema.json",It="Templates for Future Bitcoin Cash ecosystem of contracts ",kt="FBCH: Future Bitcoin Cash",yt={coupon_vault:{description:"An entity that holds coupons 'owned' by the covenant.",name:"Coupon Vault",scripts:["coupon_unlock","coupon_lock"],variables:{amount:{description:"Minimum required threshold to claim the coupon",name:"Coupon Amount (Satoshis)",type:"WalletData"},lock:{description:"The locking script the coupon will target",name:"Coupon destination",type:"WalletData"}}},future_vault:{description:"An entity that holds coupons 'owned' by the covenant.",name:"Future Vault",scripts:["vault_lock","vault_unlock"],variables:{locktime:{description:"The timestamp (blocks) when the future vault will become bidirectional",name:"Vault Locktime (blocks)",type:"WalletData"}}},future_channel:{description:"Vault holding messages to be burned into coupons.",name:"Future Chan",scripts:["process_message","edit_message","channel_lock"],variables:{channel:{description:"The subject of the channel",name:"Channel (bytes)",type:"WalletData"},amount:{description:"Minimum required threshold to claim the coupon",name:"Coupon Amount (Satoshis)",type:"WalletData"},vault_script:{description:"Unlocking bytecode for the future vault",name:"Future Vault bytecode",type:"WalletData"},coupon_script:{description:"Unlocking bytecode for the coupon vault",name:"Future coupon bytecode",type:"WalletData"}}},wallet:{description:"The entity paying transaction fees, swapping or editing messages.",name:"Funding Entity",scripts:["wallet_lock","wallet_unlock"],variables:{key:{description:"The private key that controls this wallet.",name:"Key",type:"HdKey"}}}},ft={default_channel:{data:{bytecode:{channel:"",lock:"",amount:"10000000",vault_script:"0xc0d3c0d0a06376b17568c0cec0d188c0cdc0c788c0d0c0c693c0d3c0cc939c77",coupon_script:"0x00cc00c694a16900c788c08bc39c"}},description:"",name:"Unnamed Scenario",transaction:{locktime:99e4}},clear_spam:{data:{currentBlockHeight:99e4},description:"Should clear a message sent with insufficient sats",extends:"default_channel",name:"Clear Spam Message",transaction:{inputs:[{unlockingBytecode:["slot"]},{unlockingBytecode:{script:"wallet_unlock"}}],outputs:[{lockingBytecode:{script:"wallet_lock"},valueSatoshis:999},{lockingBytecode:{script:"wallet_lock"},valueSatoshis:1e6}],locktime:99e4,version:2},sourceOutputs:[{lockingBytecode:["slot"],valueSatoshis:1e3,token:{category:"dead00000000000000000000000000000000000000000000000000000000beef",nft:{commitment:"6a00000000000000000000000000000000000000000000000000000000beef",capability:"none"}}},{lockingBytecode:{script:"wallet_lock"},valueSatoshis:1e6}]},transform_message:{data:{currentBlockHeight:99e4},description:"Should transform a message into a coupon",extends:"default_channel",name:"Transform Message",transaction:{inputs:[{unlockingBytecode:["slot"]},{unlockingBytecode:{script:"wallet_unlock"}}],outputs:[{lockingBytecode:{script:"coupon_lock"},valueSatoshis:10010}],locktime:99e4,version:2},sourceOutputs:[{lockingBytecode:["slot"],valueSatoshis:1e4,token:{category:"dead00000000000000000000000000000000000000000000000000000000beef",nft:{commitment:"6a00000000000000000000000000000000000000000000000000000000beef",capability:"none"}}},{lockingBytecode:{script:"wallet_lock"},valueSatoshis:9999}]},burn_message:{data:{bytecode:{channel:"",lock:"0xaa205b876e30b7a65024200d12cef03622def95a93468f980fb27561e5272ab965ad87",amount:"100000000",vault_script:"0xc0d3c0d0a06376b17568c0cec0d188c0cdc0c788c0d0c0c693c0d3c0cc939c77",coupon_script:"0x00cc00c694a16900c788c08bc39c"}},description:"",extends:"default_channel",name:"Burn (censor) message",transaction:{inputs:[{unlockingBytecode:["slot"]},{unlockingBytecode:{script:"wallet_unlock"}}],outputs:[{lockingBytecode:{script:"coupon_lock"},valueSatoshis:27700}]},sourceOutputs:[{lockingBytecode:["slot"],valueSatoshis:2770},{lockingBytecode:{script:"wallet_lock"},valueSatoshis:99e4}]},edit_message:{description:"Modify message with NFT key",extends:"default_channel",name:"Edit Message",transaction:{inputs:[{outpointTransactionHash:"dead00000000000000000000000000000000000000000000000000000000beef",outpointIndex:1,unlockingBytecode:["slot"],sequenceNumber:1e3},{unlockingBytecode:{script:"wallet_unlock"}}],outputs:[{valueSatoshis:1e4,token:{category:"dead00000000000000000000000000000000000000000000000000000000beef",nft:{commitment:"6a<'hi'>",capability:"mutable"}},lockingBytecode:{script:"channel_lock"}},{lockingBytecode:{script:"wallet_lock"},valueSatoshis:800}]},sourceOutputs:[{lockingBytecode:["slot"],valueSatoshis:1e4,token:{category:"dead00000000000000000000000000000000000000000000000000000000beef",nft:{commitment:"6a<'hello'>",capability:"mutable"}}},{lockingBytecode:{script:"wallet_lock"},valueSatoshis:800,token:{category:"dead00000000000000000000000000000000000000000000000000000000beef",nft:{commitment:"6a<beef>",capability:"minting"}}}]},claim_coupon:{data:{bytecode:{lock:"0xaa2082590fa4fd4f322dea535de4ebcebb6e65526e71432027a8ed6a3a201391d82c87",amount:"10000000",locktime:"1000"}},description:"Claim a coupon",name:"Claim Coupon",transaction:{inputs:[{unlockingBytecode:{script:"vault_unlock"}},{unlockingBytecode:{script:"wallet_unlock"}},{outpointTransactionHash:"dead00000000000000000000000000000000000000000000000000000000beef",outpointIndex:0,unlockingBytecode:["slot"]}],outputs:[{lockingBytecode:{script:"vault_lock"},valueSatoshis:10000001e3,token:{amount:1e3,category:"dead00000000000000000000000000000000000000000000000000000000beef"}}]},sourceOutputs:[{lockingBytecode:{script:"vault_lock"},valueSatoshis:1e3,token:{amount:10000001e3,category:"dead00000000000000000000000000000000000000000000000000000000beef"}},{lockingBytecode:{script:"wallet_lock"},valueSatoshis:1e10},{lockingBytecode:["slot"]}]},place_bch:{data:{bytecode:{locktime:"1000"}},description:"Place BCH into a Future Vault",name:"Place BCH for FBCH",transaction:{inputs:[{outpointTransactionHash:"dead00000000000000000000000000000000000000000000000000000000beef",outpointIndex:0,unlockingBytecode:["slot"]},{unlockingBytecode:{script:"wallet_unlock"}}],outputs:[{valueSatoshis:21e6,token:{amount:1e3,category:"dead00000000000000000000000000000000000000000000000000000000beef"},lockingBytecode:{script:"vault_lock"}},{valueSatoshis:1e3,token:{amount:20999e3,category:"dead00000000000000000000000000000000000000000000000000000000beef"},lockingBytecode:{script:"wallet_lock"}}]},sourceOutputs:[{lockingBytecode:["slot"],valueSatoshis:1e3,token:{amount:21e6,category:"dead00000000000000000000000000000000000000000000000000000000beef"}},{lockingBytecode:{script:"wallet_lock"},valueSatoshis:21e6}]},redeem_fbch:{data:{bytecode:{locktime:"1000"}},description:"",name:"Redeem FBCH for BCH",transaction:{locktime:1e3,inputs:[{outpointTransactionHash:"dead00000000000000000000000000000000000000000000000000000000beef",outpointIndex:0,unlockingBytecode:["slot"]},{unlockingBytecode:{script:"wallet_unlock"}}],outputs:[{valueSatoshis:1e3,lockingBytecode:{script:"vault_lock"},token:{amount:21e6,category:"dead00000000000000000000000000000000000000000000000000000000beef"}},{valueSatoshis:21e6}]},sourceOutputs:[{lockingBytecode:["slot"],valueSatoshis:21e6,token:{amount:1e3,category:"dead00000000000000000000000000000000000000000000000000000000beef"}},{lockingBytecode:{script:"wallet_lock"},valueSatoshis:1e3,token:{amount:20999e3,category:"dead00000000000000000000000000000000000000000000000000000000beef"}}]}},Nt=JSON.parse('{"process_message":{"fails":["edit_message"],"passes":["burn_message","clear_spam","transform_message"],"name":"Process Messages","script":"OP_0 // function index\\n","timeLockType":"height","unlocks":"channel_lock"},"edit_message":{"fails":["burn_message","clear_spam","transform_message"],"passes":["edit_message"],"name":"Edit Message","script":"OP_1 // function index\\n","timeLockType":"height","unlocks":"channel_lock"},"coupon_unlock":{"passes":["claim_coupon"],"name":"Unlock Coupon","script":"// \\"claim\\" function parameters\\n// none\\n","unlocks":"coupon_lock"},"vault_unlock":{"passes":["place_bch","redeem_fbch"],"name":"Unlock Future Vault","script":"// \\"swap\\" function parameters\\n// none\\n","timeLockType":"height","unlocks":"vault_lock"},"wallet_unlock":{"name":"Wallet Unlock","script":"<key.schnorr_signature.all_outputs>\\n<key.public_key>","unlocks":"wallet_lock"},"channel_lock":{"lockingType":"p2sh32","name":"Channel Message Lock","script":"<channel>\\n// pragma cashscript ~0.10.0;\\n    \\n// FutureChan - A message board contract.\\n//\\n// Message board for data written in mutable or immutable NFT commitments. \\n//\\n// - Messages can be removed after a week.\\n// - Messages can be censored early by paying a 9 times multiplier penalty.  \\n// - Messages must contain a value greater than 1/100th of a block time 2.5 months.\\n// - Messages with insufficient value may be cleared by anyone at any time.\\n// \\n// - Messages can be edited (or deleted) using an NFT with minting capability.\\n// \\n// - Clearing (or censoring) messages must create 0.1 FBCH (or 1 FBCH) coupons.\\n//\\n// - Many different channels can be used by using a different channel identifier.\\n// - Note: `cashc` compiler must be patched to not error from channel identifier usage. \\n//\\n//\\n\\n// contract FutureChan(bytes channel) {\\n\\n    OP_OVER OP_0 OP_NUMEQUAL OP_IF\\n    // function clearMessage() {\\n        \\n        // Chan messages will create a 0.1 FBCH coupon targeting a FBCH vault \\n        // where vault time is specified using the number of sats on the message.\\n        // Example #1: 9873 sats => ( 9873 % 10 ) * 1000 => FBCH-0987000; 0.1 BCH coupon\\n        //         #2:  543 sats =>  ( 543 % 10 ) * 1000 => MEV BURN\\n        //         #3: 9873 sats =>               98,730 => FBCH-0987000; 1 BCH coupon\\n\\n        OP_INPUTINDEX OP_UTXOVALUE OP_10 OP_DIV <1000> OP_MUL \\n        // int vaultTime = int(tx.inputs[this.activeInputIndex].value / 10)*1000;\\n\\n        // Default to a 0.1 BCH series coupon\\n        <10_000_000>\\n        // int amount = 10000000;\\n\\n        // If the message is being censored, the burner must provide 9 X the initial value to a 1 BCH coupon\\n        OP_INPUTINDEX OP_OUTPUTVALUE OP_INPUTINDEX OP_UTXOVALUE OP_10 OP_MUL OP_NUMEQUAL \\n        // bool isPrematureBurn = tx.outputs[this.activeInputIndex].value == tx.inputs[this.activeInputIndex].value*10;\\n\\n        // If this is an early burn (moderation), create a 1 BCH coupon \\n        OP_DUP OP_IF   \\n        //if(isPrematureBurn){\\n\\n            <100_000_000> OP_ROT OP_DROP OP_SWAP\\n            //amount = 100000000;\\n        // } // \\n        OP_ENDIF\\n\\n        // If the message has matured, the full value is used for a coupon\\n        OP_INPUTINDEX OP_OUTPUTVALUE OP_INPUTINDEX OP_UTXOVALUE OP_NUMEQUAL \\n        // bool hasMatured = tx.outputs[this.activeInputIndex].value == tx.inputs[this.activeInputIndex].value;\\n\\n        // If not early, require the message is a week old\\n        OP_DUP OP_IF \\n        // if(hasMatured){\\n\\n            // Require the message be at least a week old\\n            <1000> OP_CHECKSEQUENCEVERIFY \\n            // require(tx.age >= 1000);\\n\\n        // }  //\\n        OP_DROP OP_ENDIF \\n\\n        // If sats specifed a bad locktime (allow an early burn, no coupon, pure MEV)        \\n        OP_NOT OP_SWAP OP_NOT OP_BOOLAND OP_IF \\n        // if(!hasMatured && !isPrematureBurn){\\n\\n            // If the vault time indicated is less than ~2.5 months into the future.\\n            // Let the message be cleared and the value be taken by anyone.\\n            OP_OVER <10_000> OP_SUB OP_CHECKLOCKTIMEVERIFY OP_DROP \\n            // require(tx.time >= ( vaultTime - 10000 ));\\n\\n        // } \\n\\n        // Otherwise, the sats must pay an FBCH coupon\\n        OP_ELSE \\n        // else {\\n\\n            // Calculate the future vault corresponding to the locktime\\n            OP_OVER OP_SIZE \\n            OP_NIP OP_2 OP_PICK \\n            OP_CAT <0xc0d3c0d0a06376b17568c0cec0d188c0cdc0c788c0d0c0c693c0d3c0cc939c77> OP_CAT \\n            // bytes theVault = bytes(bytes(vaultTime).length) + \\n            //                 bytes(vaultTime) + \\n            //                 0xc0d3c0d0a06376b17568c0cec0d188c0cdc0c788c0d0c0c693c0d3c0cc939c77;\\n\\n            // Construct P2SH32 locking bytecode from redeem bytecode\\n            <0xaa20> OP_OVER OP_HASH256 OP_CAT <0x87> \\n            // bytes vaultLockingBytecode = 0xaa20 + hash256(theVault) + 0x87;\\n\\n            // Calculate the coupon vault corresponding to the locktime\\n            OP_CAT OP_DUP OP_SIZE OP_NIP OP_OVER OP_CAT\\n            OP_3 OP_PICK OP_SIZE OP_NIP OP_CAT \\n            OP_3 OP_PICK OP_CAT <0x00cc00c694a16900c788c08bc39c> OP_CAT\\n            // bytes theCoupon =  bytes(vaultLockingBytecode.length) + vaultLockingBytecode +\\n            //                 bytes(bytes(amount).length) + bytes(amount) + \\n            //                 0x00cc00c694a16900c788c08bc39c;\\n\\n            // Construct P2SH32 locking bytecode from redeem bytecode\\n            <0xaa20> OP_OVER OP_HASH256 OP_CAT <0x87> OP_CAT \\n            // bytes couponLockingBytecode = 0xaa20 + hash256(theCoupon) + 0x87;\\n\\n            // Send the message value to the coupon vault.\\n            OP_INPUTINDEX OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY \\n            // require(tx.outputs[this.activeInputIndex].lockingBytecode == couponLockingBytecode);\\n\\n        // } // \\n        OP_2DROP OP_2DROP OP_ENDIF\\n\\n        // Without CashTokens\\n        OP_INPUTINDEX OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUALVERIFY \\n        // require(tx.outputs[this.activeInputIndex].tokenCategory == 0x);\\n\\n    // } // \\n    OP_2DROP OP_2DROP \\n\\n    // Messages on mutable NFTs may be edited (or deleted) using a minting NFT of the same token category.  \\n    // Messages on immutable NFTs may only be deleted. \\n    //\\n    // oldMessage[0]          -> editedMessage[0]\\n    // oldMessage[1]          -> editedMessage[1]\\n    // oldMessage[n]          -> editedMessage[n]\\n    // mintingBaton[in.len-1] -> extendedMessage[n+1]\\n    //                        -> extendedMessage[n+2]\\n    //                        -> mintingBaton[out.len-1]\\n    //\\n    OP_1 OP_ELSE OP_SWAP OP_1 OP_NUMEQUALVERIFY \\n    // function editMessage(){\\n\\n        // Sats must be carried forward.\\n        OP_INPUTINDEX OP_OUTPUTVALUE OP_INPUTINDEX OP_UTXOVALUE OP_NUMEQUALVERIFY \\n        // require(tx.outputs[this.activeInputIndex].value == tx.inputs[this.activeInputIndex].value);\\n\\n        // ... to an output on this same contract\\n        OP_INPUTINDEX OP_OUTPUTBYTECODE OP_INPUTINDEX OP_UTXOBYTECODE OP_EQUALVERIFY \\n        // require(tx.outputs[this.activeInputIndex].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode);\\n        \\n        // But neither the commitment, NFT nor token data are required as outputs. They may be omitted.\\n\\n        // As long as last input carried a matching minting NFT\\n        // \\n        OP_TXINPUTCOUNT OP_1SUB OP_UTXOTOKENCATEGORY OP_INPUTINDEX OP_UTXOTOKENCATEGORY <32> OP_SPLIT OP_DROP OP_2 OP_CAT OP_EQUAL \\n        // require(tx.inputs[tx.inputs.length - 1].tokenCategory == tx.inputs[this.activeInputIndex].tokenCategory.split(32)[0] + 0x02);\\n\\n    // } //\\n     OP_NIP  \\n\\n// } //\\n OP_ENDIF\\n"},"coupon_lock":{"lockingType":"p2sh32","name":"Coupon Lock","script":"<lock> <amount>\\n// contract Coupon(\\n//   // Minimum spent (sats) to claim each coupon utxo.\\n//   int amount,\\n  \\n//   // Contract holding the logic.\\n//   bytes lock\\n// ){\\n\\n//   function apply() {\\n\\n    // assure at the minium amount is sent to the intended contract\\n    OP_0 OP_OUTPUTVALUE OP_0 OP_UTXOVALUE OP_SUB OP_LESSTHANOREQUAL OP_VERIFY\\n    // require((tx.outputs[0].value - tx.inputs[0].value) >= amount);\\n\\n\\n    // Check that the Coupon is interacting with an existing Vault instance \\n    OP_0 OP_UTXOBYTECODE OP_EQUALVERIFY\\n\\n    // require(tx.inputs[0].lockingBytecode == lock);\\n\\n    // The coupon must be spent as the last input, \\n    //   therefore only coupon may be spent at a time.\\n    OP_INPUTINDEX OP_1ADD OP_TXINPUTCOUNT OP_NUMEQUAL\\n    // require(this.activeInputIndex+1 == tx.inputs.length);\\n // }\\n"},"wallet_lock":{"lockingType":"standard","name":"Wallet Lock","script":"OP_DUP\\nOP_HASH160 <$(<key.public_key> OP_HASH160\\n)> OP_EQUALVERIFY\\nOP_CHECKSIG"},"vault_lock":{"lockingType":"p2sh32","name":"Lock Future Vault","script":"<locktime> \\n// contract Vault(int locktime) {\\n\\n    // function swap() {\\n        \\n        // If tokens are flowing back into this contract\\n        OP_INPUTINDEX OP_OUTPUTTOKENAMOUNT OP_INPUTINDEX OP_UTXOTOKENAMOUNT OP_GREATERTHAN OP_IF \\n        // if(tx.outputs[this.activeInputIndex].tokenAmount > tx.inputs[this.activeInputIndex].tokenAmount){\\n        \\n            // Enforce a BIP65 timelock \\n            // Note, intended for use with block height based locks \\n            // (where:  locktime < 500M).\\n            OP_DUP OP_CHECKLOCKTIMEVERIFY OP_DROP\\n            // require(tx.time >= locktime);\\n\\n        //} \\n        OP_ENDIF \\n        \\n        // Inspired by wrapped.cash c. Nov 2023\\n        // Author: Dagur Valberg Johannsson <dagurval@pvv.ntnu.no> \\n        // License: MIT\\n        //\\n        // ensure the token in and out matches\\n        OP_INPUTINDEX OP_UTXOTOKENCATEGORY OP_INPUTINDEX OP_OUTPUTTOKENCATEGORY OP_EQUALVERIFY \\n        // require(\\n        //   tx.inputs[this.activeInputIndex].tokenCategory \\n        //   == \\n        //   tx.outputs[this.activeInputIndex].tokenCategory\\n        //   );\\n\\n        // Enforce that this contract lives on\\n        OP_INPUTINDEX OP_OUTPUTBYTECODE OP_INPUTINDEX OP_UTXOBYTECODE OP_EQUALVERIFY\\n        // require(\\n        //   tx.outputs[this.activeInputIndex].lockingBytecode \\n        //   == \\n        //   tx.inputs[this.activeInputIndex].lockingBytecode\\n        //   );\\n\\n        // ensure the sum of sats and tokens in \\n        // matches the sum of sats and tokens out.\\n        OP_INPUTINDEX OP_UTXOTOKENAMOUNT OP_INPUTINDEX OP_UTXOVALUE OP_ADD\\n        OP_INPUTINDEX OP_OUTPUTTOKENAMOUNT OP_INPUTINDEX OP_OUTPUTVALUE OP_ADD \\n        OP_NUMEQUAL\\n        OP_NIP        \\n        // require(\\n        //   tx.inputs[this.activeInputIndex].tokenAmount + \\n        //   tx.inputs[this.activeInputIndex].value \\n        //   == \\n        //   tx.outputs[this.activeInputIndex].tokenAmount + \\n        //   tx.outputs[this.activeInputIndex].value\\n        //  );\\n//     }\\n// }"},"gantry_lock":{"lockingType":"p2sh32","name":"Gantry","script":"<vault_script> \\n<step> \\n OP_INPUTINDEX OP_0 OP_NUMEQUALVERIFY\\n OP_INPUTINDEX OP_UTXOBYTECODE OP_INPUTINDEX OP_OUTPUTBYTECODE OP_EQUALVERIFY\\n OP_INPUTINDEX OP_UTXOTOKENCATEGORY OP_INPUTINDEX OP_OUTPUTTOKENCATEGORY OP_EQUALVERIFY\\n OP_INPUTINDEX OP_OUTPUTVALUE OP_INPUTINDEX OP_UTXOVALUE <8500> OP_SUB OP_NUMEQUALVERIFY OP_INPUTINDEX OP_UTXOTOKENCOMMITMENT OP_BIN2NUM OP_INPUTINDEX OP_OUTPUTTOKENCOMMITMENT OP_OVER OP_3 OP_PICK OP_ADD OP_4 OP_NUM2BIN OP_EQUALVERIFY OP_DUP OP_ROT OP_DIV OP_10 OP_MOD OP_0 OP_NUMEQUAL OP_IF OP_TXOUTPUTCOUNT OP_1 OP_NUMEQUALVERIFY OP_ELSE OP_DUP OP_SIZE OP_NIP OP_OVER OP_CAT OP_2 OP_PICK OP_CAT OP_HASH256 OP_PUSHBYTES_32 OP_OVER OP_HASH256 OP_CAT OP_EQUAL OP_CAT OP_1 OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY OP_1 OP_OUTPUTTOKENCATEGORY OP_0 OP_OUTPOINTTXHASH OP_EQUALVERIFY OP_1 OP_OUTPUTTOKENCOMMITMENT OP_0 OP_EQUALVERIFY OP_1 OP_OUTPUTTOKENAMOUNT <2100000000000000> OP_NUMEQUALVERIFY OP_1 OP_OUTPUTVALUE <1000> OP_NUMEQUALVERIFY OP_2 OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY OP_2 OP_OUTPUTTOKENCATEGORY OP_0 OP_OUTPOINTTXHASH OP_EQUALVERIFY OP_2 OP_OUTPUTTOKENCOMMITMENT OP_0 OP_EQUALVERIFY OP_2 OP_OUTPUTTOKENAMOUNT <2100000000000000> OP_NUMEQUALVERIFY OP_2 OP_OUTPUTVALUE <1000> OP_NUMEQUALVERIFY OP_3 OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY OP_3 OP_OUTPUTTOKENCATEGORY OP_0 OP_OUTPOINTTXHASH OP_EQUALVERIFY OP_3 OP_OUTPUTTOKENCOMMITMENT OP_0 OP_EQUALVERIFY OP_3 OP_OUTPUTTOKENAMOUNT <2100000000000000> OP_NUMEQUALVERIFY OP_3 OP_OUTPUTVALUE <1000> OP_NUMEQUALVERIFY OP_4 OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY OP_4 OP_OUTPUTTOKENCATEGORY OP_0 OP_OUTPOINTTXHASH OP_EQUALVERIFY OP_4 OP_OUTPUTTOKENCOMMITMENT OP_0 OP_EQUALVERIFY OP_4 OP_OUTPUTTOKENAMOUNT <2100000000000000> OP_NUMEQUALVERIFY OP_4 OP_OUTPUTVALUE <1000> OP_NUMEQUALVERIFY OP_5 OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY OP_5 OP_OUTPUTTOKENCATEGORY OP_0 OP_OUTPOINTTXHASH OP_EQUALVERIFY OP_5 OP_OUTPUTTOKENCOMMITMENT OP_0 OP_EQUALVERIFY OP_5 OP_OUTPUTTOKENAMOUNT <2100000000000000> OP_NUMEQUALVERIFY OP_5 OP_OUTPUTVALUE <1000> OP_NUMEQUALVERIFY OP_6 OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY OP_6 OP_OUTPUTTOKENCATEGORY OP_0 OP_OUTPOINTTXHASH OP_EQUALVERIFY OP_6 OP_OUTPUTTOKENCOMMITMENT OP_0 OP_EQUALVERIFY OP_6 OP_OUTPUTTOKENAMOUNT <2100000000000000> OP_NUMEQUALVERIFY OP_6 OP_OUTPUTVALUE <1000> OP_NUMEQUALVERIFY OP_7 OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY OP_7 OP_OUTPUTTOKENCATEGORY OP_0 OP_OUTPOINTTXHASH OP_EQUALVERIFY OP_7 OP_OUTPUTTOKENCOMMITMENT OP_0 OP_EQUALVERIFY OP_7 OP_OUTPUTTOKENAMOUNT <2100000000000000> OP_NUMEQUALVERIFY OP_7 OP_OUTPUTVALUE <1000> OP_NUMEQUALVERIFY OP_8 OP_OUTPUTBYTECODE <OP_RETURN <\'FBCH\'>> OP_4 OP_PICK OP_SIZE OP_NIP OP_CAT OP_4 OP_PICK OP_CAT OP_EQUALVERIFY OP_8 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUALVERIFY OP_8 OP_OUTPUTVALUE OP_0 OP_NUMEQUALVERIFY OP_TXOUTPUTCOUNT OP_9 OP_NUMEQUALVERIFY OP_2DROP OP_ENDIF OP_2DROP OP_1"},"battery_lock":{"lockingType":"p2sh32","name":"Battery","script":"<vault_script> <gantry_script> <857000> <1_000_000> OP_INPUTINDEX OP_UTXOTOKENCOMMITMENT OP_BIN2NUM OP_2 OP_PICK OP_3 OP_ROLL OP_2 OP_PICK OP_MOD OP_SUB OP_OVER OP_ADD OP_4 OP_NUM2BIN OP_0 OP_OUTPUTTOKENCOMMITMENT OP_EQUALVERIFY OP_3 OP_PICK OP_SIZE OP_NIP OP_4 OP_ROLL OP_CAT OP_OVER OP_SIZE OP_NIP OP_CAT OP_OVER OP_CAT OP_3 OP_ROLL OP_CAT OP_HASH256 OP_PUSHBYTES_32 OP_SWAP OP_HASH256 OP_CAT OP_EQUAL OP_CAT OP_0 OP_OUTPUTBYTECODE OP_EQUALVERIFY OP_INPUTINDEX OP_UTXOTOKENCATEGORY <32> OP_SPLIT OP_DROP OP_1 OP_CAT OP_0 OP_OUTPUTTOKENCATEGORY OP_EQUALVERIFY OP_TXOUTPUTCOUNT OP_2 OP_NUMEQUALVERIFY OP_0 OP_OUTPUTVALUE <42500000000> OP_2 OP_PICK OP_DIV OP_GREATERTHAN OP_VERIFY OP_1 OP_OUTPUTVALUE OP_INPUTINDEX OP_UTXOVALUE <42500000000> OP_3 OP_PICK OP_DIV OP_SUB <1800> OP_SUB OP_GREATERTHAN OP_VERIFY OP_DUP OP_ROT OP_GREATERTHAN OP_IF OP_1 OP_OUTPUTTOKENCOMMITMENT OP_OVER OP_10 OP_DIV OP_4 OP_NUM2BIN OP_EQUALVERIFY OP_1 OP_OUTPUTTOKENCATEGORY OP_INPUTINDEX OP_UTXOTOKENCATEGORY OP_EQUALVERIFY OP_1 OP_OUTPUTBYTECODE OP_INPUTINDEX OP_UTXOBYTECODE OP_EQUALVERIFY OP_ELSE OP_1 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUALVERIFY OP_ENDIF OP_DROP OP_1"}}'),At=["BCH_2023_05","BCH_SPEC"],j={$schema:gt,description:It,name:kt,entities:yt,scenarios:ft,scripts:Nt,supported:At},bt="@fbch/lib",Bt={name:bt};class ${static compiler=G(j)}class K{static compiler=$.compiler;amount=1e6;lock=new Uint8Array(0);static unlockingScript="00cc00c694a16900c788c08bc39c";static getAddress(t,e,n=L.mainnet){let a=this.getLockingBytecode(t,e),o=W({bytecode:a,prefix:n,tokenSupport:!1});if(typeof o=="string")throw o;return o.address}static getUnlockingBytecode(t,e){const n=this.compiler.generateBytecode({data:{bytecode:{amount:m(BigInt(t)),lock:e}},scriptId:"coupon_unlock"});if(!n.success)throw new Error("Failed to generate bytecode, script: FutureChan, "+JSON.stringify(n,null,"  "));return n.bytecode.slice(1)}static getLockingBytecode(t,e){const n=this.compiler.generateBytecode({data:{bytecode:{amount:m(BigInt(t)),lock:e}},scriptId:"coupon_lock"});if(!n.success)throw new Error("Failed to generate bytecode, script: FutureChan, "+JSON.stringify(n,null,"  "));return n.bytecode}}class Ct{static compiler=$.compiler;locktime=0;static getAddress(t,e=L.mainnet,n=!0){let a=this.getLockingBytecode(t),o=W({bytecode:a,prefix:e,tokenSupport:n});if(typeof o=="string")throw o;return o.address}static getCoupon(t,e,n=L.mainnet){return K.getAddress(t,this.getLockingBytecode(e),n)}static getCouponLockingBytecode(t,e){return K.getLockingBytecode(t,this.getLockingBytecode(e))}static getUnlockingBytecode(t){const e=this.compiler.generateBytecode({data:{bytecode:{locktime:m(BigInt(t))}},scriptId:"vault_unlock"});if(!e.success)throw new Error("Failed to generate bytecode, script: FutureChan, "+JSON.stringify(e,null,"  "));return e.bytecode.slice(1)}static getLockingBytecode(t){const e=this.compiler.generateBytecode({data:{bytecode:{locktime:m(BigInt(t))}},scriptId:"vault_lock"});if(!e.success)throw new Error("Failed to generate bytecode, script: , "+JSON.stringify(e,null,"  "));return e.bytecode}}function q(O){if(!O)return new Uint8Array(0);const t=O.replace(/^0x/,"");return(t===O?J:l)(t)}const R=2147483648;class y{hash;auth;height;sequence;body;likes;dislikes;ref;error;constructor({hash:t="",auth:e="",height:n=-1,sequence:a=-1,body:o="",likes:i=0,dislikes:r=0,ref:s="",error:c=""}){this.hash=t,this.auth=e,this.height=n,this.sequence=a>R?a-R:a,this.body=o,this.likes=i,this.dislikes=r,this.ref=s,this.error=c}}function Yt(O){const t=l(O),n=Ut(t).split(" ").pop().substring(2);return Z(l(n))}function vt(O,t,e,n){if(!n)return;let a=Et(l(n));if(typeof a=="string")return new y({height:t,hash:e,error:a});if(!a.outputs[0].token)return;if(!a.outputs[0].token.nft)return new y({height:t,hash:e,error:"no nft on first output"});if(!a.outputs[0].token.nft.commitment)return new y({height:t,hash:e,error:"no nft commitment first output"});let o="",i="",r=0,s=0;const c=a.outputs.filter(u=>h(u.lockingBytecode)==O).filter(u=>u.token).filter(u=>u.token?.nft).map(u=>h(u.token?.nft?.commitment));if(c&&c[0])return c[0].slice(0,8)=="6a025630"&&(o=c.map(u=>Z(l(u.slice(10)))).join("")),c[0].slice(0,8)=="6a0256b2"&&(i=c[0].slice(10),r=1),c[0].slice(0,8)=="6a02562d"&&(i=c[0].slice(10),s=1),new y({hash:e,auth:h(a.outputs[0]?.token?.category),body:o,height:t,sequence:a.inputs[0]?.sequenceNumber,ref:i,likes:r,dislikes:s})}function Lt(O,t){const e=Math.ceil(O.length/t),n=Array(e);let a=0;for(let o=0;o<e;o++)n[o]=O.substr(a,t),a+=t;return n}const Rt=(O,t)=>t<=0&&O>0?-1:t>0&&O>0?Math.sign(O-t):Math.sign(t-O);function wt(O,t,e){const n=h(Vt.getLockingBytecode(e)),a=new Map(t.map(s=>[Tt(h(ht(l(s)))),s]));let o=O.map(s=>vt(n,s.height,s.tx_hash,a.get(s.tx_hash))).filter(s=>s!=null),r=o.filter(s=>s.likes==1).map(s=>s.ref).reduce((s,c)=>s.set(c,(s.get(c)||0)+1),new Map);for(const s of o)s.likes=r.get(s.hash)?r.get(s.hash):0;return o=o.sort((s,c)=>c.height===s.height||c.height<=0&&s.height<=0?Math.sign(s.sequence-c.sequence):Rt(s.height,c.height)),o.filter(s=>s.body!="")}class Vt{static USER_AGENT=Bt.name;static tokenAware=!0;static template=j;static compiler=G(this.template);static vm=Ot();static getLockingBytecode(t){const e=this.compiler.generateBytecode({data:{bytecode:{channel:q(t)}},scriptId:"channel_lock"});if(!e.success)throw new Error("Failed to generate bytecode, script: , "+JSON.stringify(e,null,"  "));return e.bytecode}static getScriptHash(t,e=!0){return rt(this.getLockingBytecode(t),e)}static getAddress(t="",e="bitcoincash"){return lt(this.getLockingBytecode(t),e,this.tokenAware)}static getInputs(t,e,n,a=!1){return e.map(o=>this.getInput(t,o,n,a))}static getInput(t,e,n,a=!1){let o=a?"edit_message":"process_message";const i=n-e.height>=1e3?1e3:0;return{outpointIndex:e.tx_pos,outpointTransactionHash:l(e.tx_hash),sequenceNumber:i,unlockingBytecode:{compiler:this.compiler,script:o,data:{bytecode:{channel:q(t),locktime:m(BigInt(Number(e.value)/10*1e3))}},valueSatoshis:BigInt(e.value),token:e.token_data?{category:l(e.token_data.category),amount:BigInt(e.token_data.amount),nft:e.token_data.nft?{commitment:l(e.token_data.nft.commitment),capability:e.token_data.nft.capability}:void 0}:void 0}}}static getSourceOutputs(t,e){return e.map(n=>this.getSourceOutput(t,n))}static getSourceOutput(t,e){return{outpointIndex:e.tx_pos,outpointTransactionHash:l(e.tx_hash),sequenceNumber:1,unlockingBytecode:Uint8Array.from([]),lockingBytecode:this.getLockingBytecode(t),valueSatoshis:BigInt(e.value)}}static getWalletSourceOutput(t,e){return{lockingBytecode:e?mt({addressIndex:0,hdPrivateKey:e}):Uint8Array.from(Array(33)),valueSatoshis:BigInt(t.value),token:t.token_data?{category:l(t.token_data.category),amount:BigInt(t.token_data.amount),nft:t.token_data.nft?{commitment:l(t.token_data.nft.commitment),capability:t.token_data.nft.capability}:void 0}:void 0}}static getCouponOutputs(t,e){return t.map(n=>this.getCouponOutput(n,e)).filter(n=>n!==void 0)}static getCouponOutput(t,e){let n=Math.floor(t.value/10)*1e3,a=n-t.height<1e3,o=e-t.height<1e3,i=o?t.value*10:t.value;i=a?t.value-1:i;let r=o?1e8:1e7;return r=a?1e7:r,{lockingBytecode:Ct.getCouponLockingBytecode(r,n),valueSatoshis:BigInt(i)}}static getWalletInputs(t,e,n){return t.map(a=>this.getWalletInput(a,e,n))}static getWalletInput(t,e,n,a=0){let o=e?{compiler:this.compiler,data:{hdKeys:{addressIndex:a,hdPrivateKeys:{wallet:e}}},script:"wallet_unlock",valueSatoshis:BigInt(t.value)}:Uint8Array.from(Array());return o.token=t.token_data?{category:l(t.token_data.category),amount:t.token_data.amount,nft:t.token_data.nft?{commitment:l(t.token_data.nft.commitment),capability:t.token_data.nft.capability}:void 0}:void 0,{outpointIndex:t.tx_pos,outpointTransactionHash:l(t.tx_hash),sequenceNumber:n&&n+R,unlockingBytecode:o}}static getChannelMessageOutputs(t,e,n,a){return Lt(e,32).map(i=>"6a025630"+h(Q(J(i)))).map(i=>({lockingBytecode:this.getLockingBytecode(t),valueSatoshis:BigInt(a),token:{amount:0n,category:l(n.token_data.category),nft:{capability:"mutable",commitment:l(i)}}}))}static getLikeOutput(t,e,n,a){let o="6a0256B2"+h(Q(l(e)));return{lockingBytecode:this.getLockingBytecode(t),valueSatoshis:BigInt(a),token:{amount:0n,category:l(n.token_data.category),nft:{capability:"none",commitment:l(o)}}}}static getChangeOutput(t,e,n,a=0){return{lockingBytecode:n?{compiler:this.compiler,data:{hdKeys:{addressIndex:a,hdPublicKeys:{wallet:Pt(n).hdPublicKey}}},script:"wallet_lock"}:Uint8Array.from(Array(33)),valueSatoshis:e,token:{amount:0n,category:l(t.token_data.category),nft:{capability:"minting",commitment:l(t.token_data?.nft?.commitment)}}}}static clear(t,e,n,a,o,i,r=1){const s=[],c=[],u=[];let P={locktime:o,version:2,inputs:s,outputs:c},_=[n];i&&_.push(...i),P.inputs.push(...this.getInputs(t,e,o)),P.inputs.push(...this.getWalletInputs(_,a)),P.outputs.push(...this.getCouponOutputs(e,o)),u.push(...this.getSourceOutputs(t,e)),u.push(this.getWalletSourceOutput(n,a));let d=B(u),E=_t(P.outputs),T=d-E;return P.outputs.push(this.getChangeOutput(n,T,a)),this.buildAndValidateTransaction(P,u,r)}static post(t,e,n,a,o,i,r,s=1){const c=[],u=[],P=[];let _={locktime:0,version:2,inputs:c,outputs:u},d=[n];r&&d.push(...r),_.inputs.push(...this.getWalletInputs(d,o,i)),_.outputs.push(...this.getChannelMessageOutputs(t,e,n,a)),P.push(this.getWalletSourceOutput(n,o));let T=B(P)-BigInt(_.outputs.length*a);return _.outputs.push(this.getChangeOutput(n,T,o)),this.buildAndValidateTransaction(_,P,s)}static like(t,e,n,a,o,i=1){const r=[],s=[],c=[];let u={locktime:0,version:2,inputs:r,outputs:s},P=[n];u.inputs.push(...this.getWalletInputs(P,o)),u.outputs.push(this.getLikeOutput(t,e,n,a)),c.push(this.getWalletSourceOutput(n,o));let d=B(c)-BigInt(u.outputs.length*a);return u.outputs.push(this.getChangeOutput(n,d,o)),this.buildAndValidateTransaction(u,c,i)}static buildAndValidateTransaction(t,e,n=1){let a=X(t);if(!a.success)throw new Error("generate transaction failed!, errors: "+JSON.stringify(a.errors,null,"  "));const o=dt(a.transaction,n),i=t.outputs.length-1;if(t.outputs[i].valueSatoshis=t.outputs[i].valueSatoshis-o,a=X(t),!a.success)throw new Error("generate transaction failed!, errors: "+JSON.stringify(a.errors,null,"  "));const r=a.transaction,s=pt(r,e);if(s!==!0&&n>0)throw s;let c=this.vm.verify({sourceOutputs:e,transaction:r});return{sourceOutputs:e,transaction:r,verify:c}}}export{Vt as C,Dt as a,wt as b,Yt as p};
//# sourceMappingURL=mdkU_V67.js.map
