{"version":3,"file":"BMx2nEoc.js","sources":["../../../../../../../../node_modules/.pnpm/@bitauth+libauth@3.0.0/node_modules/@bitauth/libauth/build/lib/crypto/pbkdf2.js","../../../../../../../../node_modules/.pnpm/@bitauth+libauth@3.0.0/node_modules/@bitauth/libauth/build/lib/key/bip39.js","../../../../../../../../node_modules/.pnpm/@bitauth+libauth@3.0.0/node_modules/@bitauth/libauth/build/lib/compiler/standard/p2pkh.js","../../../../../../../../node_modules/.pnpm/@bitauth+libauth@3.0.0/node_modules/@bitauth/libauth/build/lib/compiler/p2pkh-utils.js","../../../../../../../common/out/wallet.js"],"sourcesContent":["import { formatError, numberToBinUint32BE } from '../format/format.js';\nimport { hmacSha256, hmacSha512 } from './hmac.js';\nexport var Pbkdf2Error;\n(function (Pbkdf2Error) {\n    Pbkdf2Error[\"invalidIterations\"] = \"Invalid PBKDF2 parameters: iterations must be a positive integer.\";\n    Pbkdf2Error[\"invalidDerivedKeyLength\"] = \"Invalid PBKDF2 parameters: derived key length must be a positive integer.\";\n    Pbkdf2Error[\"invalidHmacLength\"] = \"Invalid HMAC length: HMAC length must be a positive integer.\";\n})(Pbkdf2Error || (Pbkdf2Error = {}));\n/**\n * Instantiate a PBKDF2 function as specified by RFC 2898.\n *\n * @param hmacFunction - the HMAC function to use\n * @param hmacByteLength - the byte-length of the HMAC function\n */\nexport const instantiatePbkdf2Function = (hmacFunction, hmacByteLength) => \n// eslint-disable-next-line complexity\n(parameters) => {\n    /* eslint-disable functional/immutable-data, functional/no-let, functional/no-loop-statements, functional/no-expression-statements, no-bitwise, no-plusplus */\n    const { password, salt, iterations, derivedKeyLength } = parameters;\n    if (!Number.isInteger(iterations) || iterations <= 0) {\n        return formatError(Pbkdf2Error.invalidIterations, `Iterations parameter: ${iterations}.`);\n    }\n    if (!Number.isInteger(derivedKeyLength) || derivedKeyLength <= 0) {\n        return formatError(Pbkdf2Error.invalidDerivedKeyLength, `Derived key length: ${derivedKeyLength}.`);\n    }\n    if (!Number.isInteger(hmacByteLength) || hmacByteLength <= 0) {\n        return formatError(Pbkdf2Error.invalidHmacLength, `HMAC length: ${hmacByteLength}.`);\n    }\n    const iterationCountByteLength = 4;\n    const derivedKey = new Uint8Array(derivedKeyLength);\n    const block = new Uint8Array(salt.length + iterationCountByteLength);\n    block.set(salt, 0);\n    let writePosition = 0;\n    const length = Math.ceil(derivedKeyLength / hmacByteLength);\n    for (let i = 1; i <= length; i++) {\n        const iterationUint32BEEncoded = numberToBinUint32BE(i);\n        block.set(iterationUint32BEEncoded, salt.length);\n        const accumulatedMac = hmacFunction(password, block);\n        let intermediateMac = accumulatedMac;\n        for (let j = 1; j < iterations; j++) {\n            intermediateMac = hmacFunction(password, intermediateMac);\n            for (let k = 0; k < hmacByteLength; k++) {\n                accumulatedMac[k] ^= intermediateMac[k]; // eslint-disable-line @typescript-eslint/no-non-null-assertion\n            }\n        }\n        const truncatedResult = accumulatedMac.subarray(0, derivedKeyLength);\n        derivedKey.set(truncatedResult, writePosition);\n        writePosition += hmacByteLength;\n    }\n    return derivedKey;\n    /* eslint-enable functional/immutable-data, functional/no-let, functional/no-loop-statements, functional/no-expression-statements, no-bitwise, no-plusplus */\n};\nconst hmacSha256ByteLength = 32;\n/**\n * Derive a key using PBKDF2 and the HMAC SHA256 function as specified in RFC 2898.\n *\n * Note, if the provided `parameters` are valid, this method will never error.\n *\n * @param parameters - the PBKDF2 parameters to use\n * @param sha256Hmac - the SHA256 HMAC implementation to use (defaults to the\n * internal WASM implementation)\n */\nexport const pbkdf2HmacSha256 = (parameters, sha256Hmac = hmacSha256) => instantiatePbkdf2Function(sha256Hmac, hmacSha256ByteLength)(parameters);\nconst hmacSha512ByteLength = 64;\n/**\n * Derive a key using PBKDF2 and the HMAC SHA512 function as specified in RFC 2898.\n *\n * Note, if the provided `parameters` are valid, this method will never error.\n *\n * @param parameters - the PBKDF2 parameters to use\n * @param sha512Hmac - the SHA512 HMAC implementation to use (defaults to the\n * internal WASM implementation)\n */\nexport const pbkdf2HmacSha512 = (parameters, sha512Hmac = hmacSha512) => instantiatePbkdf2Function(sha512Hmac, hmacSha512ByteLength)(parameters);\n//# sourceMappingURL=pbkdf2.js.map","import { pbkdf2HmacSha512 as internalPbkdf2HmacSha512, sha512 as internalSha512, sha256, } from '../crypto/crypto.js';\nimport { binStringToBin, binToBinString, formatError, splitEvery, utf8ToBin, } from '../format/format.js';\nimport { deriveHdPrivateNodeFromSeed } from './hd-key.js';\nimport { generateRandomBytes as internalGenerateRandomBytes } from './key-utils.js';\nimport { bip39WordListChineseSimplified } from './word-lists/bip39.chinese-simplified.js';\nimport { bip39WordListChineseTraditional } from './word-lists/bip39.chinese-traditional.js';\nimport { bip39WordListCzech } from './word-lists/bip39.czech.js';\nimport { bip39WordListEnglish } from './word-lists/bip39.english.js';\nimport { bip39WordListFrench } from './word-lists/bip39.french.js';\nimport { bip39WordListItalian } from './word-lists/bip39.italian.js';\nimport { bip39WordListJapanese } from './word-lists/bip39.japanese.js';\nimport { bip39WordListKorean } from './word-lists/bip39.korean.js';\nimport { bip39WordListPortuguese } from './word-lists/bip39.portuguese.js';\nimport { bip39WordListSpanish } from './word-lists/bip39.spanish.js';\nexport { bip39WordListChineseSimplified, bip39WordListChineseTraditional, bip39WordListCzech, bip39WordListEnglish, bip39WordListFrench, bip39WordListItalian, bip39WordListJapanese, bip39WordListKorean, bip39WordListPortuguese, bip39WordListSpanish, };\nexport var Bip39Error;\n(function (Bip39Error) {\n    Bip39Error[\"invalidEntropyLength\"] = \"BIP39 Error: invalid entropy length. Entropy length must be 16, 20, 24, 28, or 32 bytes.\";\n    Bip39Error[\"invalidMnemonicLength\"] = \"BIP39 Error: invalid mnemonic length. Word count must be 12, 15, 18, 21, or 24.\";\n    Bip39Error[\"invalidWordListLength\"] = \"BIP39 Error: invalid word list length. BIP39 word lists must contain exactly 2048 words.\";\n    Bip39Error[\"invalidChecksum\"] = \"BIP39 Error: invalid checksum for the given mnemonic phrase.\";\n    Bip39Error[\"unknownWord\"] = \"BIP39 Error: unknown word(s). The mnemonic phrase contains one or more words that do not exist in the word list.\";\n})(Bip39Error || (Bip39Error = {}));\n/**\n * Verify that the provided BIP39 word list contains exactly 2048 words.\n *\n * @param wordList - the word list\n */\nexport const isValidBip39WordList = (wordList) => wordList.length === 2048 /* Bip39.validWordListLength */;\n/**\n * Verify that the length of the provided entropy is valid for BIP39: 16, 20,\n * 24, 28, or 32 bytes.\n *\n * @param entropy - the entropy bytes\n */\nexport const isValidBip39EntropyLength = (entropy) => entropy.length >= 16 /* Bip39.minEntropyBytes */ &&\n    entropy.length <= 32 /* Bip39.maxEntropyBytes */ &&\n    entropy.length % 4 /* Bip39.entropyLengthStepSize */ === 0;\n/**\n * Derive BIP39 checksum bits for the given entropy bytes.\n *\n * Note, this method always completes. For a valid result, `entropy` must\n * satisfy {@link isValidBip39EntropyLength}.\n *\n * @param entropy - the entropy bytes\n */\nexport const deriveBip39ChecksumBits = (entropy) => {\n    const ENT = entropy.length * 8 /* Bip39.bitsPerByte */;\n    const CS = ENT / 32 /* Bip39.checksumRatio */;\n    const hash = sha256.hash(entropy);\n    return binToBinString(hash).slice(0, CS);\n};\n/**\n * Decode the provided BIP39 mnemonic phrase using the provided word list.\n * Reverses {@link encodeBip39MnemonicNonStandard}.\n *\n * See {@link decodeBip39Mnemonic} to decode using the English word list.\n *\n * @param mnemonic - the BIP39 mnemonic phrase\n * @param wordList - the word list to use\n */\n// eslint-disable-next-line complexity\nexport const decodeBip39MnemonicNonStandard = (mnemonic, wordList) => {\n    if (!isValidBip39WordList(wordList)) {\n        return formatError(Bip39Error.invalidWordListLength, `Word list length: ${wordList.length}.`);\n    }\n    const words = mnemonic.normalize('NFKD').split(' ');\n    if (words.length % 3 /* Bip39.wordCountStepSize */ !== 0 ||\n        words.length < 12 /* Bip39.minWordCount */ ||\n        words.length > 24 /* Bip39.maxWordCount */) {\n        return formatError(Bip39Error.invalidMnemonicLength, `Word count: ${words.length}.`);\n    }\n    const unknownWords = words.filter((word) => !wordList.includes(word));\n    if (unknownWords.length !== 0) {\n        return formatError(Bip39Error.unknownWord, `Unknown word(s): ${unknownWords.join(', ')}.`);\n    }\n    const binString = words\n        .map((word) => {\n        const index = wordList.indexOf(word);\n        return index.toString(2 /* Bip39.base2 */).padStart(11 /* Bip39.bitsPerWord */, '0');\n    })\n        .join('');\n    const splitIndex = (words.length / 3 /* Bip39.wordCountStepSize */) * 32 /* Bip39.checksumRatio */;\n    const entropyBits = binString.slice(0, splitIndex);\n    const checksumBits = binString.slice(splitIndex);\n    const entropy = binStringToBin(entropyBits);\n    const newChecksum = deriveBip39ChecksumBits(entropy);\n    if (newChecksum !== checksumBits) {\n        return formatError(Bip39Error.invalidChecksum, `Encoded: ${checksumBits}; computed: ${newChecksum}.`);\n    }\n    return entropy;\n};\n/**\n * Decode the provided BIP39 mnemonic phrase using the English word list.\n * Reverses {@link encodeBip39Mnemonic}.\n *\n * See {@link decodeBip39MnemonicNonStandard} for other word lists.\n *\n * @param mnemonic - the BIP39 mnemonic phrase\n */\nexport const decodeBip39Mnemonic = (mnemonic) => decodeBip39MnemonicNonStandard(mnemonic, bip39WordListEnglish);\n/**\n * Encode the provided entropy in a BIP39 mnemonic phrase using a custom word\n * list. Reverses {@link decodeBip39MnemonicNonStandard}.\n *\n * See {@link encodeBip39Mnemonic} to encode using the English word list.\n *\n * If the provided `entropy` and `wordList` each has a valid length, this method\n * will never error.\n *\n * @param entropy - the entropy (length must be 16, 20, 24, 28, or 32 bytes)\n * @param wordList - the word list to use\n */\nexport const encodeBip39MnemonicNonStandard = (entropy, wordList) => {\n    if (!isValidBip39EntropyLength(entropy)) {\n        return formatError(Bip39Error.invalidEntropyLength, `Entropy length: ${entropy.length}.`);\n    }\n    if (!isValidBip39WordList(wordList)) {\n        return formatError(Bip39Error.invalidWordListLength, `Word list length: ${wordList.length}.`);\n    }\n    const entropyBits = binToBinString(entropy);\n    const checksumBits = deriveBip39ChecksumBits(entropy);\n    const bits = entropyBits + checksumBits;\n    const chunks = splitEvery(bits, 11 /* Bip39.bitsPerWord */);\n    const words = chunks.map((binary) => {\n        const index = parseInt(binary, 2);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const word = wordList[index];\n        return word;\n    });\n    /*\n     * Japanese phrases use an ideographic space separator; if the first word is\n     * Japanese, join using `\\u3000`.\n     */\n    const phrase = wordList[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093'\n        ? words.join('\\u3000')\n        : words.join(' ');\n    return { phrase };\n};\n/**\n * Encode the provided entropy in an English BIP39 mnemonic phrase.\n * Reverses {@link decodeBip39Mnemonic}.\n *\n * Even for localized applications, English is the safest choice for BIP39\n * mnemonic phrase encoding. English mnemonic phrases are the most widely used\n * and supported by ecosystem tooling, meaning they can be more reliably error\n * corrected than phrases using other word lists, and they are more likely to be\n * recognized as valuable by humans and generalized automation, e.g.\n * organizational secret scanning and anti-exfiltration software. Note also that\n * specialized exfiltration efforts are unlikely to be thwarted by obscuring\n * mnemonic phrases with localized or custom word lists; instead, consider using\n * a passphrase during seed derivation.\n *\n * If the provided `entropy` is a valid length, this method will never error.\n *\n * To use other word lists, see {@link encodeBip39MnemonicNonStandard}.\n *\n * @param entropy - the entropy (length must be 16, 20, 24, 28, or 32 bytes)\n */\nexport const encodeBip39Mnemonic = (entropy) => encodeBip39MnemonicNonStandard(entropy, bip39WordListEnglish);\n/**\n * Derive a seed from the provided BIP39 mnemonic phrase.\n *\n * Note that by design, **BIP39 seed derivation is one-way**: seeds derived from\n * a mnemonic phrase cannot be used to recover the source phrase. Additionally,\n * BIP39 seed derivation does not perform any validation on the provided\n * mnemonic phrase, **allowing derivation from any string**.\n *\n * For use cases in which a particular mnemonic phrase is expected to be\n * correctly formed (with a valid checksum), first verify that it can be decoded\n * with {@link decodeBip39Mnemonic}.\n *\n * @param mnemonic - the BIP39 mnemonic phrase\n * @param passphrase - an optional passphrase (defaults to `undefined`)\n * @param crypto - an optional object containing an implementation of PBKDF2\n * using HMAC SHA512 (defaults to the internal WASM implementations)\n */\nexport const deriveSeedFromBip39Mnemonic = (mnemonic, { crypto = { pbkdf2HmacSha512: internalPbkdf2HmacSha512 }, passphrase = '', } = {}) => {\n    const mnemonicNormalized = mnemonic.normalize('NFKD');\n    const salt = `mnemonic${passphrase}`;\n    const saltNormalized = salt.normalize('NFKD');\n    const mnemonicBin = utf8ToBin(mnemonicNormalized);\n    const saltBin = utf8ToBin(saltNormalized);\n    return crypto.pbkdf2HmacSha512({\n        derivedKeyLength: 64 /* Bip39.derivedKeyLength */,\n        iterations: 2048 /* Bip39.pbkdf2Iterations */,\n        password: mnemonicBin,\n        salt: saltBin,\n    });\n};\n/**\n * Derive an {@link HdPrivateNode} from the provided BIP39 mnemonic phrase\n * following the BIP32 and BIP39 specifications.\n *\n * Note that by design, **BIP39 seed derivation is one-way**: seeds derived from\n * a mnemonic phrase cannot be used to recover the source phrase. Additionally,\n * BIP39 seed derivation does not perform any validation on the provided\n * mnemonic phrase, **allowing derivation from any string**.\n *\n * For use cases in which a particular mnemonic phrase is expected to be\n * correctly formed (with a valid checksum), first verify that it can be decoded\n * with {@link decodeBip39Mnemonic}.\n *\n * @param mnemonic - the BIP39 mnemonic phrase\n * @param passphrase - an optional passphrase (defaults to `undefined`)\n * @param crypto - an optional object containing an implementation of SHA-512\n * and PBKDF2 using HMAC SHA-512 (defaults to the internal WASM implementations)\n * @param hmacSha512Key - the HMAC SHA-512 key to use (defaults the HMAC SHA-512\n * key used by BIP32, `utf8ToBin('Bitcoin seed')`\n */\nexport const deriveHdPrivateNodeFromBip39Mnemonic = (mnemonic, { crypto = {\n    pbkdf2HmacSha512: internalPbkdf2HmacSha512,\n    sha512: internalSha512,\n}, hmacSha512Key, passphrase, } = {}) => deriveHdPrivateNodeFromSeed(deriveSeedFromBip39Mnemonic(mnemonic, { crypto, passphrase }), { crypto, hmacSha512Key });\n/**\n * Generate a new, cryptographically secure, BIP39 mnemonic phrase using a\n * localized or custom word list.\n *\n * See {@link generateBip39Mnemonic} to generate a standard, 12-word English\n * mnemonic phrase.\n *\n * See {@link encodeBip39Mnemonic} to encode existing entropy as a BIP39\n * mnemonic phrase.\n *\n * **Usage**\n * ```ts\n * import {\n *   assertSuccess,\n *   bip39WordListSpanish,\n *   generateBip39Mnemonic\n * } from '@bitauth/libauth';\n *\n * const { phrase } = assertSuccess(generateBip39Mnemonic(bip39WordListSpanish, 32));\n * ```\n *\n * @param wordList - a 2048-word array to use as the BIP39 word list\n * @param entropyLength - the entropy length to generate â€“ 16, 20, 24, 28, or 32\n * bytes (defaults to 16).\n */\nexport const generateBip39MnemonicNonStandard = (wordList, entropyLength = 16 /* Bip39.minEntropyBytes */, { generateRandomBytes = internalGenerateRandomBytes, } = {}) => {\n    if (!isValidBip39WordList(wordList)) {\n        return formatError(Bip39Error.invalidWordListLength, `Word list length: ${wordList.length}.`);\n    }\n    const entropy = generateRandomBytes(entropyLength);\n    if (!isValidBip39EntropyLength(entropy)) {\n        return formatError(Bip39Error.invalidEntropyLength, `Entropy length: ${entropy.length}.`);\n    }\n    return encodeBip39MnemonicNonStandard(entropy, wordList);\n};\n/**\n * Generate a new, cryptographically secure, 12-word English BIP39\n * mnemonic phrase.\n *\n * See {@link generateBip39MnemonicNonStandard} to use a localized or custom\n * word list.\n *\n * See {@link encodeBip39Mnemonic} to encode existing entropy as a BIP39\n * mnemonic phrase.\n *\n * **Usage**\n * ```ts\n * import { generateBip39Mnemonic } from '@bitauth/libauth';\n *\n * const phrase = generateBip39Mnemonic();\n * ```\n */\nexport const generateBip39Mnemonic = () => generateBip39MnemonicNonStandard(bip39WordListEnglish, 16 /* Bip39.minEntropyBytes */).phrase;\n// cSpell:ignore aban\n/**\n * TODO: not yet implemented; see also: {@link attemptCashAddressFormatErrorCorrection}\n *\n * Attempt to automatically correct any typographical errors in a BIP39 mnemonic\n * phrase, returning correction information for the closest matching valid\n * mnemonic phrase.\n *\n * Note that by design, BIP39 allows seed derivation from any NFKD-normalized\n * string, including phrases containing an incorrect or unrecognized checksum.\n *\n * **Indiscriminate use of this function during BIP39 mnemonic phrase import\n * would prevent the use of seeds derived from such nonstandard phrases.**\n *\n * Instead, this function should be used to offer an end user the best possible\n * correction for the provided mnemonic phrase, e.g.:\n *\n * ```\n * Warning: the BIP39 mnemonic phrase you entered appears to have typographical\n * errors. The phrase could be corrected to:\n *\n * [Render the corrected phrase, emphasizing all correction ranges.]\n *\n * Correction description: [render Bip39MnemonicCorrection.description]\n *\n * Would you like to use this corrected phrase?\n *\n * [Button: \"Use corrected phrase\"] [Button: \"Use phrase with errors\"]\n * ```\n *\n * This function attempts the following corrections, returning a\n * {@link Bip39MnemonicCorrection} as soon as a BIP39 mnemonic phrase with a\n * valid checksum is produced:\n *\n * - Trim whitespace from the beginning and end of the phrase\n * - Convert the phrase to lowercase characters\n * - Identify the best candidate word list from `possibleWordLists` with which\n * to correct errors by counting exact prefix matches, e.g. `aban` is a prefix\n * match for both English and French. If two word lists share the same number of\n * matches, the earlier index in `possibleWordLists` is prioritized. (Note that\n * `100` words are shared between the French and English word lists, and `1275`\n * words are shared between the Chinese Traditional and Chinese Simplified word\n * lists. Because this function is intended to correct standard BIP39 mnemonic\n * phrases, we assume that all correct words are found in a single word list.\n * - Deduplicate spaces between words, ensuring the expected space separator is\n * used (for the Japanese word list, an ideographic space separator: `\\u3000`).\n * - Attempt to verify the checksum for all valid subsets of the phrase by\n * slicing the phrase at 24, 21, 18, 15, and 12 words. In these cases, the\n * additional words may have been entered in error, or they may be part of a\n * passphrase recorded in the same location as the phrase. The returned\n * {@link Bip39MnemonicCorrection.description} indicates that the user should\n * review the source material to see if the deleted word(s) are a passphrase.\n * - For every word where an exact match is not found, develop a ranked list of\n * possible matches:\n *   - Attempt to extend the word by finding all word(s) in the selected word\n * list with a matching prefix (i.e. only the first few characters of the\n * correct word were included in the incorrect phrase). If multiple prefix\n * matches are found, rank them in word list order (in later steps, all of these\n * matches are considered to have a similarity of `1`).\n *   - If no prefix matches were found, compute the Jaro similarity between\n * the unknown word and every word in the candidate word list, adding all\n * words to the ranked list in descending-similarity, then word list order.\n * - Attempt to find a corrected phrase with the minimum possible correction by\n * validating the checksum for each candidate combination in ranked order:\n *   - Beginning with a similarity target of 1, create candidate combinations\n * by replacing unknown words with all possible matches having a similarity\n * equal to or greater than the target.\n *   - If any unknown words have no matches meeting the similarity target, lower\n * the similarity target to the value of the next-most-similar match for that\n * word, using only that match in this correction iteration.\n *   - If no phrases with a valid checksum are found, repeat these steps with\n * the lowered similarity target, excluding previously-tried combinations.\n *\n * If no plausible matches are found, or if the provided phrase has an invalid\n * word count (after attempting to correct whitespace errors), an error (string)\n * is returned.\n *\n * Note, this method does not attempt to correct mnemonic phrases with an\n * incorrect word count; in these cases, the user should be asked to either\n * identify and provide the missing words or use a dedicated brute-forcing tool\n * (if words have been lost).\n *\n * @param mnemonic - the BIP39 mnemonic phrase to error-correct\n * @param possibleWordLists - an array of BIP39 word lists that may be in use by\n * the BIP39 mnemonic\n */\nexport const attemptBip39MnemonicErrorCorrection = /* c8 ignore next */ (\n/* c8 ignore next 3 */\n_mnemonic, _possibleWordLists) => 'TODO: not yet implemented';\n// export enum Bip39MnemonicCorrectionError {}\n//# sourceMappingURL=bip39.js.map","/**\n * A standard single-factor wallet template that uses\n * Pay-to-Public-Key-Hash (P2PKH), the most common authentication scheme in use\n * on the network.\n *\n * This P2PKH template uses BCH Schnorr signatures, reducing the size of\n * transactions.\n *\n * Note, this wallet template uses only a single `Key`. For HD key\n * support, see {@link walletTemplateP2pkhHd}.\n */\nexport const walletTemplateP2pkhNonHd = {\n    $schema: 'https://libauth.org/schemas/wallet-template-v0.schema.json',\n    description: 'A standard single-factor wallet template that uses Pay-to-Public-Key-Hash (P2PKH), the most common authentication scheme in use on the network.\\n\\nThis P2PKH template uses BCH Schnorr signatures, reducing the size of transactions.',\n    entities: {\n        owner: {\n            description: 'The individual who can spend from this wallet.',\n            name: 'Owner',\n            scripts: ['lock', 'unlock'],\n            variables: {\n                key: {\n                    description: 'The private key that controls this wallet.',\n                    name: 'Key',\n                    type: 'Key',\n                },\n            },\n        },\n    },\n    name: 'Single Signature (P2PKH)',\n    scripts: {\n        lock: {\n            lockingType: 'standard',\n            name: 'P2PKH Lock',\n            script: 'OP_DUP\\nOP_HASH160 <$(<key.public_key> OP_HASH160\\n)> OP_EQUALVERIFY\\nOP_CHECKSIG',\n        },\n        unlock: {\n            name: 'Unlock',\n            script: '<key.schnorr_signature.all_outputs>\\n<key.public_key>',\n            unlocks: 'lock',\n        },\n    },\n    supported: ['BCH_2020_05', 'BCH_2021_05', 'BCH_2022_05'],\n    version: 0,\n};\n/**\n * A standard single-factor wallet template that uses\n * Pay-to-Public-Key-Hash (P2PKH), the most common authentication scheme in use\n * on the network.\n *\n * This P2PKH template uses BCH Schnorr signatures, reducing the size of\n * transactions.\n *\n * Because the template uses a Hierarchical Deterministic (HD) key, it also\n * supports watch-only clients.\n */\nexport const walletTemplateP2pkh = {\n    $schema: 'https://libauth.org/schemas/wallet-template-v0.schema.json',\n    description: 'A standard single-factor wallet template that uses Pay-to-Public-Key-Hash (P2PKH), the most common authentication scheme in use on the network.\\n\\nThis P2PKH template uses BCH Schnorr signatures, reducing the size of transactions. Because the template uses a Hierarchical Deterministic (HD) key, it also supports watch-only clients.',\n    entities: {\n        owner: {\n            description: 'The individual who can spend from this wallet.',\n            name: 'Owner',\n            scripts: ['lock', 'unlock'],\n            variables: {\n                key: {\n                    description: 'The private key that controls this wallet.',\n                    name: 'Key',\n                    type: 'HdKey',\n                },\n            },\n        },\n    },\n    name: 'Single Signature (P2PKH)',\n    scripts: {\n        lock: {\n            lockingType: 'standard',\n            name: 'P2PKH Lock',\n            script: 'OP_DUP\\nOP_HASH160 <$(<key.public_key> OP_HASH160\\n)> OP_EQUALVERIFY\\nOP_CHECKSIG',\n        },\n        unlock: {\n            name: 'Unlock',\n            script: '<key.schnorr_signature.all_outputs>\\n<key.public_key>',\n            unlocks: 'lock',\n        },\n    },\n    supported: ['BCH_2020_05', 'BCH_2021_05', 'BCH_2022_05'],\n    version: 0,\n};\n//# sourceMappingURL=p2pkh.js.map","import { lockingBytecodeToCashAddress } from '../address/address.js';\nimport { formatError } from '../format/format.js';\nimport { stringifyErrors } from '../language/language.js';\nimport { walletTemplateToCompilerBCH } from './compiler-bch/compiler-bch.js';\nimport { walletTemplateP2pkh, walletTemplateP2pkhNonHd, } from './standard/standard.js';\nexport var P2pkhUtilityError;\n(function (P2pkhUtilityError) {\n    P2pkhUtilityError[\"hdPrivateKeyToP2pkhLockingBytecodeCompilation\"] = \"P2PKH utility error: could not derive P2PKH locking bytecode from the provided HD private key.\";\n    P2pkhUtilityError[\"hdPublicKeyToP2pkhLockingBytecodeCompilation\"] = \"P2PKH utility error: could not derive P2PKH locking bytecode from the provided HD public key.\";\n    P2pkhUtilityError[\"privateKeyToP2pkhLockingBytecodeCompilation\"] = \"P2PKH utility error: could not derive P2PKH locking bytecode from the provided private key.\";\n    P2pkhUtilityError[\"publicKeyToP2pkhLockingBytecodeCompilation\"] = \"P2PKH utility error: could not derive P2PKH locking bytecode from the provided public key.\";\n})(P2pkhUtilityError || (P2pkhUtilityError = {}));\n/**\n * Derive the P2PKH locking bytecode of the provided private key.\n *\n * Note that this function defaults to throwing an error if provided with an\n * invalid private key. To handle errors in a type-safe way, set `throwErrors`\n * to `false`.\n *\n * To derive the resulting CashAddress, use\n * {@link privateKeyToP2pkhCashAddress}. For HD private keys, use\n * {@link hdPrivateKeyToP2pkhLockingBytecode}. For the public key equivalent,\n * see {@link publicKeyToP2pkhLockingBytecode}.\n */\nexport const privateKeyToP2pkhLockingBytecode = ({ privateKey, throwErrors = true, }) => {\n    const compiler = walletTemplateToCompilerBCH(walletTemplateP2pkhNonHd);\n    const lockingBytecode = compiler.generateBytecode({\n        data: { keys: { privateKeys: { key: privateKey } } },\n        scriptId: 'lock',\n    });\n    if (!lockingBytecode.success) {\n        return formatError(P2pkhUtilityError.privateKeyToP2pkhLockingBytecodeCompilation, stringifyErrors(lockingBytecode.errors), throwErrors);\n    }\n    return lockingBytecode.bytecode;\n};\n/**\n * Derive the P2PKH locking bytecode of the provided public key.\n *\n * Note that this function defaults to throwing an error if provided with an\n * invalid public key. To handle errors in a type-safe way, set `throwErrors`\n * to `false`.\n *\n * To derive the resulting CashAddress, use {@link publicKeyToP2pkhCashAddress}.\n * For HD public keys, use {@link hdPublicKeyToP2pkhLockingBytecode}. For the\n * private key equivalent, see {@link privateKeyToP2pkhLockingBytecode}.\n */\nexport const publicKeyToP2pkhLockingBytecode = ({ publicKey, throwErrors = true, }) => {\n    const compiler = walletTemplateToCompilerBCH(walletTemplateP2pkhNonHd);\n    const lockingBytecode = compiler.generateBytecode({\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        data: { bytecode: { 'key.public_key': publicKey } },\n        scriptId: 'lock',\n    });\n    if (!lockingBytecode.success) {\n        return formatError(P2pkhUtilityError.publicKeyToP2pkhLockingBytecodeCompilation, stringifyErrors(lockingBytecode.errors), throwErrors);\n    }\n    return lockingBytecode.bytecode;\n};\n/**\n * Derive the P2PKH locking bytecode at the provided path and address index of\n * the provided HD private key.\n *\n * Note that this function defaults to throwing an error if provided with an\n * invalid HD private key or derivation path. To handle errors in a type-safe\n * way, set `throwErrors` to `false`.\n *\n * To derive the resulting CashAddress, use\n * {@link hdPrivateKeyToP2pkhCashAddress}. For non-HD private keys, use\n * {@link privateKeyToP2pkhLockingBytecode}. For the HD public key equivalent,\n * see {@link hdPublicKeyToP2pkhLockingBytecode}.\n */\nexport const hdPrivateKeyToP2pkhLockingBytecode = ({ addressIndex, hdPrivateKey, privateDerivationPath = 'i', throwErrors = true, }) => {\n    const template = structuredClone(walletTemplateP2pkh);\n    // eslint-disable-next-line functional/no-expression-statements, functional/immutable-data, @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n    template.entities.owner.variables.key.privateDerivationPath =\n        privateDerivationPath;\n    const compiler = walletTemplateToCompilerBCH(template);\n    const lockingBytecode = compiler.generateBytecode({\n        data: { hdKeys: { addressIndex, hdPrivateKeys: { owner: hdPrivateKey } } },\n        scriptId: 'lock',\n    });\n    if (!lockingBytecode.success) {\n        return formatError(P2pkhUtilityError.hdPrivateKeyToP2pkhLockingBytecodeCompilation, stringifyErrors(lockingBytecode.errors), throwErrors);\n    }\n    return lockingBytecode.bytecode;\n};\n/**\n * Derive the P2PKH locking bytecode at the provided index of the provided HD\n * public key.\n *\n * Note that this function defaults to throwing an error if provided with an\n * invalid HD public key. To handle errors in a type-safe way, set `throwErrors`\n * to `false`.\n *\n * To derive the resulting CashAddress, use\n * {@link hdPublicKeyToP2pkhCashAddress}. For non-HD public keys, use\n * {@link publicKeyToP2pkhLockingBytecode}. For the HD private key equivalent,\n * see {@link hdPrivateKeyToP2pkhLockingBytecode}.\n */\nexport const hdPublicKeyToP2pkhLockingBytecode = ({ addressIndex, hdPublicKey, hdPublicKeyDerivationPath = '', throwErrors = true, publicDerivationPath = 'i', }) => {\n    const template = structuredClone(walletTemplateP2pkh);\n    /* eslint-disable functional/no-expression-statements, functional/immutable-data, @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access */\n    template.entities.owner.variables.key.publicDerivationPath =\n        publicDerivationPath;\n    template.entities.owner.variables.key.hdPublicKeyDerivationPath =\n        hdPublicKeyDerivationPath;\n    template.entities.owner.variables.key.privateDerivationPath =\n        hdPublicKeyDerivationPath === ''\n            ? publicDerivationPath\n            : `${hdPublicKeyDerivationPath}/${publicDerivationPath}`;\n    /* eslint-enable functional/no-expression-statements, functional/immutable-data, @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access */\n    const compiler = walletTemplateToCompilerBCH(template);\n    const lockingBytecode = compiler.generateBytecode({\n        data: { hdKeys: { addressIndex, hdPublicKeys: { owner: hdPublicKey } } },\n        scriptId: 'lock',\n    });\n    if (!lockingBytecode.success) {\n        return formatError(P2pkhUtilityError.hdPublicKeyToP2pkhLockingBytecodeCompilation, stringifyErrors(lockingBytecode.errors), throwErrors);\n    }\n    return lockingBytecode.bytecode;\n};\n/**\n * Derive the P2PKH address of the provided private key.\n *\n * Note that this function defaults to throwing an error if provided with an\n * invalid private key. To handle errors in a type-safe way, set `throwErrors`\n * to `false`.\n *\n * To derive only the locking bytecode, use\n * {@link privateKeyToP2pkhLockingBytecode}. For HD private keys, use\n * {@link hdPrivateKeyToP2pkhCashAddress}. For the public key equivalent,\n * see {@link publicKeyToP2pkhCashAddress}.\n */\nexport const privateKeyToP2pkhCashAddress = ({ privateKey, prefix = 'bitcoincash', throwErrors = true, tokenSupport = false, }) => {\n    const bytecode = privateKeyToP2pkhLockingBytecode({\n        privateKey,\n        throwErrors,\n    });\n    if (typeof bytecode === 'string') {\n        return formatError(bytecode, undefined, throwErrors);\n    }\n    return lockingBytecodeToCashAddress({\n        bytecode,\n        prefix,\n        tokenSupport,\n    });\n};\n/**\n * Derive the P2PKH address of the provided public key.\n *\n * Note that this function defaults to throwing an error if provided with an\n * invalid public key. To handle errors in a type-safe way, set `throwErrors`\n * to `false`.\n *\n * To derive only the locking bytecode, use\n * {@link publicKeyToP2pkhLockingBytecode}. For HD public keys, use\n * {@link hdPublicKeyToP2pkhCashAddress}. For the private key equivalent,\n * see {@link privateKeyToP2pkhCashAddress}.\n */\nexport const publicKeyToP2pkhCashAddress = ({ publicKey, prefix = 'bitcoincash', throwErrors = true, tokenSupport = false, }) => {\n    const bytecode = publicKeyToP2pkhLockingBytecode({\n        publicKey,\n        throwErrors,\n    });\n    if (typeof bytecode === 'string') {\n        return formatError(bytecode, undefined, throwErrors);\n    }\n    return lockingBytecodeToCashAddress({\n        bytecode,\n        prefix,\n        tokenSupport,\n    });\n};\n/**\n * Derive the P2PKH address at the provided index of the provided HD\n * private key.\n *\n * Note that this function defaults to throwing an error if provided with an\n * invalid HD private key or derivation path. To handle errors in a type-safe\n * way, set `throwErrors` to `false`.\n *\n * To derive only the locking bytecode, use\n * {@link hdPrivateKeyToP2pkhLockingBytecode}. For non-HD private keys, use\n * {@link privateKeyToP2pkhCashAddress}. For the HD public key equivalent,\n * see {@link hdPublicKeyToP2pkhCashAddress}.\n */\nexport const hdPrivateKeyToP2pkhCashAddress = ({ addressIndex, hdPrivateKey, prefix = 'bitcoincash', privateDerivationPath = 'i', throwErrors = true, tokenSupport = false, }) => {\n    const bytecode = hdPrivateKeyToP2pkhLockingBytecode({\n        addressIndex,\n        hdPrivateKey,\n        privateDerivationPath,\n        throwErrors,\n    });\n    if (typeof bytecode === 'string') {\n        return formatError(bytecode, undefined, throwErrors);\n    }\n    return lockingBytecodeToCashAddress({\n        bytecode,\n        prefix,\n        tokenSupport,\n    });\n};\n/**\n * Derive the P2PKH address at the provided index of the provided HD\n * public key.\n *\n * Note that this function defaults to throwing an error if provided with an\n * invalid HD public key. To handle errors in a type-safe way, set `throwErrors`\n * to `false`.\n *\n * To derive only the locking bytecode, use\n * {@link hdPublicKeyToP2pkhLockingBytecode}. For non-HD public keys, use\n * {@link publicKeyToP2pkhCashAddress}. For the HD private key equivalent,\n * see {@link hdPrivateKeyToP2pkhCashAddress}.\n */\nexport const hdPublicKeyToP2pkhCashAddress = ({ addressIndex, hdPublicKey, hdPublicKeyDerivationPath = '', prefix = 'bitcoincash', publicDerivationPath = 'i', throwErrors = true, tokenSupport = false, }) => {\n    const bytecode = hdPublicKeyToP2pkhLockingBytecode({\n        addressIndex,\n        hdPublicKey,\n        hdPublicKeyDerivationPath,\n        publicDerivationPath,\n        throwErrors,\n    });\n    if (typeof bytecode === 'string') {\n        return formatError(bytecode, undefined, throwErrors);\n    }\n    return lockingBytecodeToCashAddress({\n        bytecode,\n        prefix,\n        tokenSupport,\n    });\n};\n//# sourceMappingURL=p2pkh-utils.js.map","import { \n//binToHex,\nderiveSeedFromBip39Mnemonic, deriveHdPrivateNodeFromSeed, deriveHdPath, encodeHdPrivateKey,\n//encodeHdPublicKey,\n// deriveHdPublicNode,\n// hash160,\n// deriveHdPrivateNodeChild\n } from \"@bitauth/libauth\";\nimport { checkForEmptySeed } from \"./util.js\";\nexport function getHdPrivateKey(mnemonic, path, isTestnet = false) {\n    if (mnemonic.length == 0)\n        throw Error(\"refusing to create wallet from empty mnemonic\");\n    const seed = deriveSeedFromBip39Mnemonic(mnemonic);\n    checkForEmptySeed(seed);\n    const network = isTestnet ? \"testnet\" : \"mainnet\";\n    let hdNode = deriveHdPrivateNodeFromSeed(seed);\n    if (typeof hdNode == \"string\")\n        throw Error(hdNode);\n    const zerothChildParent = deriveHdPath(hdNode, path);\n    let result = encodeHdPrivateKey({\n        network: network,\n        node: zerothChildParent\n    });\n    if (typeof result == \"string\")\n        throw Error(result);\n    return result.hdPrivateKey;\n}\n//# sourceMappingURL=wallet.js.map"],"names":["Pbkdf2Error","instantiatePbkdf2Function","hmacFunction","hmacByteLength","parameters","password","salt","iterations","derivedKeyLength","formatError","iterationCountByteLength","derivedKey","block","writePosition","length","i","iterationUint32BEEncoded","numberToBinUint32BE","accumulatedMac","intermediateMac","j","k","truncatedResult","hmacSha512ByteLength","pbkdf2HmacSha512","sha512Hmac","hmacSha512","Bip39Error","deriveSeedFromBip39Mnemonic","mnemonic","crypto","internalPbkdf2HmacSha512","passphrase","mnemonicNormalized","saltNormalized","mnemonicBin","utf8ToBin","saltBin","walletTemplateP2pkh","P2pkhUtilityError","hdPrivateKeyToP2pkhLockingBytecode","addressIndex","hdPrivateKey","privateDerivationPath","throwErrors","template","lockingBytecode","walletTemplateToCompilerBCH","stringifyErrors","getHdPrivateKey","path","isTestnet","seed","checkForEmptySeed","network","hdNode","deriveHdPrivateNodeFromSeed","zerothChildParent","deriveHdPath","result","encodeHdPrivateKey"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}