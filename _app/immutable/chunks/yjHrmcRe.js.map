{"version":3,"file":"yjHrmcRe.js","sources":["../../../../../../../../node_modules/.pnpm/@bitauth+libauth@3.1.0-next.8/node_modules/@bitauth/libauth/build/lib/format/log.js"],"sourcesContent":["import { binToHex } from './hex.js';\nconst defaultStringifySpacing = 2;\n/**\n * A safe method to `JSON.stringify` a value, useful for debugging and logging\n * purposes.\n *\n * @remarks\n * Without modifications, `JSON.stringify` has several shortcomings in\n * debugging and logging usage:\n * - throws when serializing anything containing a `bigint`\n * - `Uint8Array`s are often encoded in base 10 with newlines between each\n *   index item\n * - `functions` and `symbols` are not clearly marked\n *\n * This method is more helpful in these cases:\n * - `bigint`: `0n` → `<bigint: 0n>`\n * - `Uint8Array`: `Uint8Array.of(0,0)` → `<Uint8Array: 0x0000>`\n * - `function`: `(x) => x * 2` → `<function: (x) => x * 2>`\n * - `symbol`: `Symbol(A)` → `<symbol: Symbol(A)>`\n *\n * @param value - the data to stringify\n * @param spacing - the number of spaces to use in\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const stringify = (value, spacing = defaultStringifySpacing) => JSON.stringify(value, \n// eslint-disable-next-line complexity\n(_, item) => {\n    const type = typeof item;\n    const name = typeof item === 'object' && item !== null\n        ? item.constructor.name\n        : type;\n    switch (name) {\n        case 'Uint8Array':\n            return `<Uint8Array: 0x${binToHex(item)}>`;\n        case 'bigint':\n            return `<bigint: ${item.toString()}n>`;\n        case 'function':\n        case 'symbol':\n            // eslint-disable-next-line @typescript-eslint/ban-types\n            return `<${name}: ${item.toString()}>`;\n        default:\n            return item;\n    }\n}, spacing);\n/**\n * Given a value, recursively sort the keys of all objects it references\n * (without sorting arrays).\n *\n * @param objectOrArray - the object or array in which to sort object keys\n */\nexport const sortObjectKeys = (objectOrArray) => {\n    if (Array.isArray(objectOrArray)) {\n        return objectOrArray.map(sortObjectKeys);\n    }\n    if (typeof objectOrArray !== 'object' ||\n        objectOrArray === null ||\n        objectOrArray.constructor.name !== 'Object') {\n        return objectOrArray;\n    }\n    // eslint-disable-next-line functional/immutable-data\n    const keys = Object.keys(objectOrArray).sort((a, b) => a.localeCompare(b, 'en'));\n    return keys.reduce((all, key) => ({\n        ...all,\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        [key]: sortObjectKeys(objectOrArray[key]),\n    }), {});\n};\nconst uint8ArrayRegex = /\"<Uint8Array: 0x(?<hex>[0-9a-f]*)>\"/gu;\nconst bigIntRegex = /\"<bigint: (?<bigint>[0-9]*)n>\"/gu;\n/**\n * An alternative to {@link stringify} that produces valid JavaScript for use\n * as a test vector in this library. `Uint8Array`s are constructed using\n * {@link hexToBin} and `bigint` values use the `BigInt` constructor. If\n * `alphabetize` is `true`, all objects will be sorted in the output.\n *\n * Note, this assumes all strings that match the expected regular expressions\n * are values of type `Uint8Array` and `bigint` respectively. String values\n * that otherwise happen to match these regular expressions will be converted\n * incorrectly.\n *\n * @param value - the value to stringify\n * @param alphabetize - whether or not to alphabetize object keys, defaults\n * to true\n */\nexport const stringifyTestVector = (\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvalue, alphabetize = true) => {\n    const stringified = alphabetize\n        ? stringify(sortObjectKeys(value))\n        : stringify(value);\n    return stringified\n        .replace(uint8ArrayRegex, \"hexToBin('$1')\")\n        .replace(bigIntRegex, '$1n');\n};\n/**\n * Elide words and hex strings in the given `text` at `maxLength`. Max length\n * defaults to `148`, the maximum hex-encoded length (with `0x` prefix) of most\n * ECDSA signatures.\n *\n * Hex strings include a count of total bytes, e.g.\n * `0x01 … (512 total bytes) … 10101`. (Note that the surrounding spacing\n * decreases the incidences of line breaks within the message.)\n *\n * @param text - the text to process\n * @param maxLength - the maximum length of each word in the resulting text\n * @returns\n */\nexport const elideWordsAndHexAtLength = (text, \n// eslint-disable-next-line @typescript-eslint/no-magic-numbers\nmaxLength = 148) => text.replace(/\\S+/gu, (w) => {\n    if (w.length < maxLength)\n        return w;\n    const prefix = '0x'.length;\n    const byte = 2;\n    const match = /^(?:<)?(?<hex>0x[0-9A-Fa-f]+)(?:>)?$/gu.exec(w);\n    const middle = match\n        ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            ` … (${(match.groups['hex'].length - prefix) / byte} total bytes) … `\n        : '…';\n    const keep = maxLength - middle.length;\n    const half = 2;\n    const front = Math.floor(keep / half);\n    const back = keep - front;\n    return `${w.slice(0, front)}${middle}${w.slice(w.length - back)}`;\n});\n//# sourceMappingURL=log.js.map"],"names":["defaultStringifySpacing","stringify","value","spacing","_","item","name","binToHex"],"mappings":"kCACA,MAAMA,EAA0B,EAuBnBC,EAAY,CAACC,EAAOC,EAAUH,IAA4B,KAAK,UAAUE,EAEtF,CAACE,EAAGC,IAAS,CAET,MAAMC,EAAO,OAAOD,GAAS,UAAYA,IAAS,KAC5CA,EAAK,YAAY,KAFV,OAAOA,EAIpB,OAAQC,EAAI,CACR,IAAK,aACD,MAAO,kBAAkBC,EAASF,CAAI,CAAC,IAC3C,IAAK,SACD,MAAO,YAAYA,EAAK,SAAQ,CAAE,KACtC,IAAK,WACL,IAAK,SAED,MAAO,IAAIC,CAAI,KAAKD,EAAK,SAAU,CAAA,IACvC,QACI,OAAOA,CACnB,CACA,EAAGF,CAAO","x_google_ignoreList":[0]}