import{w as a,f as r,s as l,l as p}from"./0o8OGYDl.js";const d={$schema:"https://libauth.org/schemas/wallet-template-v0.schema.json",description:`A standard single-factor wallet template that uses Pay-to-Public-Key-Hash (P2PKH), the most common authentication scheme in use on the network.

This P2PKH template uses BCH Schnorr signatures, reducing the size of transactions.`,entities:{owner:{description:"The individual who can spend from this wallet.",name:"Owner",scripts:["lock","unlock"],variables:{key:{description:"The private key that controls this wallet.",name:"Key",type:"Key"}}}},name:"Single Signature (P2PKH)",scripts:{lock:{lockingType:"standard",name:"P2PKH Lock",script:`OP_DUP
OP_HASH160 <$(<key.public_key> OP_HASH160
)> OP_EQUALVERIFY
OP_CHECKSIG`},unlock:{name:"Unlock",script:`<key.schnorr_signature.all_outputs>
<key.public_key>`,unlocks:"lock"}},supported:["BCH_2020_05","BCH_2021_05","BCH_2022_05","BCH_2023_05","BCH_2024_05","BCH_2025_05","BCH_2026_05","BCH_SPEC"]},u={$schema:"https://libauth.org/schemas/wallet-template-v0.schema.json",description:`A standard single-factor wallet template that uses Pay-to-Public-Key-Hash (P2PKH), the most common authentication scheme in use on the network.

This P2PKH template uses BCH Schnorr signatures, reducing the size of transactions. Because the template uses a Hierarchical Deterministic (HD) key, it also supports watch-only clients.`,entities:{owner:{description:"The individual who can spend from this wallet.",name:"Owner",scripts:["lock","unlock"],variables:{key:{description:"The private key that controls this wallet.",name:"Key",type:"HdKey"}}}},name:"Single Signature (P2PKH)",scripts:{lock:{lockingType:"standard",name:"P2PKH Lock",script:`OP_DUP
OP_HASH160 <$(<key.public_key> OP_HASH160
)> OP_EQUALVERIFY
OP_CHECKSIG`},unlock:{name:"Unlock",script:`<key.schnorr_signature.all_outputs>
<key.public_key>`,unlocks:"lock"}},supported:["BCH_2020_05","BCH_2021_05","BCH_2022_05","BCH_2023_05","BCH_2024_05","BCH_2025_05","BCH_2026_05","BCH_SPEC"]};var c;(function(e){e.hdPrivateKeyToP2pkhLockingBytecodeCompilation="P2PKH utility error: could not derive P2PKH locking bytecode from the provided HD private key.",e.hdPublicKeyToP2pkhLockingBytecodeCompilation="P2PKH utility error: could not derive P2PKH locking bytecode from the provided HD public key.",e.privateKeyToP2pkhLockingBytecodeCompilation="P2PKH utility error: could not derive P2PKH locking bytecode from the provided private key.",e.publicKeyToP2pkhLockingBytecodeCompilation="P2PKH utility error: could not derive P2PKH locking bytecode from the provided public key."})(c||(c={}));const y=({publicKey:e,throwErrors:i=!0})=>{const t=a(d).generateBytecode({data:{bytecode:{"key.public_key":e}},scriptId:"lock"});return t.success?t.bytecode:r(c.publicKeyToP2pkhLockingBytecodeCompilation,l(t.errors),i)},P=({addressIndex:e,hdPrivateKey:i,privateDerivationPath:n="i",throwErrors:t=!0})=>{const o=structuredClone(u);o.entities.owner.variables.key.privateDerivationPath=n;const s=a(o).generateBytecode({data:{hdKeys:{addressIndex:e,hdPrivateKeys:{owner:i}}},scriptId:"lock"});return s.success?s.bytecode:r(c.hdPrivateKeyToP2pkhLockingBytecodeCompilation,l(s.errors),t)},m=({publicKey:e,prefix:i="bitcoincash",throwErrors:n=!0,tokenSupport:t=!1})=>{const o=y({publicKey:e,throwErrors:n});return typeof o=="string"?r(o,void 0,n):p({bytecode:o,prefix:i,tokenSupport:t})};export{P as h,m as p,d as w};
//# sourceMappingURL=CHgWMm4e.js.map
