import{$ as b,M as $,a as r,b as w,p as g,c as E}from"./CcPnn9Ii.js";function p(s,e,t,i){Object.defineProperty(s,e,{get:t,set:i,enumerable:!0,configurable:!0})}class d{static buildRequestObject(e,t,i){return JSON.stringify({method:e,params:t,id:i})}static get versionRegexp(){return/^\d+(\.\d+)+$/}static get statementDelimiter(){return`
`}}var m={};p(m,"isVersionRejected",()=>v);p(m,"isVersionNegotiated",()=>T);const v=function(s){return"error"in s},T=function(s){return"software"in s&&"protocol"in s},N=function(s){return"id"in s&&"error"in s},C=function(s){return!("id"in s)&&"method"in s};var I={};p(I,"ConnectionStatus",()=>o);var o;(function(s){s[s.DISCONNECTED=0]="DISCONNECTED",s[s.CONNECTED=1]="CONNECTED",s[s.DISCONNECTING=2]="DISCONNECTING",s[s.CONNECTING=3]="CONNECTING",s[s.RECONNECTING=4]="RECONNECTING"})(o||(o={}));class y extends b{constructor(e,t,i,n){if(super(),this.application=e,this.version=t,this.socketOrHostname=i,this.options=n,this.status=o.DISCONNECTED,this.verifications=[],this.messageBuffer="",!d.versionRegexp.test(t))throw new Error(`Provided version string (${t}) is not a valid protocol version number.`);typeof i=="string"?this.socket=new w(i):this.socket=i,this.socket.on("connected",this.onSocketConnect.bind(this)),this.socket.on("disconnected",this.onSocketDisconnect.bind(this)),this.socket.on("data",this.parseMessageChunk.bind(this)),typeof document<"u"&&document.addEventListener("visibilitychange",this.handleVisibilityChange.bind(this)),typeof window<"u"&&(window.addEventListener("online",this.handleNetworkChange.bind(this)),window.addEventListener("offline",this.handleNetworkChange.bind(this)))}get hostIdentifier(){return this.socket.hostIdentifier}get encrypted(){return this.socket.encrypted}parseMessageChunk(e){for(this.lastReceivedTimestamp=Date.now(),this.emit("received"),this.verifications.forEach(t=>clearTimeout(t)),this.verifications.length=0,this.messageBuffer+=e;this.messageBuffer.includes(d.statementDelimiter);){const t=this.messageBuffer.split(d.statementDelimiter);for(;t.length>1;){const i=String(t.shift());let n=g(i,null,this.options.useBigInt?E:parseFloat);for(Array.isArray(n)||(n=[n]);n.length>0;){const c=n.shift();if(C(c)){this.emit("response",c);continue}if(c.id==="versionNegotiation"){if(N(c))this.emit("version",{error:c.error});else{const[a,u]=c.result;this.emit("version",{software:a,protocol:u})}continue}c.id!=="keepAlive"&&this.emit("response",c)}}this.messageBuffer=t.shift()||""}}ping(){r.ping(`Sending keep-alive ping to '${this.hostIdentifier}'`);const e=d.buildRequestObject("server.ping",[],"keepAlive");return this.send(e)}async connect(){if(this.status===o.CONNECTED)return;this.status=o.CONNECTING,this.emit("connecting");const e=(t,i)=>{const n=a=>{this.status=o.DISCONNECTED,this.emit("disconnected"),i(a)};this.socket.removeAllListeners("error"),this.socket.once("error",n);const c=()=>{r.network(`Requesting protocol version ${this.version} with '${this.hostIdentifier}'.`),this.socket.removeListener("error",n);const a=d.buildRequestObject("server.version",[this.application,this.version],"versionNegotiation"),u=h=>{if(v(h)){this.disconnect(!0);const l="unsupported protocol version.";r.errors(`Failed to connect with ${this.hostIdentifier} due to ${l}`),i(l)}else if(h.protocol!==this.version&&`${h.protocol}.0`!==this.version&&`${h.protocol}.0.0`!==this.version){this.disconnect(!0);const l=`incompatible protocol version negotiated (${h.protocol} !== ${this.version}).`;r.errors(`Failed to connect with ${this.hostIdentifier} due to ${l}`),i(l)}else r.network(`Negotiated protocol version ${h.protocol} with '${this.hostIdentifier}', powered by ${h.software}.`),this.status=o.CONNECTED,this.emit("connected"),t()};this.once("version",u),this.send(a)};this.socket.once("connected",c),this.socket.on("error",this.onSocketError.bind(this)),this.socket.connect()};await new Promise(e)}async reconnect(){await this.clearReconnectTimer(),r.network(`Trying to reconnect to '${this.hostIdentifier}'..`),this.status=o.RECONNECTING,this.emit("reconnecting"),this.socket.disconnect();try{await this.connect()}catch{}}clearReconnectTimer(){this.reconnectTimer&&clearTimeout(this.reconnectTimer),this.reconnectTimer=void 0}clearKeepAliveTimer(){this.keepAliveTimer&&clearTimeout(this.keepAliveTimer),this.keepAliveTimer=void 0}setupKeepAliveTimer(){this.keepAliveTimer||(this.keepAliveTimer=setTimeout(this.ping.bind(this),this.options.sendKeepAliveIntervalInMilliSeconds))}async disconnect(e=!1,t=!0){if(this.status===o.DISCONNECTED&&!e)return!1;t&&(this.status=o.DISCONNECTING),this.emit("disconnecting"),await this.clearKeepAliveTimer(),await this.clearReconnectTimer();const i=n=>{this.once("disconnected",()=>n(!0)),this.socket.disconnect()};return new Promise(i)}async handleNetworkChange(){typeof window.navigator>"u"||(window.navigator.onLine===!0&&this.reconnect(),window.navigator.onLine!==!0&&this.disconnect(!0,!1))}async handleVisibilityChange(){document.visibilityState==="hidden"&&this.disconnect(!0,!1),document.visibilityState==="visible"&&this.reconnect()}send(e){this.clearKeepAliveTimer();const t=Date.now(),i=setTimeout(this.verifySend.bind(this,t),this.socket.timeout);return this.verifications.push(i),this.setupKeepAliveTimer(),this.socket.write(e+d.statementDelimiter)}verifySend(e){if(Number(this.lastReceivedTimestamp)<e){if(this.status===o.DISCONNECTED||this.status===o.DISCONNECTING)return;this.clearKeepAliveTimer(),r.network(`Connection to '${this.hostIdentifier}' timed out.`),this.socket.disconnect()}}onSocketConnect(){this.clearReconnectTimer(),this.lastReceivedTimestamp=Date.now(),this.setupKeepAliveTimer(),this.socket.removeAllListeners("error"),this.socket.on("error",this.onSocketError.bind(this))}onSocketDisconnect(){this.clearKeepAliveTimer(),this.status===o.DISCONNECTING?(this.status=o.DISCONNECTED,this.emit("disconnected"),this.clearReconnectTimer(),this.removeAllListeners(),r.network(`Disconnected from '${this.hostIdentifier}'.`)):(this.status===o.CONNECTED&&r.errors(`Connection with '${this.hostIdentifier}' was closed, trying to reconnect in ${this.options.reconnectAfterMilliSeconds/1e3} seconds.`),this.status=o.DISCONNECTED,this.emit("disconnected"),this.reconnectTimer||(this.reconnectTimer=setTimeout(this.reconnect.bind(this),this.options.reconnectAfterMilliSeconds)))}onSocketError(e){typeof e>"u"||r.errors(`Network error ('${this.hostIdentifier}'): `,e)}}const f=1e3,k={useBigInt:!1,sendKeepAliveIntervalInMilliSeconds:1*f,reconnectAfterMilliSeconds:5*f,verifyConnectionTimeoutInMilliSeconds:5*f};class D extends b{get status(){return this.connection.status}constructor(e,t,i,n={}){super(),this.application=e,this.version=t,this.socketOrHostname=i,this.options=n,this.subscriptionMethods={},this.requestId=0,this.requestResolvers={},this.connectionLock=new $;const c={...k,...n};this.connection=new y(e,t,i,c)}get hostIdentifier(){return this.connection.hostIdentifier}get encrypted(){return this.connection.encrypted}async connect(){const e=await this.connectionLock.acquire();try{if(this.connection.status===o.CONNECTED)return;this.connection.on("response",this.response.bind(this)),this.connection.on("connected",this.resubscribeOnConnect.bind(this)),this.connection.on("disconnected",this.onConnectionDisconnect.bind(this)),this.connection.on("connecting",this.handleConnectionStatusChanges.bind(this,"connecting")),this.connection.on("disconnecting",this.handleConnectionStatusChanges.bind(this,"disconnecting")),this.connection.on("reconnecting",this.handleConnectionStatusChanges.bind(this,"reconnecting")),this.connection.on("version",this.storeSoftwareVersion.bind(this)),this.connection.on("received",this.updateLastReceivedTimestamp.bind(this)),this.connection.on("error",this.emit.bind(this,"error")),await this.connection.connect()}finally{e()}}async disconnect(e=!1,t=!1){return t||(this.removeAllListeners(),this.subscriptionMethods={}),this.connection.disconnect(e)}async request(e,...t){if(this.connection.status!==o.CONNECTED)throw new Error(`Unable to send request to a disconnected server '${this.hostIdentifier}'.`);this.requestId+=1;const i=this.requestId,n=d.buildRequestObject(e,t,i),c=a=>{this.requestResolvers[i]=(u,h)=>{a(u||h)},this.connection.send(n)};return r.network(`Sending request '${e}' to '${this.hostIdentifier}'`),new Promise(c)}async subscribe(e,...t){this.subscriptionMethods[e]||(this.subscriptionMethods[e]=new Set),this.subscriptionMethods[e].add(JSON.stringify(t));const i=await this.request(e,...t);if(i instanceof Error)throw i;if(Array.isArray(i))throw new Error("Subscription request returned an more than one data point.");const n={jsonrpc:"2.0",method:e,params:[...t,i]};this.emit("notification",n),this.updateChainHeightFromHeadersNotifications(n)}async unsubscribe(e,...t){if(this.connection.status!==o.CONNECTED)throw new Error(`Unable to send unsubscribe request to a disconnected server '${this.hostIdentifier}'.`);if(!this.subscriptionMethods[e])throw new Error(`Cannot unsubscribe from '${e}' since the method has no subscriptions.`);const i=JSON.stringify(t);if(!this.subscriptionMethods[e].has(i))throw new Error(`Cannot unsubscribe from '${e}' since it has no subscription with the given parameters.`);this.subscriptionMethods[e].delete(i),await this.request(e.replace(".subscribe",".unsubscribe"),...t),r.client(`Unsubscribed from '${String(e)}' for the '${i}' parameters.`)}async resubscribeOnConnect(){r.client(`Connected to '${this.hostIdentifier}'.`),this.handleConnectionStatusChanges("connected");const e=[];for(const t in this.subscriptionMethods){for(const i of this.subscriptionMethods[t].values()){const n=JSON.parse(i);e.push(this.subscribe(t,...n))}await Promise.all(e)}e.length>0&&r.client(`Restored ${e.length} previous subscriptions for '${this.hostIdentifier}'`)}response(e){if(C(e)){r.client(`Received notification for '${e.method}' from '${this.hostIdentifier}'`),this.emit("notification",e),this.updateChainHeightFromHeadersNotifications(e);return}if(e.id===null)throw new Error("Internal error: Received an RPC response with ID null.");const t=this.requestResolvers[e.id];if(!t){r.warning(`Ignoring response #${e.id} as the request has already been rejected.`);return}delete this.requestResolvers[e.id],N(e)?t(new Error(e.error.message)):(t(void 0,e.result),this.storeGenesisHashFromFeaturesResponse(e))}async onConnectionDisconnect(){for(const e in this.requestResolvers){const t=this.requestResolvers[e];t(new Error("Connection lost")),delete this.requestResolvers[e]}this.handleConnectionStatusChanges("disconnected")}async storeSoftwareVersion(e){e.error||(this.software=e.software)}async updateLastReceivedTimestamp(){this.lastReceivedTimestamp=Date.now()}async updateChainHeightFromHeadersNotifications(e){e.method==="blockchain.headers.subscribe"&&(this.chainHeight=e.params[0].height)}async storeGenesisHashFromFeaturesResponse(e){try{typeof e.result.genesis_hash<"u"&&(this.genesisHash=e.result.genesis_hash)}catch{}}async handleConnectionStatusChanges(e){this.emit(e)}}var R=D;export{o as $,R as a};
//# sourceMappingURL=CQVT_UhJ.js.map
