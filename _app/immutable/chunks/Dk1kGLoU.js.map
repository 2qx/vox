{"version":3,"file":"Dk1kGLoU.js","sources":["../../../../../../../../node_modules/.pnpm/svelte@5.33.18/node_modules/svelte/src/internal/client/dom/blocks/await.js"],"sourcesContent":["/** @import { Effect, Source, TemplateNode } from '#client' */\nimport { DEV } from 'esm-env';\nimport { is_promise } from '../../../shared/utils.js';\nimport { block, branch, pause_effect, resume_effect } from '../../reactivity/effects.js';\nimport { internal_set, mutable_source, source } from '../../reactivity/sources.js';\nimport { flushSync, set_active_effect, set_active_reaction } from '../../runtime.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport { queue_micro_task } from '../task.js';\nimport { HYDRATION_START_ELSE, UNINITIALIZED } from '../../../../constants.js';\nimport {\n\tcomponent_context,\n\tis_runes,\n\tset_component_context,\n\tset_dev_current_component_function\n} from '../../context.js';\n\nconst PENDING = 0;\nconst THEN = 1;\nconst CATCH = 2;\n\n/**\n * @template V\n * @param {TemplateNode} node\n * @param {(() => Promise<V>)} get_input\n * @param {null | ((anchor: Node) => void)} pending_fn\n * @param {null | ((anchor: Node, value: Source<V>) => void)} then_fn\n * @param {null | ((anchor: Node, error: unknown) => void)} catch_fn\n * @returns {void}\n */\nexport function await_block(node, get_input, pending_fn, then_fn, catch_fn) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\tvar runes = is_runes();\n\tvar active_component_context = component_context;\n\n\t/** @type {any} */\n\tvar component_function = DEV ? component_context?.function : null;\n\n\t/** @type {V | Promise<V> | typeof UNINITIALIZED} */\n\tvar input = UNINITIALIZED;\n\n\t/** @type {Effect | null} */\n\tvar pending_effect;\n\n\t/** @type {Effect | null} */\n\tvar then_effect;\n\n\t/** @type {Effect | null} */\n\tvar catch_effect;\n\n\tvar input_source = (runes ? source : mutable_source)(/** @type {V} */ (undefined));\n\tvar error_source = (runes ? source : mutable_source)(undefined);\n\tvar resolved = false;\n\n\t/**\n\t * @param {PENDING | THEN | CATCH} state\n\t * @param {boolean} restore\n\t */\n\tfunction update(state, restore) {\n\t\tresolved = true;\n\n\t\tif (restore) {\n\t\t\tset_active_effect(effect);\n\t\t\tset_active_reaction(effect); // TODO do we need both?\n\t\t\tset_component_context(active_component_context);\n\t\t\tif (DEV) set_dev_current_component_function(component_function);\n\t\t}\n\n\t\ttry {\n\t\t\tif (state === PENDING && pending_fn) {\n\t\t\t\tif (pending_effect) resume_effect(pending_effect);\n\t\t\t\telse pending_effect = branch(() => pending_fn(anchor));\n\t\t\t}\n\n\t\t\tif (state === THEN && then_fn) {\n\t\t\t\tif (then_effect) resume_effect(then_effect);\n\t\t\t\telse then_effect = branch(() => then_fn(anchor, input_source));\n\t\t\t}\n\n\t\t\tif (state === CATCH && catch_fn) {\n\t\t\t\tif (catch_effect) resume_effect(catch_effect);\n\t\t\t\telse catch_effect = branch(() => catch_fn(anchor, error_source));\n\t\t\t}\n\n\t\t\tif (state !== PENDING && pending_effect) {\n\t\t\t\tpause_effect(pending_effect, () => (pending_effect = null));\n\t\t\t}\n\n\t\t\tif (state !== THEN && then_effect) {\n\t\t\t\tpause_effect(then_effect, () => (then_effect = null));\n\t\t\t}\n\n\t\t\tif (state !== CATCH && catch_effect) {\n\t\t\t\tpause_effect(catch_effect, () => (catch_effect = null));\n\t\t\t}\n\t\t} finally {\n\t\t\tif (restore) {\n\t\t\t\tif (DEV) set_dev_current_component_function(null);\n\t\t\t\tset_component_context(null);\n\t\t\t\tset_active_reaction(null);\n\t\t\t\tset_active_effect(null);\n\n\t\t\t\t// without this, the DOM does not update until two ticks after the promise\n\t\t\t\t// resolves, which is unexpected behaviour (and somewhat irksome to test)\n\t\t\t\tflushSync();\n\t\t\t}\n\t\t}\n\t}\n\n\tvar effect = block(() => {\n\t\tif (input === (input = get_input())) return;\n\n\t\t/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\t// @ts-ignore coercing `anchor` to a `Comment` causes TypeScript and Prettier to fight\n\t\tlet mismatch = hydrating && is_promise(input) === (anchor.data === HYDRATION_START_ELSE);\n\n\t\tif (mismatch) {\n\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh\n\t\t\tanchor = remove_nodes();\n\n\t\t\tset_hydrate_node(anchor);\n\t\t\tset_hydrating(false);\n\t\t\tmismatch = true;\n\t\t}\n\n\t\tif (is_promise(input)) {\n\t\t\tvar promise = input;\n\n\t\t\tresolved = false;\n\n\t\t\tpromise.then(\n\t\t\t\t(value) => {\n\t\t\t\t\tif (promise !== input) return;\n\t\t\t\t\t// we technically could use `set` here since it's on the next microtick\n\t\t\t\t\t// but let's use internal_set for consistency and just to be safe\n\t\t\t\t\tinternal_set(input_source, value);\n\t\t\t\t\tupdate(THEN, true);\n\t\t\t\t},\n\t\t\t\t(error) => {\n\t\t\t\t\tif (promise !== input) return;\n\t\t\t\t\t// we technically could use `set` here since it's on the next microtick\n\t\t\t\t\t// but let's use internal_set for consistency and just to be safe\n\t\t\t\t\tinternal_set(error_source, error);\n\t\t\t\t\tupdate(CATCH, true);\n\t\t\t\t\tif (!catch_fn) {\n\t\t\t\t\t\t// Rethrow the error if no catch block exists\n\t\t\t\t\t\tthrow error_source.v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (hydrating) {\n\t\t\t\tif (pending_fn) {\n\t\t\t\t\tpending_effect = branch(() => pending_fn(anchor));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Wait a microtask before checking if we should show the pending state as\n\t\t\t\t// the promise might have resolved by the next microtask.\n\t\t\t\tqueue_micro_task(() => {\n\t\t\t\t\tif (!resolved) update(PENDING, true);\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tinternal_set(input_source, input);\n\t\t\tupdate(THEN, false);\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\n\t\t// Set the input to something else, in order to disable the promise callbacks\n\t\treturn () => (input = UNINITIALIZED);\n\t});\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n"],"names":["PENDING","THEN","CATCH","await_block","node","get_input","pending_fn","then_fn","catch_fn","hydrating","hydrate_next","anchor","runes","is_runes","active_component_context","component_context","input","UNINITIALIZED","pending_effect","then_effect","catch_effect","input_source","source","mutable_source","error_source","resolved","update","state","restore","set_active_effect","effect","set_active_reaction","set_component_context","resume_effect","branch","pause_effect","flushSync","block","mismatch","is_promise","HYDRATION_START_ELSE","remove_nodes","set_hydrate_node","set_hydrating","promise","value","internal_set","error","queue_micro_task","hydrate_node"],"mappings":"uLAuBA,MAAMA,EAAU,EACVC,EAAO,EACPC,EAAQ,EAWP,SAASC,EAAYC,EAAMC,EAAWC,EAAYC,EAASC,EAAU,CACvEC,GACHC,EAAc,EAGf,IAAIC,EAASP,EACTQ,EAAQC,EAAU,EAClBC,EAA2BC,EAM3BC,EAAQC,EAGRC,EAGAC,EAGAC,EAEAC,GAAgBT,EAAQU,EAASC,GAAkC,MAAW,EAC9EC,GAAgBZ,EAAQU,EAASC,GAAgB,MAAS,EAC1DE,EAAW,GAMf,SAASC,EAAOC,EAAOC,EAAS,CAC/BH,EAAW,GAEPG,IACHC,EAAkBC,CAAM,EACxBC,EAAoBD,CAAM,EAC1BE,EAAsBlB,CAAwB,GAI/C,GAAI,CACCa,IAAU3B,GAAWM,IACpBY,EAAgBe,EAAcf,CAAc,EAC3CA,EAAiBgB,EAAO,IAAM5B,EAAWK,CAAM,CAAC,GAGlDgB,IAAU1B,GAAQM,IACjBY,EAAac,EAAcd,CAAW,EACrCA,EAAce,EAAO,IAAM3B,EAAQI,EAAQU,CAAY,CAAC,GAG1DM,IAAUzB,GAASM,IAClBY,EAAca,EAAcb,CAAY,EACvCA,EAAec,EAAO,IAAM1B,EAASG,EAAQa,CAAY,CAAC,GAG5DG,IAAU3B,GAAWkB,GACxBiB,EAAajB,EAAgB,IAAOA,EAAiB,IAAK,EAGvDS,IAAU1B,GAAQkB,GACrBgB,EAAahB,EAAa,IAAOA,EAAc,IAAK,EAGjDQ,IAAUzB,GAASkB,GACtBe,EAAaf,EAAc,IAAOA,EAAe,IAAK,CAE1D,QAAY,CACLQ,IAEHI,EAAsB,IAAI,EAC1BD,EAAoB,IAAI,EACxBF,EAAkB,IAAI,EAItBO,EAAW,EAEf,CACA,CAEC,IAAIN,EAASO,EAAM,IAAM,CACxB,GAAIrB,KAAWA,EAAQX,EAAS,GAAK,OAIrC,IAAIiC,EAAW7B,GAAa8B,EAAWvB,CAAK,KAAOL,EAAO,OAAS6B,GAWnE,GATIF,IAEH3B,EAAS8B,EAAc,EAEvBC,EAAiB/B,CAAM,EACvBgC,EAAc,EAAK,EACnBL,EAAW,IAGRC,EAAWvB,CAAK,EAAG,CACtB,IAAI4B,EAAU5B,EAEdS,EAAW,GAEXmB,EAAQ,KACNC,GAAU,CACND,IAAY5B,IAGhB8B,EAAazB,EAAcwB,CAAK,EAChCnB,EAAOzB,EAAM,EAAI,EACjB,EACA8C,GAAU,CACV,GAAIH,IAAY5B,IAGhB8B,EAAatB,EAAcuB,CAAK,EAChCrB,EAAOxB,EAAO,EAAI,EACd,CAACM,GAEJ,MAAMgB,EAAa,CAEzB,CACI,EAEGf,EACCH,IACHY,EAAiBgB,EAAO,IAAM5B,EAAWK,CAAM,CAAC,GAKjDqC,EAAiB,IAAM,CACjBvB,GAAUC,EAAO1B,EAAS,EAAI,CACxC,CAAK,CAEL,MACG8C,EAAazB,EAAcL,CAAK,EAChCU,EAAOzB,EAAM,EAAK,EAGnB,OAAIqC,GAEHK,EAAc,EAAI,EAIZ,IAAO3B,EAAQC,CACxB,CAAE,EAEGR,IACHE,EAASsC,EAEX","x_google_ignoreList":[0]}