import{f as m,a as d,d as ut}from"../chunks/DYbKDSXk.js";import{o as Ot,a as dt}from"../chunks/CPLxGhQo.js";import{au as _t,p as tt,c as r,r as i,s as l,E as n,aF as lt,t as M,a as et,aG as E,ac as W,ad as T,f as j}from"../chunks/DlUVEpaU.js";import{i as A}from"../chunks/C6jlbT71.js";import{e as mt,i as Pt}from"../chunks/CMKxWac-.js";import{s as x}from"../chunks/vpaS6ag4.js";import{s as pt}from"../chunks/jyPZu9FF.js";import"../chunks/DMsRCC9c.js";import"../chunks/vmZ8CxnS.js";import{$ as z,a as J}from"../chunks/CRbVXWIV.js";import{W as ft,I as Tt,B as kt}from"../chunks/1C4dGgcF.js";import{g as gt}from"../chunks/moW41TmD.js";import{m as L,k as ht,p as nt,q as Et,N as Z,C as bt,E as Ut,b as $,H as yt,F as vt}from"../chunks/0o8OGYDl.js";import{g as Bt}from"../chunks/TzW3FNAJ.js";import{c as Nt}from"../chunks/B6Foiicm.js";import{B as Ct,D as At}from"../chunks/CReqLTTF.js";import"../chunks/l0sNRNKZ.js";import{C as xt}from"../chunks/B7hCbxZp.js";import{d as It,s as G}from"../chunks/DIwOIcma.js";import{b as Rt}from"../chunks/B8sppVjI.js";import{b as Lt}from"../chunks/C4jED5RM.js";import{T as wt,a as Ft}from"../chunks/BIB44Wys.js";const Yt=!0,xe=Object.freeze(Object.defineProperty({__proto__:null,prerender:Yt},Symbol.toStringTag,{value:"Module"}));var Mt=m('<h3>About BadgerStake</h3> <p>Badgers is a proof-of-ownership memecoin on BitcoinCash.</p> <p>More information at <a href="https://badgers.cash/FAQ" rel="nofollow">Badgers.Cash</a></p>',1);function qt(b){var t=Mt();_t(4),d(b,t)}const St="https://libauth.org/schemas/wallet-template-v0.schema.json",Vt="BadgerStake: a staking contract to earn Badger tokens.",Dt="BadgerStake",Qt={covenant:{description:"BadgerStake holds undistributed BadgerCoins on the MasterBadger NFT as well as staked coins.",name:"Badger Vault",scripts:["unlock","stake","lock","administer"],variables:{amount:{description:"Stake amount.",name:"Amount",type:"WalletData"},stake_blocks:{description:"The duration of the staking period (in blocks)",name:"Stake Blocks",type:"WalletData"},new_fee:{description:"The category of the asset being listed.",name:"Asset Category",type:"WalletData"},user_pkh:{description:"The key that controls user funds.",name:"User",type:"WalletData"},admin_pkh:{description:"The key administering this covenant.",name:"Admin",type:"WalletData"}}}},Kt={base:{data:{bytecode:{stake_blocks:"5000",amount:"100000000",new_fee:"1000"}},description:"",name:"Base Scenario"},stake:{data:{bytecode:{stake_blocks:"5000",amount:"400000",new_fee:"1000",user_pkh:"0xbe7f0bcf860657ce2fdb6f047141faa39e50f224"}},description:"Lock coins in the Badger Vault",extends:"base",name:"Lock Assets",transaction:{inputs:[{unlockingBytecode:["slot"]},{}],outputs:[{lockingBytecode:{script:"lock"},valueSatoshis:335e3,token:{amount:"9223372036854412287",category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",nft:{capability:"minting",commitment:"e8030000000000000000000000000000000000002770188a88f75360d1e956d7ff290ef1e0f56787"}}},{lockingBytecode:{script:"lock"},valueSatoshis:4e5,token:{amount:20,category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",nft:{capability:"mutable",commitment:"be7f0bcf860657ce2fdb6f047141faa39e50f2240000000000000000000000000000000000008813"}}},{lockingBytecode:"76a914be7f0bcf860657ce2fdb6f047141faa39e50f22488ac",valueSatoshis:2713641}],version:2},sourceOutputs:[{lockingBytecode:["slot"],valueSatoshis:334e3,token:{category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",amount:"9223372036854412307",nft:{commitment:"e8030000000000000000000000000000000000002770188a88f75360d1e956d7ff290ef1e0f56787",capability:"minting"}}},{valueSatoshis:42715641}]},unlock:{data:{bytecode:{stake_blocks:"5000",amount:"400000",new_fee:"1000",user_pkh:"0xbe7f0bcf860657ce2fdb6f047141faa39e50f224"}},description:"",extends:"base",name:"Release Assets",transaction:{inputs:[{unlockingBytecode:["slot"],sequenceNumber:5e3}],outputs:[{lockingBytecode:"76a914be7f0bcf860657ce2fdb6f047141faa39e50f22488ac",valueSatoshis:1e3,token:{amount:20,category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7"}},{lockingBytecode:"76a914be7f0bcf860657ce2fdb6f047141faa39e50f22488ac",valueSatoshis:1e3,token:{category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",amount:0,nft:{capability:"none",commitment:"000014"}}},{lockingBytecode:"76a914be7f0bcf860657ce2fdb6f047141faa39e50f22488ac",valueSatoshis:397e3}],version:2},sourceOutputs:[{lockingBytecode:["slot"],valueSatoshis:4e5,token:{category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",amount:20,nft:{commitment:"be7f0bcf860657ce2fdb6f047141faa39e50f2240000000000000000000000000000000000008813",capability:"mutable"}}}]},withdraw:{description:"Administer the current fee, ",extends:"base",name:"Withdraw accumulated fees and adjust anti-spam fee",transaction:{inputs:[{unlockingBytecode:["slot"],sequenceNumber:10},{unlockingBytecode:{script:["copy"]}}],outputs:[{lockingBytecode:{script:"lock"},valueSatoshis:1e3,token:{amount:"9223372036854412287",category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",nft:{capability:"minting",commitment:"e8030000000000000000000000000000000000002770188a88f75360d1e956d7ff290ef1e0f56787"}}},{lockingBytecode:"76a9142770188a88f75360d1e956d7ff290ef1e0f5678788ac",valueSatoshis:330800}],version:2},sourceOutputs:[{lockingBytecode:["slot"],valueSatoshis:332e3,token:{category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",amount:"9223372036854412287",nft:{commitment:"e8030000000000000000000000000000000000002770188a88f75360d1e956d7ff290ef1e0f56787",capability:"minting"}}},{lockingBytecode:"76a9142770188a88f75360d1e956d7ff290ef1e0f5678788ac",valueSatoshis:800}]}},Xt=JSON.parse(`{"stake":{"passes":["stake"],"name":"0: Lock","script":" <user_pkh> <stake_blocks> <amount>  OP_0","unlocks":"lock"},"unlock":{"passes":["unlock"],"name":"1: Unlock","script":"OP_1","unlocks":"lock"},"administer":{"passes":["withdraw"],"name":"2: Administer","script":"<new_fee> OP_2 ","unlocks":"lock"},"lock":{"lockingType":"p2sh32","name":"BadgerStake Covenant","script":"\\n// pragma cashscript ^0.10.0;\\n\\n// contract BadgerStake() {\\n\\n//     /////////////////////////////////////////////\\n//     //inputs:\\n//     //  0   masterBadger        [NFT]   (from contract)\\n//     //  1   userUTXO            [BCH]   (from user)\\n//     //outputs:\\n//     //  0   masterBadger        [NFT]   (to contract)\\n//     //  1   lockUTXO            [NFT]   (to contract)\\n//     //  2   {optional} change   [BCH]   (to user)\\n//     /////////////////////\\n//     //parameters:\\n//     //  amount: BCH amount user wants to lock up\\n//     //  stakeBlocks: number of blocks to be locked up for\\n//     //  pubkeyhash: a pubkeyhash, used to send the locked BCH back to the users address\\n//     /////////////////////////////////////////////\\n\\n       OP_DUP OP_0 OP_NUMEQUAL OP_IF \\n//     function lock(int amount, int stakeBlocks, bytes20 pubkeyhash) {\\n\\n//       // this contract must be input0\\n         OP_INPUTINDEX OP_0 OP_NUMEQUALVERIFY \\n//       require(this.activeInputIndex == 0);\\n\\n//       // must have exactly 2 inputs\\n         OP_TXINPUTCOUNT OP_2 OP_NUMEQUALVERIFY \\n//       require(tx.inputs.length == 2);\\n\\n//       // must have 3 or less outputs\\n         OP_TXOUTPUTCOUNT OP_3 OP_LESSTHANOREQUAL OP_VERIFY \\n//       require(tx.outputs.length <= 3);\\n\\n//       // cannot lock for longer than 65536 blocks\\n         OP_2 OP_PICK <65536> OP_LESSTHANOREQUAL OP_VERIFY \\n//       require(stakeBlocks <= 65536);\\n\\n//       // minimum 5000 sats to lock so have enough for unlock()\\n         OP_OVER <5000> OP_GREATERTHANOREQUAL OP_VERIFY \\n//       require(amount >= 5000);\\n\\n//       // input0 must be masterBadger NFT\\n         OP_0 OP_UTXOTOKENCATEGORY <0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24> OP_2 OP_CAT OP_EQUALVERIFY\\n//       require(tx.inputs[0].tokenCategory == 0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24 + 0x02);\\n\\n//       // input1 must be BCH with no tokens\\n         OP_1 OP_UTXOTOKENCATEGORY OP_0 OP_EQUALVERIFY \\n//       require(tx.inputs[1].tokenCategory == 0x);\\n\\n//       // provided pubkeyhash must be the pubkeyhash of input1 (users address)\\n         OP_1 OP_UTXOBYTECODE <0x76a914> OP_5 OP_PICK OP_CAT <0x88ac> OP_CAT OP_EQUALVERIFY \\n//       require(tx.inputs[1].lockingBytecode == new LockingBytecodeP2PKH(pubkeyhash));\\n\\n//       // convert stakeBlocks to bytes for inclusion into commitment\\n         OP_2 OP_PICK OP_2 OP_NUM2BIN \\n//       bytes stakeLength = bytes2(stakeBlocks);\\n\\n//       // save payout address and length of lock into output1 commitment (lockNFT)\\n         OP_1 OP_OUTPUTTOKENCOMMITMENT OP_5 OP_ROLL OP_0 <18> OP_NUM2BIN OP_CAT OP_ROT OP_CAT OP_EQUALVERIFY \\n//       require(tx.outputs[1].nftCommitment == pubkeyhash + bytes18(0) + stakeLength);\\n\\n//       // get current locking fee from masterBadger's commitment\\n         OP_0 OP_UTXOTOKENCOMMITMENT OP_2 OP_SPLIT OP_DROP \\n//       bytes2 stakeFee = bytes2(tx.inputs[0].nftCommitment.split(2)[0]);\\n\\n//       // add locking fee to current masterBadger balance\\n         OP_0 OP_OUTPUTVALUE OP_0 OP_UTXOVALUE OP_ROT OP_BIN2NUM OP_ADD OP_NUMEQUALVERIFY \\n//       require(tx.outputs[0].value == tx.inputs[0].value + int(stakeFee));\\n\\n//       // output0 sent to contract (recreate masterBadger)\\n         OP_0 OP_OUTPUTBYTECODE OP_0 OP_UTXOBYTECODE OP_EQUALVERIFY \\n//       require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\\n\\n//       // carry forward masterBadger tokenCategory + capability\\n         OP_0 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY OP_EQUALVERIFY \\n//       require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\\n\\n//       // carry forward masterBadger commitment\\n         OP_0 OP_OUTPUTTOKENCOMMITMENT OP_0 OP_UTXOTOKENCOMMITMENT OP_EQUALVERIFY \\n//       require(tx.outputs[0].nftCommitment == tx.inputs[0].nftCommitment);\\n\\n//       calculate amount of BadgerCoins user will earn (amount * blocks / 1BCH)\\n         OP_OVER OP_3 OP_ROLL OP_MUL <100000000> OP_DIV \\n//       int stakeReward = amount * stakeBlocks / 100000000;\\n\\n//       // require at least 1 BadgerCoin will be earned\\n         OP_DUP OP_1 OP_GREATERTHANOREQUAL OP_VERIFY \\n//       require(stakeReward >= 1);\\n\\n//       // deduct earned BadgerCoins from masterBadger\\n         OP_0 OP_OUTPUTTOKENAMOUNT OP_0 OP_UTXOTOKENAMOUNT OP_2 OP_PICK OP_SUB OP_NUMEQUALVERIFY \\n//       require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount - stakeReward);\\n\\n//       // output1 sent to contract (lockNFT)\\n         OP_1 OP_OUTPUTBYTECODE OP_0 OP_UTXOBYTECODE OP_EQUALVERIFY \\n//       require(tx.outputs[1].lockingBytecode == tx.inputs[0].lockingBytecode);\\n\\n//       // lockNFT is a mutable NFT of masterBadger categoryID\\n         OP_1 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY <32> OP_SPLIT OP_DROP OP_1 OP_CAT OP_EQUALVERIFY \\n//       require(tx.outputs[1].tokenCategory == tx.inputs[0].tokenCategory.split(32)[0] + 0x01);\\n\\n//       // lockNFT has BCH equal to users amount parameter\\n         OP_1 OP_OUTPUTVALUE OP_3 OP_ROLL OP_NUMEQUALVERIFY\\n//       require(tx.outputs[1].value == amount);\\n\\n//       // lockNFT has BadgerCoin equal to calculated amount to be earned\\n         OP_1 OP_OUTPUTTOKENAMOUNT OP_NUMEQUALVERIFY \\n//       require(tx.outputs[1].tokenAmount == stakeReward);\\n\\n//       // if output2 exists (change)\\n         OP_TXOUTPUTCOUNT OP_3 OP_NUMEQUAL OP_IF \\n//       if (tx.outputs.length == 3) {\\n//          // change must be sent to users address\\n            OP_2 OP_OUTPUTBYTECODE OP_1 OP_UTXOBYTECODE OP_EQUALVERIFY \\n//          require(tx.outputs[2].lockingBytecode == tx.inputs[1].lockingBytecode);\\n\\n//          // change must not have tokens\\n            OP_2 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUALVERIFY OP_ENDIF \\n//          require(tx.outputs[2].tokenCategory == 0x);\\n//       }\\n//     }\\n      OP_DROP OP_1 OP_ELSE \\n\\n//    /////////////////////////////////////////////\\n//    //inputs:\\n//    //  0   lockUTXO            [NFT]   (from contract)\\n//    //      <20-byte owner_pkh> <18-byte 00s> <2-byte fee>\\n//    //\\n//    //outputs:\\n//    //  0   BadgerCoins         [FUN]   (to user)\\n//    //  1   Honey               [NFT]   (to user)\\n//    //  2   {optional} change   [BCH]   (to user)\\n//    /////////////////////////////////////////////\\n      OP_DUP OP_1 OP_NUMEQUAL OP_IF \\n//     function unlock() {\\n\\n//       // this contract must be input0\\n         OP_INPUTINDEX OP_0 OP_NUMEQUALVERIFY \\n//       require(this.activeInputIndex == 0);\\n\\n//       // must have exactly 1 input\\n         OP_TXINPUTCOUNT OP_1 OP_NUMEQUALVERIFY \\n//       require(tx.inputs.length == 1);\\n\\n//       // must have exactly 3 outputs\\n         OP_TXOUTPUTCOUNT OP_3 OP_NUMEQUALVERIFY \\n//       require(tx.outputs.length == 3);\\n\\n//       // input0 must be a lockNFT (masterBadger categoryID + mutable)\\n         OP_0 OP_UTXOTOKENCATEGORY <0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24> OP_1 OP_CAT OP_EQUALVERIFY \\n//       require(tx.inputs[0].tokenCategory == 0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24 + 0x01);\\n\\n//       // get number of blocks locked for from lockNFT's commitment\\n         OP_0 OP_UTXOTOKENCOMMITMENT <38> OP_SPLIT OP_NIP \\n//       bytes stakeBlocks = bytes2(tx.inputs[0].nftCommitment.split(38)[1]);\\n\\n//       // require the number of blocks locked for has been passed\\n         OP_BIN2NUM OP_CHECKSEQUENCEVERIFY \\n//       require(tx.age >= int(stakeBlocks));\\n\\n//       // get the pubkeyhash in lockNFT it was created with\\n         OP_DROP OP_0 OP_UTXOTOKENCOMMITMENT <20> OP_SPLIT OP_DROP \\n//       bytes20 payoutAddress = bytes20(tx.inputs[0].nftCommitment.split(20)[0]);\\n\\n//       // create the lockingBytecode for that pubkeyhash\\n         <0x76a914> OP_SWAP OP_CAT <0x88ac> OP_CAT \\n//       bytes payoutBytecode = new LockingBytecodeP2PKH(payoutAddress);\\n\\n//       // output0 (BadgerCoins) goes to the resulting wallet address (user who created the lock)\\n         OP_0 OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY \\n//       require(tx.outputs[0].lockingBytecode == payoutBytecode);\\n\\n//       // output0 is a masterBadger categoryID but no capability\\n         OP_0 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY <32> OP_SPLIT OP_DROP OP_EQUALVERIFY \\n//       require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory.split(32)[0]);\\n\\n//       // output0 has 1000 dust satoshis so it can exist\\n         OP_0 OP_OUTPUTVALUE <1000> OP_NUMEQUALVERIFY \\n//       require(tx.outputs[0].value == 1000);\\n\\n         OP_0 OP_OUTPUTTOKENAMOUNT OP_0 OP_UTXOTOKENAMOUNT OP_NUMEQUALVERIFY \\n//       require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount);\\n\\n//       // output1 (HoneyNFT) goes to the resulting wallet address (user who created the lock)\\n         OP_1 OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY \\n//       require(tx.outputs[1].lockingBytecode == payoutBytecode);\\n\\n//       // output1 is a masterBadger categoryID but no capability\\n         OP_1 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY <32> OP_SPLIT OP_DROP OP_EQUALVERIFY \\n//       require(tx.outputs[1].tokenCategory == tx.inputs[0].tokenCategory.split(32)[0]);\\n\\n//       // output1 has 1000 satoshis so it can exist\\n         OP_1 OP_OUTPUTVALUE <1000> OP_NUMEQUALVERIFY \\n//       require(tx.outputs[1].value == 1000);\\n\\n//       // create commitment of ID0 + amount of BadgerCoins earned\\n         <0x0000> OP_0 OP_UTXOTOKENAMOUNT OP_CAT \\n//       bytes commitment = 0x0000 + bytes(tx.inputs[0].tokenAmount);\\n\\n//       // output1 has above commitment\\n         OP_1 OP_OUTPUTTOKENCOMMITMENT OP_EQUALVERIFY \\n//       require(tx.outputs[1].nftCommitment == commitment);\\n\\n//       // output2 (unlocked BCH) goes to the extracted wallet address (user who created the lock)\\n         OP_2 OP_OUTPUTBYTECODE OP_EQUALVERIFY \\n//       require(tx.outputs[2].lockingBytecode == payoutBytecode);\\n\\n//       // output2 has no tokens\\n         OP_2 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUALVERIFY \\n//       require(tx.outputs[2].tokenCategory == 0x);\\n\\n//       // output2 has original locked BCH minus 3000sats (miner fee + BadgerCoin utxo + Honey utxo)\\n         OP_2 OP_OUTPUTVALUE OP_0 OP_UTXOVALUE <3000> OP_SUB OP_NUMEQUAL \\n//       require(tx.outputs[2].value == tx.inputs[0].value - 3000);\\n//     }\\n\\n//     /////////////////////////////////////////////\\n//     //inputs:\\n//     //  0   masterBadger        [NFT]   (from contract)\\n//     //      <2-byte fee> <18-byte 00s> <20-byte admin_pkh>\\n//     //      \\n//     //  1   adminUTXO           [BCH]   (from admin)\\n//     //outputs:\\n//     //  0   masterBadger        [NFT]   (to contract)\\n//     //  1   withdrawUTXO        [BCH]   (to admin)\\n//     /////////////////////\\n//     //parameters:\\n//     //  newFee: sets the masterBadger's locking fee (0 to 65536)\\n//     /////////////////////////////////////////////\\n      OP_NIP OP_ELSE OP_2 OP_NUMEQUALVERIFY \\n//     function withdraw(int newFee) {\\n\\n//       // this contract must be input0\\n         OP_INPUTINDEX OP_0 OP_NUMEQUALVERIFY \\n//       require(this.activeInputIndex == 0);\\n\\n//       // must have exactly 2 inputs\\n         OP_TXINPUTCOUNT OP_2 OP_NUMEQUALVERIFY \\n//       require(tx.inputs.length == 2);\\n\\n//       // must have exactly 2 outputs\\n         OP_TXOUTPUTCOUNT OP_2 OP_NUMEQUALVERIFY \\n//       require(tx.outputs.length == 2);\\n\\n//       // input0 must be masterBadger NFT\\n         OP_0 OP_UTXOTOKENCATEGORY <0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24> OP_2 OP_CAT OP_EQUALVERIFY \\n//       require(tx.inputs[0].tokenCategory == 0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24 + 0x02);\\n\\n//       // input1 must be BCH with no tokens\\n         OP_1 OP_UTXOTOKENCATEGORY OP_0 OP_EQUALVERIFY \\n//       require(tx.inputs[1].tokenCategory == 0x);\\n\\n//       // get admins pubkeyhash stored in masterBadger commitment\\n         OP_0 OP_UTXOTOKENCOMMITMENT <20> OP_SPLIT OP_NIP \\n//       bytes20 adminAddress = bytes20(tx.inputs[0].nftCommitment.split(20)[1]);\\n\\n//       // create the lockingBytecode for that pubkeyhash\\n         <0x76a914> OP_SWAP OP_CAT <0x88ac> OP_CAT \\n//       bytes payoutBytecode = new LockingBytecodeP2PKH(adminAddress);\\n\\n//       // require the resulting lockingBytecode matches input1 (input1 is from admin address)\\n         OP_1 OP_UTXOBYTECODE OP_EQUALVERIFY \\n//       require(tx.inputs[1].lockingBytecode == payoutBytecode);\\n\\n//       // output1 has no tokens\\n         OP_1 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUALVERIFY \\n//       require(tx.outputs[1].tokenCategory == 0x);\\n\\n//       // output1 takes masterBadger's BCH balance minus 2000sats (miner fee + masterBadger dust)\\n         OP_1 OP_OUTPUTVALUE OP_0 OP_UTXOVALUE OP_1 OP_UTXOVALUE OP_ADD <2000> OP_SUB OP_NUMEQUALVERIFY \\n//       require(tx.outputs[1].value == tx.inputs[0].value + tx.inputs[1].value - 2000);\\n\\n//       // output0 sent to contract (recreate masterBadger)\\n         OP_0 OP_OUTPUTBYTECODE OP_0 OP_UTXOBYTECODE OP_EQUALVERIFY \\n//       require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\\n\\n//       // masterBadger retains its tokenCategory + capability\\n         OP_0 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY OP_EQUALVERIFY \\n//       require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\\n\\n//       // masterBadger set to 1000sats so it can exist\\n         OP_0 OP_OUTPUTVALUE <1000> OP_NUMEQUALVERIFY \\n//       require(tx.outputs[0].value == 1000);\\n\\n//       // masterBadger retains its remaining BadgerCoins\\n         OP_0 OP_OUTPUTTOKENAMOUNT OP_0 OP_UTXOTOKENAMOUNT OP_NUMEQUALVERIFY \\n//       require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount);\\n\\n//       // get last 38bytes of masterBadgers commitment\\n         OP_0 OP_UTXOTOKENCOMMITMENT OP_2 OP_SPLIT OP_NIP \\n//       bytes restCommitment = tx.inputs[0].nftCommitment.split(2)[1];\\n\\n//       // update masterBadger's commitment to newFee + rest of its commitment\\n         OP_0 OP_OUTPUTTOKENCOMMITMENT OP_ROT OP_2 OP_NUM2BIN OP_ROT OP_CAT OP_EQUAL\\n//       require(tx.outputs[0].nftCommitment == bytes2(newFee) + restCommitment);\\n//    }\\n   OP_ENDIF \\n// }\\nOP_ENDIF"}}`),Ht=["BCH_2023_05","BCH_SPEC"],Gt={$schema:St,description:Vt,name:Dt,entities:Qt,scenarios:Kt,scripts:Xt,supported:Ht},Wt="@unspent/badgers",jt={name:Wt},zt=L("242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7");L("0000000000000000000000000000000000000000000000000000000000000000");class C{static USER_AGENT=jt.name;static tokenAware=!0;static template=Gt;static compiler=ht(this.template);static vm=Nt();static getLockingBytecode(){const t=this.compiler.generateBytecode({data:{},scriptId:"lock"});if(!t.success)throw new Error("Failed to generate bytecode, script: , "+JSON.stringify(t,null,"  "));return t.bytecode}static getScriptHash(t=!0){return nt(this.getLockingBytecode(),t)}static getAddress(t="bitcoincash"){return Et(this.getLockingBytecode(),t,this.tokenAware)}static parseNFT(t){if(t.token_data?.nft?.capability=="mutable")return{amount:parseInt(t.token_data?.amount),stake:Z(L(t.token_data?.nft?.commitment.slice(-4))),user_pkh:t.token_data?.nft?.commitment.slice(0,40)};if(t.token_data?.nft?.capability=="minting")return{amount:parseInt(t.token_data?.amount),stake:Z(L(t.token_data?.nft?.commitment.slice(0,4))),user_pkh:t.token_data?.nft?.commitment.slice(-40)};throw Error("Nft was not minting nor mutable")}static getSourceOutput(t){return{lockingBytecode:this.getLockingBytecode(),valueSatoshis:BigInt(t.value)}}static getInput(t){return{outpointIndex:t.tx_pos,outpointTransactionHash:L(t.tx_hash),sequenceNumber:t.value,unlockingBytecode:{data:{},compiler:this.compiler,script:"unlock",valueSatoshis:BigInt(t.value)}}}static getOutput(){return{lockingBytecode:{data:{},compiler:this.compiler,script:"op_return"},valueSatoshis:BigInt(0)}}static getSourceOutputs(t){const k=[];return k.push(...t.map(_=>this.getSourceOutput(_))),k}static unlock(t){let P={locktime:0,version:2,inputs:[],outputs:[]};P.inputs.push(this.getInput(t)),P.outputs.push(this.getOutput());let c=bt(P);if(!c.success)throw new Error("generate transaction failed!, errors: "+JSON.stringify(c.errors,null,"  "));const p=[this.getSourceOutput(t)],s=c.transaction,g=Ut(s,p,{maximumTokenCommitmentLength:40});if(g!==!0)throw g;let f=this.vm.verify({sourceOutputs:p,transaction:s});if(typeof f=="string")throw f;return{sourceOutputs:p,transaction:s,verify:f}}}var Jt=m('<div class="svelte-1mqbhtw"><!> <!></div>'),Zt=(b,t)=>{t.unlock({tx_hash:t.tx_hash,tx_pos:t.tx_pos,value:t.value,token_data:t.token_data})},$t=m("<button>release</button>"),te=m('<img height="32px" class="svelte-1mqbhtw"/>'),ee=m('<div class="container svelte-1mqbhtw"><div class="stake svelte-1mqbhtw"><div class="balance svelte-1mqbhtw"><div class="fill svelte-1mqbhtw"><!></div> <div><div> <b>BCH</b> <img width="20px"/></div> <div class="auth svelte-1mqbhtw"><!> <!></div></div></div> <div class="header svelte-1mqbhtw"><div class="timestamp svelte-1mqbhtw"> </div> <div class="fill svelte-1mqbhtw"></div> <div class="timestamp svelte-1mqbhtw"> </div></div></div></div>');function ne(b,t){tt(t,!0);let k=lt(()=>t.height+t.stake<t.now);var _=ee(),P=r(_),c=r(P),p=r(c),s=r(p);{var g=o=>{var u=Jt(),v=r(u);wt(v,{get amount(){return t.token_data.amount},get category(){return t.token_data.category}});var K=l(v,2);Ft(K,{size:"20",get category(){return t.token_data.category}}),i(u),d(o,u)};A(s,o=>{t.token_data&&o(g)})}i(p);var f=l(p,2),I=r(f),R=r(I),q=l(R,3);i(I);var h=l(I,2),w=r(h);{var S=o=>{var u=$t();u.__click=[Zt,t],d(o,u)};A(w,o=>{n(k)&&o(S)})}var V=l(w,2);{var D=o=>{var u=te();M(v=>{x(u,"src",v),x(u,"alt",t.user_pkh)},[()=>Rt(t.user_pkh,16)]),d(o,u)};A(V,o=>{t.user_pkh&&o(D)})}i(h),i(f),i(c);var y=l(c,2),U=r(y),F=r(U,!0);i(U);var Y=l(U,4),Q=r(Y,!0);i(Y),i(y),i(P),i(_),M(o=>{G(R,`${o??""} `),x(q,"src",Lt),G(F,t.stake),G(Q,t.height)},[()=>Number(t.value/1e8).toLocaleString(void 0,{})]),d(b,_),et()}It(["click"]);var ae=m("<img/>"),se=m('<img alt="Disconnected"/>'),oe=m('<div class="row svelte-a2gs4s"><!></div>'),re=m("<p>No staked coins?</p>"),ie=m('<h3>Current Stakes</h3> <div class="grid svelte-a2gs4s"><!></div>',1),ce=m('<section><div class="status svelte-a2gs4s"><!> <!></div> <!> <!></section>');function Ie(b,t){tt(t,!0);let k=E(0),_=E(""),P=E(""),c=E(W([]));W([]);let p=E(""),s=E(void 0),g=E(""),f=E("");T(g,C.getScriptHash(),!0);const I=!0;$(zt);const R=gt(I);let q=new Set,h;const w=async function(e){if(e.method==="blockchain.headers.subscribe"){let a=e.params[0];T(k,a.height,!0),V()}else e.method==="blockchain.scripthash.subscribe"?e.params[1]!==n(P)&&(T(P,e.params[1],!0),T(_,J[n(s).status],!0)):console.log(e)},S=async function(e){let a=await n(s).request("blockchain.transaction.broadcast",e);if(a instanceof Error)throw T(_,J[n(s).status],!0),a},V=async function(){let e=await n(s).request("blockchain.scripthash.listunspent",n(g),"include_tokens");if(e instanceof Error)throw e;let a=new Set(e.map(O=>`${O.tx_hash}":"${O.tx_pos}`));(n(c).length==0||q.intersection(a).size==0)&&T(c,e.filter(O=>O.token_data.nft.capability=="mutable").map(O=>({...O,...C.parseNFT(O),now:n(k)})),!0)},D=async function(e){let a=C.unlock(e),O=$(vt(a.transaction));await S(O)};Ot(async()=>{kt.StorageProvider=Tt,h=await ft.named("vox"),T(p,Bt(h.mnemonic,h.derivationPath.slice(0,-2),h.isTestnet),!0);let e=yt(h.getDepositAddress());if(typeof e=="string")throw e;T(f,nt(e.bytecode),!0),T(s,new z(C.USER_AGENT,"1.4.1",R),!0),await n(s).connect(),n(s).on("notification",w),await n(s).subscribe("blockchain.scripthash.subscribe",n(g)),await n(s).subscribe("blockchain.scripthash.subscribe",n(f)),await n(s).subscribe("blockchain.headers.subscribe")}),dt(async()=>{await new z(C.USER_AGENT,"1.4.1",R).disconnect()});var y=ce(),U=r(y),F=r(U);Ct(F,{get template(){return C.template}});var Y=l(F,2);{var Q=e=>{var a=ae();M(()=>{x(a,"src",xt),x(a,"alt",n(_))}),d(e,a)},o=e=>{var a=se();M(()=>x(a,"src",At)),d(e,a)};A(Y,e=>{n(_)=="CONNECTED"?e(Q):e(o,!1)})}i(U);var u=l(U,2);{var v=e=>{var a=ie(),O=l(j(a),2),at=r(O);{var st=B=>{var N=ut(),rt=j(N);mt(rt,17,()=>n(c).filter(X=>X.height>0),Pt,(X,it)=>{var H=oe(),ct=r(H);ne(ct,pt({unlock:D},()=>n(it))),i(H),d(X,H)}),d(B,N)},ot=B=>{var N=re();d(B,N)};A(at,B=>{n(c).filter(N=>N.height>0).length>0?B(st):B(ot,!1)})}i(O),d(e,a)};A(u,e=>{n(c).length&&e(v)})}var K=l(u,2);qt(K),i(y),d(b,y),et()}export{Ie as component,xe as universal};
//# sourceMappingURL=4.B3c5BOqa.js.map
