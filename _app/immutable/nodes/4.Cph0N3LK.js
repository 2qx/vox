import{d as ra,e as nn,f as E,a as O,c as Bt,t as sn}from"../chunks/DTc5U4eY.js";import{c as rn,o as ya,a as on}from"../chunks/_R59KZhj.js";import{t as V,h as oa,d as ia,O as cn,aO as ln,w as ca,Z as un,aI as dn,aH as fn,l as mn,G as Et,aA as Ta,p as At,aP as ce,aQ as Ea,c as y,s as B,r as T,J as te,a as Nt,ak as P,v as he,a4 as R,I as t,f as ut,aR as rt,aS as la,af as Yt,aB as ke,ao as ua,ay as _n}from"../chunks/CQU5mOuk.js";import{e as ae,s as ee,d as Ua,h as pn}from"../chunks/CF3aPdyL.js";import{i as I}from"../chunks/CZ0rTjPC.js";import{e as Kt,i as Qt}from"../chunks/CbL2L94E.js";import{s as W}from"../chunks/-rOGAMhN.js";import{p as m,a as gn,b as On,c as hn,s as vn}from"../chunks/DBDCTY7c.js";import{p as kn}from"../chunks/SxaV7pye.js";import"../chunks/CuzQ0eOn.js";import{s as it}from"../chunks/CXfu__Ha.js";import{s as ct}from"../chunks/BfYLLTK_.js";import{b as Pn}from"../chunks/DTFErT7K.js";import{i as Ba}from"../chunks/DiAzQF1U.js";import{w as bn}from"../chunks/Cj-hKU-C.js";import{T as Aa}from"../chunks/otdWaXgM.js";import{B as Na,t as Ia}from"../chunks/B2Xzehbr.js";import{$ as da,a as fa}from"../chunks/BDt1pbpk.js";import{h as ma,W as yn,T as Tn,g as En,I as Un,B as Bn}from"../chunks/BTBIn4-B.js";import{j as An}from"../chunks/Bt3MikUi.js";import{h as J,g as Nn,d as Ca,e as In,M as _a,N as pa,t as Rt,O as Cn,P as wn,B as xn,Q as Rn,H as Fn,q as Ft,f as St,C as Sn,v as ga,D as Lt,b as mt,j as Ln,s as Mn,k as Oa}from"../chunks/BQUio51k.js";import{c as Vn}from"../chunks/DGwzT_kg.js";import{B as Dn}from"../chunks/BzLj6JBc.js";import{C as Yn}from"../chunks/B7hCbxZp.js";import{D as qn}from"../chunks/DMvn4Q5j.js";import{b as Hn}from"../chunks/B8sppVjI.js";import{T as Kn}from"../chunks/DxhSOfUG.js";function lt(r,e,n=!1,p=!1,v=!1){var i=r,_="";V(()=>{var h=cn;if(_===(_=e()??"")){oa&&ia();return}if(h.nodes_start!==null&&(ln(h.nodes_start,h.nodes_end),h.nodes_start=h.nodes_end=null),_!==""){if(oa){ca.data;for(var d=ia(),f=d;d!==null&&(d.nodeType!==8||d.data!=="");)f=d,d=un(d);if(d===null)throw dn(),fn;ra(ca,f),i=mn(d);return}var b=_+"";n?b=`<svg>${b}</svg>`:p&&(b=`<math>${b}</math>`);var A=nn(b);if((n||p)&&(A=Et(A)),ra(Et(A),A.lastChild),n||p)for(;Et(A);)i.before(Et(A));else i.before(A)}})}const Qn=()=>performance.now(),Fe={tick:r=>requestAnimationFrame(r),now:()=>Qn(),tasks:new Set};function wa(){const r=Fe.now();Fe.tasks.forEach(e=>{e.c(r)||(Fe.tasks.delete(e),e.f())}),Fe.tasks.size!==0&&Fe.tick(wa)}function Xn(r){let e;return Fe.tasks.size===0&&Fe.tick(wa),{promise:new Promise(n=>{Fe.tasks.add(e={c:r,f:n})}),abort(){Fe.tasks.delete(e)}}}function ha(r){return function(...e){var n=e[0];return n.preventDefault(),r?.apply(this,e)}}const Gn=!0,Rr=Object.freeze(Object.defineProperty({__proto__:null,prerender:Gn},Symbol.toStringTag,{value:"Module"}));var zn=E('<h3>About BadgerStake</h3> <p>Badgers is a proof-of-ownership memecoin on BitcoinCash.</p> <p>More information at <a href="https://badgers.cash/FAQ" rel="nofollow">Badgers.Cash</a></p>',1);function Wn(r){var e=zn();Ta(4),O(r,e)}function va(r){return Object.prototype.toString.call(r)==="[object Date]"}function qt(r,e,n,p){if(typeof n=="number"||va(n)){const v=p-n,i=(n-e)/(r.dt||1/60),_=r.opts.stiffness*v,h=r.opts.damping*i,d=(_-h)*r.inv_mass,f=(i+d)*r.dt;return Math.abs(f)<r.opts.precision&&Math.abs(v)<r.opts.precision?p:(r.settled=!1,va(n)?new Date(n.getTime()+f):n+f)}else{if(Array.isArray(n))return n.map((v,i)=>qt(r,e[i],n[i],p[i]));if(typeof n=="object"){const v={};for(const i in n)v[i]=qt(r,e[i],n[i],p[i]);return v}else throw new Error(`Cannot spring ${typeof n} values`)}}function jn(r,e={}){const n=bn(r),{stiffness:p=.15,damping:v=.8,precision:i=.01}=e;let _,h,d,f=r,b=r,A=1,le=0,g=!1;function c(s,D={}){b=s;const M=d={};return r==null||D.hard||k.stiffness>=1&&k.damping>=1?(g=!0,_=Fe.now(),f=s,n.set(r=b),Promise.resolve()):(D.soft&&(le=1/((D.soft===!0?.5:+D.soft)*60),A=0),h||(_=Fe.now(),g=!1,h=Xn(ne=>{if(g)return g=!1,h=null,!1;A=Math.min(A+le,1);const se=Math.min(ne-_,1e3/30),x={inv_mass:A,opts:k,settled:!0,dt:se*60/1e3},ue=qt(x,f,r,b);return _=ne,f=r,n.set(r=ue),x.settled&&(h=null),!x.settled})),new Promise(ne=>{h.promise.then(()=>{M===d&&ne()})}))}const k={set:c,update:(s,D)=>c(s(b,r),D),subscribe:n.subscribe,stiffness:p,damping:v,precision:i};return k}function ot(r){return typeof r=="number"&&!isNaN(r)&&isFinite(r)}const Ee=(r,e=2)=>parseFloat((+r).toFixed(e)),ka=function(r,e,n){return r<=e?e:r>=n?n:r},Ye=function(r,e,n,p=2){let v=(r-e)/(n-e)*100;return isNaN(v)||v<=0?0:v>=100?100:Ee(v,p)},Jn=function(r,e,n){return(n-e)/100*r+e},Ge=function(r,e,n,p,v=2,i=null){if(r=ot(r)?r:i?.[0]??e,r<=(i?.[0]??e)||r>=(i?.[1]??n))return r=ka(r,i?.[0]??e,i?.[1]??n);let _=(r-e)%p,h=r-_;return Math.abs(_)*2>=p?h+=_>0?p:-p:r>=n-_&&(h=n),h=ka(h,i?.[0]??e,i?.[1]??n),Ee(h,v)},Zn=(r="")=>`${r}`.replace(/<[^>]*>/g,""),_t=r=>{const{clientX:e,clientY:n}="touches"in r?r.touches[0]||r.changedTouches[0]:r;return{x:e,y:n}},Pa=r=>{if(!r)return-1;for(var e=0;r=r.previousElementSibling;)e++;return e},Mt=(r,e,n)=>{if(n==="min")return e[0]>r;if(n==="max")return e[0]<r;if(n)return e[0]<r&&e[1]>r},Vt=(r,e)=>e?r<e[0]||r>e[1]:!1,Dt=(r,e,n=2)=>e.some(p=>Ee(p,n)===Ee(r,n)),$n=(r,e,n,p,v,i=2)=>Ee(e+r*v*p,i),Ut=(r,e,n,p,v,i)=>{const _=r.getBoundingClientRect();let h=0,d=0,f=0;return n?(h=e.y-_.top,d=h/_.height*100,d=p?d:100-d):(h=e.x-_.left,d=h/_.width*100,d=p?100-d:d),f=Jn(d,v,i),{pointerVal:f,pointerPercent:d}};var es=E('<span class="rsPipValPrefix"> </span>'),ts=E('<span class="rsPipValSuffix"> </span>'),as=E('<span class="rsPipVal"><!> <!> <!></span>'),ns=E("<span><!></span>"),ss=E('<span class="rsPipValPrefix"> </span>'),rs=E('<span class="rsPipValSuffix"> </span>'),os=E('<span class="rsPipVal"><!> <!> <!></span>'),is=E("<span><!></span>"),cs=E('<span class="rsPipValPrefix"> </span>'),ls=E('<span class="rsPipValSuffix"> </span>'),us=E('<span class="rsPipVal"><!> <!> <!></span>'),ds=E("<span><!></span>"),fs=E("<div><!> <!> <!></div>");function ms(r,e){At(e,!1);const n=he(),p=he();let v=m(e,"range",8,!1),i=m(e,"min",8,0),_=m(e,"max",8,100),h=m(e,"step",8,1),d=m(e,"value",24,()=>(_()+i())/2),f=m(e,"values",24,()=>[d()]),b=m(e,"vertical",8,!1),A=m(e,"reversed",8,!1),le=m(e,"hoverable",8,!0),g=m(e,"disabled",8,!1),c=m(e,"limits",8,null),k=m(e,"pipstep",8,void 0),s=m(e,"all",8,!0),D=m(e,"first",8,void 0),M=m(e,"last",8,void 0),ne=m(e,"rest",8,void 0),se=m(e,"prefix",8,""),x=m(e,"suffix",8,""),ue=m(e,"formatter",8,(G,Y,re)=>G),C=m(e,"precision",8,2),N=m(e,"focus",8),w=m(e,"orientationStart",8),Q=m(e,"moveHandle",8),me=null,Ue=he(0);const tt=500;let _e=he(1);function Se(G){me=_t(G)}function qe(G,Y){const re=_t(Y);!g()&&me&&(Math.sqrt(Math.pow(me.x-re.x,2)+Math.pow(me.y-re.y,2))<=5&&Q()(null,G),me=null)}ce(()=>R(b()),()=>{P(n,b()?50:100)}),ce(()=>(R(_()),R(i()),R(h()),t(n)),()=>{P(p,(_()-i())/h()>=t(n))}),ce(()=>(t(_e),R(k()),t(p),R(_()),R(i()),t(n),t(Ue),R(h())),()=>{if(P(_e,k()??(t(p)?(_()-i())/(t(n)/5):1)),P(Ue,Math.ceil((_()-i())/(h()*t(_e)))),t(Ue)>tt)for(console.warn('RangePips: You are trying to render too many pips. This will cause performance issues. Try increasing the "pipstep" prop to reduce the number of pips shown.');t(Ue)>=tt;)P(_e,t(_e)+t(_e)),P(Ue,Math.ceil((_()-i())/(h()*t(_e))))}),Ea(),Ba();var de=fs();let Pe;var be=y(de);{var we=G=>{var Y=ns();let re;W(Y,"data-index",0);var xe=y(Y);{var Me=q=>{var u=as(),l=y(u);{var K=S=>{var H=es(),F=y(H,!0);T(H),V(()=>ee(F,se())),O(S,H)};I(l,S=>{se()&&S(K)})}var oe=B(l,2);lt(oe,()=>ue()(Ee(i(),C()),0,0));var j=B(oe,2);{var z=S=>{var H=ts(),F=y(H,!0);T(H),V(()=>ee(F,x())),O(S,H)};I(j,S=>{x()&&S(z)})}T(u),O(q,u)};I(xe,q=>{(s()==="label"||D()==="label")&&q(Me)})}T(Y),V((q,u)=>{re=it(Y,1,"rsPip rsPip--first",null,re,q),ct(Y,`${w()??""}: 0%;`),W(Y,"data-val",u)},[()=>({rsSelected:Dt(i(),f(),C()),rsInRange:Mt(i(),f(),v()),rsOutOfLimit:Vt(i(),c())}),()=>Ee(i(),C())],te),ae("pointerdown",Y,q=>{Se(q)}),ae("pointerup",Y,q=>{qe(i(),q)}),O(G,Y)};I(be,G=>{(s()&&D()!==!1||D())&&G(we)})}var ye=B(be,2);{var Le=G=>{var Y=Bt(),re=ut(Y);Kt(re,1,()=>Array(t(Ue)),Qt,(xe,Me,q)=>{var u=Bt();const l=te(()=>$n(q,i(),_(),t(_e),h(),C()));var K=ut(u);{var oe=j=>{var z=is();let S;W(z,"data-index",q);var H=y(z);{var F=Z=>{var ie=os(),Be=y(ie);{var ve=Ae=>{var Ne=ss(),We=y(Ne,!0);T(Ne),V(()=>ee(We,se())),O(Ae,Ne)};I(Be,Ae=>{se()&&Ae(ve)})}var dt=B(Be,2);lt(dt,()=>ue()(t(l),q,Ye(t(l),i(),_(),C())));var gt=B(dt,2);{var ze=Ae=>{var Ne=rs(),We=y(Ne,!0);T(Ne),V(()=>ee(We,x())),O(Ae,Ne)};I(gt,Ae=>{x()&&Ae(ze)})}T(ie),O(Z,ie)};I(H,Z=>{(s()==="label"||ne()==="label")&&Z(F)})}T(z),V((Z,ie)=>{S=it(z,1,"rsPip",null,S,Z),ct(z,`${w()??""}: ${ie??""}%;`),W(z,"data-val",t(l))},[()=>({rsSelected:Dt(t(l),f(),C()),rsInRange:Mt(t(l),f(),v()),rsOutOfLimit:Vt(t(l),c())}),()=>Ye(t(l),i(),_(),C())],te),ae("pointerdown",z,Z=>{Se(Z)}),ae("pointerup",z,Z=>{qe(t(l),Z)}),O(j,z)};I(K,j=>{t(l)>i()&&t(l)<_()&&j(oe)})}O(xe,u)}),O(G,Y)};I(ye,G=>{(s()&&ne()!==!1||ne())&&G(Le)})}var at=B(ye,2);{var pt=G=>{var Y=ds();let re;var xe=y(Y);{var Me=q=>{var u=us(),l=y(u);{var K=S=>{var H=cs(),F=y(H,!0);T(H),V(()=>ee(F,se())),O(S,H)};I(l,S=>{se()&&S(K)})}var oe=B(l,2);lt(oe,()=>ue()(Ee(_(),C()),t(Ue),100));var j=B(oe,2);{var z=S=>{var H=ls(),F=y(H,!0);T(H),V(()=>ee(F,x())),O(S,H)};I(j,S=>{x()&&S(z)})}T(u),O(q,u)};I(xe,q=>{(s()==="label"||M()==="label")&&q(Me)})}T(Y),V((q,u)=>{re=it(Y,1,"rsPip rsPip--last",null,re,q),ct(Y,`${w()??""}: 100%;`),W(Y,"data-val",u),W(Y,"data-index",t(Ue))},[()=>({rsSelected:Dt(_(),f(),C()),rsInRange:Mt(_(),f(),v()),rsOutOfLimit:Vt(_(),c())}),()=>Ee(_(),C())],te),ae("pointerdown",Y,q=>{Se(q)}),ae("pointerup",Y,q=>{qe(_(),q)}),O(G,Y)};I(at,G=>{(s()&&M()!==!1||M())&&G(pt)})}T(de),V(G=>Pe=it(de,1,"rangePips",null,Pe,G),[()=>({rsDisabled:g(),rsHoverable:le(),rsVertical:b(),rsReversed:A(),rsFocus:N()})],te),O(r,de),Nt()}var _s=E('<span class="rangeFloatPrefix"> </span>'),ps=E('<span class="rangeFloatSuffix"> </span>'),gs=E('<span class="rangeFloat"><!><!><!></span>'),Os=E('<span role="slider"><span class="rangeNub"></span> <!></span>'),hs=E('<span class="rangeLimit"></span>'),vs=E('<span class="rangeFloatPrefix"> </span>'),ks=E('<span class="rangeFloatSuffix"> </span>'),Ps=E('<span class="rangeFloatPrefix"> </span>'),bs=E('<span class="rangeFloatSuffix"> </span>'),ys=E("<!><!><!> <!><!><!>",1),Ts=E('<span class="rangeFloat"><!></span>'),Es=E("<span><!></span>"),Us=E('<div role="none"><!> <!> <!> <!></div>');function ba(r,e){At(e,!1);const[n,p]=On(),v=()=>gn(t(ve),"$springPositions",n),i=he(),_=he(),h=he();let d=m(e,"slider",12,void 0),f=m(e,"precision",8,2),b=m(e,"range",8,!1),A=m(e,"pushy",8,!1),le=m(e,"draggy",8,!1),g=m(e,"min",12,0),c=m(e,"max",12,100),k=m(e,"step",12,1),s=m(e,"values",28,()=>[Ee((c()+g())/2,f())]),D=m(e,"value",28,()=>s()[0]),M=m(e,"vertical",8,!1),ne=m(e,"float",8,!1),se=m(e,"rangeFloat",8,!1),x=m(e,"reversed",8,!1),ue=m(e,"hoverable",8,!0),C=m(e,"disabled",8,!1),N=m(e,"limits",8,null),w=m(e,"rangeGapMin",12,0),Q=m(e,"rangeGapMax",12,1/0),me=m(e,"pips",8,!1),Ue=m(e,"pipstep",8,void 0),tt=m(e,"all",8,!0),_e=m(e,"first",8,void 0),Se=m(e,"last",8,void 0),qe=m(e,"rest",8,void 0),de=m(e,"prefix",8,""),Pe=m(e,"suffix",8,""),be=m(e,"formatter",12,(a,o,U)=>a),we=m(e,"handleFormatter",28,be),ye=m(e,"rangeFormatter",12,null),Le=m(e,"ariaLabels",28,()=>[]),at=m(e,"id",8,void 0),pt=m(e,"class",8,""),G=m(e,"style",8,void 0),Y=m(e,"darkmode",8,!1),re=m(e,"springValues",24,()=>({stiffness:.15,damping:.4})),xe=m(e,"spring",8,!0);const Me=rn();let q=he(!1),u=he(0),l=he(!1),K=!1,oe=he(!1),j=!1,z=he(!1),S=[1,1],H=!1,F=he(-1),Z=[],ie=[],Be=he(0),ve=he();const dt=()=>{Ne(),s()[0]!==D()&&s(s()[0]=D(),!0)},gt=()=>{Ae(),D()!==s()[0]&&D(s()[0])},ze=()=>{ot(g())||(g(0),console.error("'min' prop must be a valid finite Number")),ot(c())||(c(100),console.error("'max' prop must be a valid finite Number")),g()>=c()&&(g(0),c(100),console.error("'min' prop should be less than 'max'")),g(Ee(g(),f())),c(Ee(c(),f()))},Ae=()=>{ot(D())||(D((c()+g())/2),console.error("'value' prop should be a Number"))},Ne=()=>{Array.isArray(s())?s().some(a=>!ot(a))&&(s(s().map(a=>ot(a)?a:(c()+g())/2)),console.error("'values' prop should be an Array of Numbers")):(s([D()]),console.error("'values' prop should be an Array"))},We=()=>{(!ot(k())||k()<=0)&&(k(1),console.error("'step' prop must be a positive Number"))},X=()=>{s().length>1&&!Array.isArray(Le())&&(Le([]),console.warn("'ariaLabels' prop should be an Array"))},fe=()=>{if(s(s().map(a=>Ge(a,g(),c(),k(),f(),N()))),w()<0&&w(0),Q()<0&&Q(1/0),w()>Q()&&w(Q()),Q()<1/0){const a=Ge(s()[0]+Q(),g(),c(),k(),f(),N());s()[1]>a&&s(s()[1]=a,!0)}if(w()>0){const a=Ge(s()[0]+w(),g(),c(),k(),f(),N());s()[1]<a&&s(s()[1]=a,!0)}},je=()=>{(be()===null||be()===void 0)&&(console.error("formatter must be a function"),be((a,o,U)=>a)),(we()===null||we()===void 0)&&(console.error("handleFormatter must be a function"),we(be())),ye()===void 0&&(console.error("rangeFormatter must be a function, or null"),ye(null))};ze(),Ae(),Ne(),We(),fe(),je();const Ot=a=>{hn(P(ve,jn(a.map(o=>Ye(o,g(),c())),re())),"$springPositions",n)},pe=a=>{requestAnimationFrame(()=>{t(ve).set(a.map(o=>Ye(o,g(),c())),{hard:!xe()})})},Te=()=>{t(ve)&&(la(ve,t(ve).stiffness=re().stiffness??.15),la(ve,t(ve).damping=re().damping??.4))};function Je(a){return requestAnimationFrame(()=>{if(a){const o=a.getBoundingClientRect();P(Be,M()?o.height:o.width)}})}let He,Ve;ya(()=>(d()&&(He=new ResizeObserver(a=>{Ve&&cancelAnimationFrame(Ve),Ve=Je(a[0].target)}),He.observe(d()),setTimeout(()=>{P(q,!0)},16)),()=>{Ve&&cancelAnimationFrame(Ve),He?.disconnect?.(),P(q,!1)}));function It(a){if(!d())return!1;const o=d().querySelectorAll(".handle"),U=Array.prototype.includes.call(o,a),$=Array.prototype.some.call(o,L=>L.contains(a));return U||$}function xa(a,o){return o==="min"||o==="max"?a.slice(0,1):o?a.slice(0,2):a}function Ra(a){if(!d())return 0;const{pointerVal:o}=Ut(d(),a,M(),x(),g(),c());let U=0;return b()===!0&&s()[0]===s()[1]?o>s()[1]?U=1:U=0:U=s().indexOf([...s()].sort(($,L)=>Math.abs(o-$)-Math.abs(o-L))[0]),U}function Ct(a){if(!d()||!K)return;const{pointerVal:o}=Ut(d(),a,M(),x(),g(),c());Ze(t(F),o)}function Fa(a){if(!d()||!le()||!j||b()==="min"||b()==="max")return;const{pointerVal:o}=Ut(d(),a,M(),x(),g(),c());S=[s()[0]-o,s()[1]-o]}function Sa(a){if(!d()||!le()||!j||b()==="min"||b()==="max")return;const{pointerVal:o}=Ut(d(),a,M(),x(),g(),c());P(F,-1),Ze(0,o+S[0],!1),Ze(1,o+S[1],!0)}function Ze(a,o,U=!0){return o=Ge(o,g(),c(),k(),f(),N()),a===null&&(a=t(F)),b()===!0&&(a===0?o>s()[1]-w()?A()&&o<=(N()?.[1]??c())-w()?s(s()[1]=o+w(),!0):o=s()[1]-w():o<s()[1]-Q()&&(A()?s(s()[1]=o+Q(),!0):o=s()[1]-Q()):a===1&&(o<s()[0]+w()?A()&&o>=(N()?.[0]??g())+w()?s(s()[0]=o-w(),!0):o=s()[0]+w():o>s()[0]+Q()&&(A()?s(s()[0]=o-Q(),!0):o=s()[0]+Q()))),s()[a]!==o&&s(s()[a]=Ge(o,g(),c(),k(),f(),N()),!0),U&&La(s()),o}function La(a){(ie.some((U,$)=>U!==a[$])||ie.length!==a.length)&&(Ga(),ie=[...a])}function Ma(a){return b()==="min"?0:a[0]}function Va(a){return b()==="max"?100:b()==="min"?a[0]:a[1]}function Da(a){a.target,H&&(P(l,!1),K=!1,P(oe,!1),j=!1,P(z,!1))}function Ya(a){const o=a.target;C()||(P(F,Pa(o)),P(l,!0))}function qa(a){if(!C()){let o=!1;const U=Pa(a.target);let $=k();if(a.ctrlKey||a.metaKey){const L=(c()-g())/100;$=Math.max(k(),Math.round(L/k())*k())}else if(a.shiftKey||a.key==="PageUp"||a.key==="PageDown"){const L=(c()-g())/10;$=Math.max(k(),Math.round(L/k())*k())}switch(a.key){case"PageUp":case"ArrowRight":case"ArrowUp":ht(),Ze(U,s()[U]+$),o=!0;break;case"PageDown":case"ArrowLeft":case"ArrowDown":ht(),Ze(U,s()[U]-$),o=!0;break;case"Home":ht(),Ze(U,g()),o=!0;break;case"End":ht(),Ze(U,c()),o=!0;break}o&&(a.preventDefault(),a.stopPropagation())}}function ht(){Z=s().map(a=>Ge(a,g(),c(),k(),f(),N())),ie=[...Z]}function Xt(a){if(!C()){const o=a.target,U=_t(a);P(l,!0),o.matches(".rangeBar")&&b()===!0&&le()?(K=!1,P(oe,!1),P(F,-1),j=!0,P(z,!0),Fa(U)):(K=!0,P(oe,!0),P(F,Ra(U)),a.type==="touchstart"&&!o.closest(".rsPipVal")&&Ct(U)),ht(),Xa()}}function Gt(a){a.type==="touchend"&&jt(),P(oe,!1),P(z,!1)}function zt(a){const o=a.target;H=!1,d()&&t(l)&&o!==d()&&!d().contains(o)&&P(l,!1)}function Wt(a){C()||(K?Ct(_t(a)):j&&Sa(_t(a)))}function Ha(a){if(!C()){const o=a.target;K&&d()&&(o===d()||d().contains(o))&&(P(l,!0),!It(o)&&!o.closest(".rsPipVal")&&Ct(_t(a))),(K||j)&&jt()}K=!1,P(oe,!1),j=!1,P(z,!1)}function Ka(a){K=!1,P(oe,!1),j=!1,P(z,!1)}function Qa(a){const o=a.target;!C()&&d()&&(o===d()||d().contains(o))&&(H=!0)}function Xa(){C()||Me("start",{activeHandle:t(F),value:Z[t(F)],values:Z})}function jt(){if(C())return;const a=j?Z:Z[t(F)];Me("stop",{activeHandle:t(F),startValue:a,value:s()[t(F)],values:s().map(o=>Ge(o,g(),c(),k(),f(),N()))})}function Ga(){if(C())return;const a=j?Z:Z[t(F)],o=ie.length===0?a:j?ie:ie[t(F)];Me("change",{activeHandle:t(F),startValue:a,previousValue:o,value:s()[t(F)],values:s().map(U=>Ge(U,g(),c(),k(),f(),N()))})}function za(a,o){const U=Ye(a,g(),c(),f()),$=we()(a,o,U),L=Zn(String($));return`${de()}${L}${Pe()}`}ce(()=>R(D()),()=>{D(),dt()}),ce(()=>(R(b()),R(g()),R(c()),R(k()),R(f()),R(N()),t(u),R(d()),R(s()),R(D())),()=>{((a,o)=>{const $=xa(a,b()).map(L=>Ge(L,g(),c(),k(),f(),N()));(a.length!==$.length||!a.every((L,vt)=>Ee(L,f())===$[vt]))&&(a=$),t(u)!==a.length?Ot(a):d()&&pe(a),s(a),P(u,a.length)})(s(),D())}),ce(()=>R(s()),()=>{s(),gt()}),ce(()=>R(Le()),()=>{Le(),X()}),ce(()=>R(g()),()=>{g(),ze()}),ce(()=>R(c()),()=>{c(),ze()}),ce(()=>R(k()),()=>{k(),We()}),ce(()=>R(w()),()=>{w(),fe()}),ce(()=>R(Q()),()=>{Q(),fe()}),ce(()=>R(be()),()=>{be(),je()}),ce(()=>R(we()),()=>{we(),je()}),ce(()=>R(ye()),()=>{ye(),je()}),ce(()=>R(re()),()=>{re(),Te()}),ce(()=>(R(b()),R(s())),()=>{P(i,b()===!0&&s().length===2||(b()==="min"||b()==="max")&&s().length===1)}),ce(()=>(R(M()),R(x())),()=>{P(_,M()?x()?"top":"bottom":x()?"right":"left")}),ce(()=>(R(M()),R(x())),()=>{P(h,M()?x()?"bottom":"top":x()?"left":"right")}),Ea(),Ba();var Re=Us();ae("mousedown",rt,zt),ae("touchstart",rt,zt),ae("mousemove",rt,Wt),ae("touchmove",rt,Wt),ae("mouseup",rt,Ha),ae("touchend",rt,Ka),ae("keydown",rt,Qa);let Jt;var Zt=y(Re);Kt(Zt,1,s,Qt,(a,o,U,$)=>{var L=Os();const vt=te(()=>t(l)&&t(F)===U?"z-index: 3; ":""),kt=te(()=>t(q)?"":"opacity: 0; ");let Pt;W(L,"data-handle",U);var wt=B(y(L),2);{var nt=Ke=>{var $e=gs();const bt=te(()=>Ye(t(o),g(),c(),f())),et=te(()=>we()(t(o),U,t(bt)));var yt=y($e);{var xt=Ie=>{var Xe=_s(),ft=y(Xe,!0);T(Xe),V(()=>ee(ft,de())),O(Ie,Xe)};I(yt,Ie=>{de()&&Ie(xt)})}var Tt=B(yt);lt(Tt,()=>t(et));var De=B(Tt);{var Qe=Ie=>{var Xe=ps(),ft=y(Xe,!0);T(Xe),V(()=>ee(ft,Pe())),O(Ie,Xe)};I(De,Ie=>{Pe()&&Ie(Qe)})}T($e),O(Ke,$e)};I(wt,Ke=>{ne()&&Ke(nt)})}T(L),V((Ke,$e)=>{Pt=it(L,1,"rangeHandle",null,Pt,Ke),ct(L,`--handle-pos: ${v()[U]};${t(vt)}${t(kt)}`),W(L,"aria-label",Le()[U]),W(L,"aria-valuemin",b()===!0&&U===1?s()[0]:g()),W(L,"aria-valuemax",b()===!0&&U===0?s()[1]:c()),W(L,"aria-valuenow",t(o)),W(L,"aria-valuetext",$e),W(L,"aria-orientation",M()?"vertical":"horizontal"),W(L,"aria-disabled",C()),W(L,"tabindex",C()?-1:0)},[()=>({rsActive:t(l)&&t(F)===U,rsPress:t(oe)&&t(F)===U}),()=>za(t(o),U)],te),ae("blur",L,Da),ae("focus",L,Ya),ae("keydown",L,qa),O(a,L)});var $t=B(Zt,2);{var Wa=a=>{var o=hs();V((U,$)=>ct(o,`${t(_)??""}: ${U??""}%;
             ${t(h)??""}: ${$??""}%;`),[()=>Ye(N()[0],g(),c(),f()),()=>100-Ye(N()[1],g(),c(),f())],te),O(a,o)};I($t,a=>{N()&&a(Wa)})}var ea=B($t,2);{var ja=a=>{var o=Es();const U=te(()=>Ma(v())),$=te(()=>Va(v())),L=te(()=>t($)-t(U)),vt=te(()=>t(q)?"":"opacity: 0; ");let kt;var Pt=y(o);{var wt=nt=>{var Ke=Ts();const $e=te(()=>b()==="min"?g():s()[0]),bt=te(()=>b()==="max"?c():b()==="min"?s()[0]:s()[1]),et=te(()=>{const[De,Qe]=x()?[t(bt),t($e)]:[t($e),t(bt)];return{first:De,second:Qe}});var yt=y(Ke);{var xt=De=>{var Qe=Bt(),Ie=ut(Qe);lt(Ie,()=>ye()(t(et).first,t(et).second,Ye(t(et).first,g(),c(),f()),Ye(t(et).second,g(),c(),f()))),O(De,Qe)},Tt=De=>{var Qe=ys(),Ie=ut(Qe);{var Xe=ge=>{var Oe=vs(),st=y(Oe,!0);T(Oe),V(()=>ee(st,de())),O(ge,Oe)};I(Ie,ge=>{de()&&ge(Xe)})}var ft=B(Ie);lt(ft,()=>t(et).first);var ta=B(ft);{var $a=ge=>{var Oe=ks(),st=y(Oe,!0);T(Oe),V(()=>ee(st,Pe())),O(ge,Oe)};I(ta,ge=>{Pe()&&ge($a)})}var aa=B(ta);aa.nodeValue="  -  ";var na=B(aa);{var en=ge=>{var Oe=Ps(),st=y(Oe,!0);T(Oe),V(()=>ee(st,de())),O(ge,Oe)};I(na,ge=>{de()&&ge(en)})}var sa=B(na);lt(sa,()=>t(et).second);var tn=B(sa);{var an=ge=>{var Oe=bs(),st=y(Oe,!0);T(Oe),V(()=>ee(st,Pe())),O(ge,Oe)};I(tn,ge=>{Pe()&&ge(an)})}O(De,Qe)};I(yt,De=>{ye()?De(xt):De(Tt,!1)})}T(Ke),O(nt,Ke)};I(Pt,nt=>{se()&&nt(wt)})}T(o),V(nt=>{kt=it(o,1,"rangeBar",null,kt,nt),ct(o,`--range-start:${t(U)};--range-end:${t($)};--range-size:${t(L)};${t(vt)};`)},[()=>({rsPress:t(z)})],te),O(a,o)};I(ea,a=>{t(i)&&a(ja)})}var Ja=B(ea,2);{var Za=a=>{ms(a,{get values(){return s()},get min(){return g()},get max(){return c()},get step(){return k()},get range(){return b()},get vertical(){return M()},get reversed(){return x()},get orientationStart(){return t(_)},get hoverable(){return ue()},get disabled(){return C()},get limits(){return N()},get all(){return tt()},get first(){return _e()},get last(){return Se()},get rest(){return qe()},get pipstep(){return Ue()},get prefix(){return de()},get suffix(){return Pe()},get formatter(){return be()},get precision(){return f()},get focus(){return t(l)},moveHandle:Ze})};I(Ja,a=>{me()&&a(Za)})}T(Re),Pn(Re,a=>d(a),()=>d()),V(a=>{W(Re,"id",at()),Jt=it(Re,1,`rangeSlider ${pt()??""}`,null,Jt,a),ct(Re,`--slider-length: ${t(Be)};${G()??""}`)},[()=>({rsDark:Y()==="force",rsAutoDark:Y()==="auto",rsRange:t(i),rsDrag:t(i)&&le(),rsMin:t(i)&&b()==="min",rsMax:t(i)&&b()==="max",rsDisabled:C(),rsHoverable:ue(),rsVertical:M(),rsReversed:x(),rsFocus:t(l),rsPips:me(),rsPipLabels:tt()==="label"||_e()==="label"||Se()==="label"||qe()==="label"})],te),ae("mousedown",Re,Xt),ae("mouseup",Re,Gt),ae("touchstart",Re,ha(Xt)),ae("touchend",Re,ha(Gt)),O(r,Re),Nt(),p()}const Bs="https://libauth.org/schemas/wallet-template-v0.schema.json",As="BadgerStake: a staking contract to earn Badger tokens.",Ns="BadgerStake",Is={covenant:{description:"BadgerStake holds undistributed BadgerCoins on the MasterBadger NFT as well as staked coins.",name:"Badger Vault",scripts:["unlock","stake","lock","administer"],variables:{amount:{description:"Stake amount.",name:"Amount",type:"WalletData"},authentication_category:{description:"The category of the badger token authenticating new stakes.",name:"Authenticating Token Category",type:"WalletData"},stake_blocks:{description:"The duration of the staking period (in blocks)",name:"Stake Blocks",type:"WalletData"},new_fee:{description:"The current fee setting of the badger vault.",name:"Fee",type:"WalletData"},user_pkh:{description:"The key that controls user funds.",name:"User",type:"WalletData"},admin_pkh:{description:"The key administering this covenant.",name:"Admin",type:"WalletData"}}},wallet:{description:"Standard p2pkh wallet controlling the stake baton",name:"Stake Owner",scripts:["wallet_unlock","wallet_lock"],variables:{key:{description:"The private key that controls this wallet.",name:"Key",type:"HdKey"}}}},Cs={base:{data:{bytecode:{new_fee:"1000",authentication_category:"0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24"}},description:"",name:"Base Scenario"},stake:{data:{bytecode:{stake_blocks:"5000",amount:"400000",new_fee:"1000",user_pkh:"0xbe7f0bcf860657ce2fdb6f047141faa39e50f224",authentication_category:"0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24"}},description:"Lock coins in the Badger Vault",extends:"base",name:"Lock Assets",transaction:{inputs:[{unlockingBytecode:["slot"]},{}],outputs:[{lockingBytecode:{script:"lock"},valueSatoshis:335e3,token:{amount:"9223372036854412287",category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",nft:{capability:"minting",commitment:"e8030000000000000000000000000000000000002770188a88f75360d1e956d7ff290ef1e0f56787"}}},{lockingBytecode:{script:"lock"},valueSatoshis:4e5,token:{amount:20,category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",nft:{capability:"mutable",commitment:"be7f0bcf860657ce2fdb6f047141faa39e50f2240000000000000000000000000000000000008813"}}},{lockingBytecode:"76a914be7f0bcf860657ce2fdb6f047141faa39e50f22488ac",valueSatoshis:2713641}],version:2},sourceOutputs:[{lockingBytecode:["slot"],valueSatoshis:334e3,token:{category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",amount:"9223372036854412307",nft:{commitment:"e8030000000000000000000000000000000000002770188a88f75360d1e956d7ff290ef1e0f56787",capability:"minting"}}},{valueSatoshis:42715641}]},unlock:{data:{bytecode:{stake_blocks:"5000",amount:"400000",new_fee:"1000",user_pkh:"0xbe7f0bcf860657ce2fdb6f047141faa39e50f224",authentication_category:"0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24"}},description:"",extends:"base",name:"Release Assets",transaction:{inputs:[{unlockingBytecode:["slot"],sequenceNumber:5e3}],outputs:[{lockingBytecode:"76a914be7f0bcf860657ce2fdb6f047141faa39e50f22488ac",valueSatoshis:1e3,token:{amount:20,category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7"}},{lockingBytecode:"76a914be7f0bcf860657ce2fdb6f047141faa39e50f22488ac",valueSatoshis:1e3,token:{category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",amount:0,nft:{capability:"none",commitment:"000014"}}},{lockingBytecode:"76a914be7f0bcf860657ce2fdb6f047141faa39e50f22488ac",valueSatoshis:397e3}],version:2},sourceOutputs:[{lockingBytecode:["slot"],valueSatoshis:4e5,token:{category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",amount:20,nft:{commitment:"be7f0bcf860657ce2fdb6f047141faa39e50f2240000000000000000000000000000000000008813",capability:"mutable"}}}]},withdraw:{description:"Administer the current fee, ",extends:"base",name:"Withdraw accumulated fees and adjust anti-spam fee",transaction:{inputs:[{unlockingBytecode:["slot"],sequenceNumber:10},{unlockingBytecode:{script:["copy"]}}],outputs:[{lockingBytecode:{script:"lock"},valueSatoshis:1e3,token:{amount:"9223372036854412287",category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",nft:{capability:"minting",commitment:"e8030000000000000000000000000000000000002770188a88f75360d1e956d7ff290ef1e0f56787"}}},{lockingBytecode:"76a9142770188a88f75360d1e956d7ff290ef1e0f5678788ac",valueSatoshis:330800}],version:2},sourceOutputs:[{lockingBytecode:["slot"],valueSatoshis:332e3,token:{category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",amount:"9223372036854412287",nft:{commitment:"e8030000000000000000000000000000000000002770188a88f75360d1e956d7ff290ef1e0f56787",capability:"minting"}}},{lockingBytecode:"76a9142770188a88f75360d1e956d7ff290ef1e0f5678788ac",valueSatoshis:800}]}},ws=JSON.parse(`{"stake":{"passes":["stake"],"name":"0: Lock","script":" <user_pkh> <stake_blocks> <amount>  OP_0","unlocks":"lock"},"wallet_unlock":{"passes":["stake"],"name":"Wallet Unlock","script":"<key.schnorr_signature.all_outputs> <key.public_key>","unlocks":"wallet_lock"},"unlock":{"passes":["unlock"],"name":"1: Unlock","script":"OP_1","unlocks":"lock"},"administer":{"passes":["withdraw"],"name":"2: Administer","script":"<new_fee> OP_2 ","unlocks":"lock"},"wallet_lock":{"lockingType":"standard","name":"Wallet Lock","script":"OP_DUP OP_HASH160 <$(<key.public_key> OP_HASH160)> OP_EQUALVERIFY OP_CHECKSIG"},"lock":{"lockingType":"p2sh32","name":"BadgerStake Covenant","script":"\\n// pragma cashscript ^0.10.0;\\n\\n// contract BadgerStake() {\\n\\n//     /////////////////////////////////////////////\\n//     //inputs:\\n//     //  0   masterBadger        [NFT]   (from contract)\\n//     //  1   userUTXO            [BCH]   (from user)\\n//     //outputs:\\n//     //  0   masterBadger        [NFT]   (to contract)\\n//     //  1   lockUTXO            [NFT]   (to contract)\\n//     //  2   {optional} change   [BCH]   (to user)\\n//     /////////////////////\\n//     //parameters:\\n//     //  amount: BCH amount user wants to lock up\\n//     //  stakeBlocks: number of blocks to be locked up for\\n//     //  pubkeyhash: a pubkeyhash, used to send the locked BCH back to the users address\\n//     /////////////////////////////////////////////\\n\\n       OP_DUP OP_0 OP_NUMEQUAL OP_IF \\n//     function lock(int amount, int stakeBlocks, bytes20 pubkeyhash) {\\n\\n//       // this contract must be input0\\n         OP_INPUTINDEX OP_0 OP_NUMEQUALVERIFY \\n//       require(this.activeInputIndex == 0);\\n\\n//       // must have exactly 2 inputs\\n         OP_TXINPUTCOUNT OP_2 OP_NUMEQUALVERIFY \\n//       require(tx.inputs.length == 2);\\n\\n//       // must have 3 or less outputs\\n         OP_TXOUTPUTCOUNT OP_3 OP_LESSTHANOREQUAL OP_VERIFY \\n//       require(tx.outputs.length <= 3);\\n\\n//       // cannot lock for longer than 65536 blocks\\n         OP_2 OP_PICK <65536> OP_LESSTHANOREQUAL OP_VERIFY \\n//       require(stakeBlocks <= 65536);\\n\\n//       // minimum 5000 sats to lock so have enough for unlock()\\n         OP_OVER <5000> OP_GREATERTHANOREQUAL OP_VERIFY \\n//       require(amount >= 5000);\\n\\n//       // input0 must be masterBadger NFT\\n         OP_0 OP_UTXOTOKENCATEGORY <authentication_category> OP_2 OP_CAT OP_EQUALVERIFY\\n//       require(tx.inputs[0].tokenCategory == 0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24 + 0x02);\\n\\n//       // input1 must be BCH with no tokens\\n         OP_1 OP_UTXOTOKENCATEGORY OP_0 OP_EQUALVERIFY \\n//       require(tx.inputs[1].tokenCategory == 0x);\\n\\n//       // provided pubkeyhash must be the pubkeyhash of input1 (users address)\\n         OP_1 OP_UTXOBYTECODE <0x76a914> OP_5 OP_PICK OP_CAT <0x88ac> OP_CAT OP_EQUALVERIFY \\n//       require(tx.inputs[1].lockingBytecode == new LockingBytecodeP2PKH(pubkeyhash));\\n\\n//       // convert stakeBlocks to bytes for inclusion into commitment\\n         OP_2 OP_PICK OP_2 OP_NUM2BIN \\n//       bytes stakeLength = bytes2(stakeBlocks);\\n\\n//       // save payout address and length of lock into output1 commitment (lockNFT)\\n         OP_1 OP_OUTPUTTOKENCOMMITMENT OP_5 OP_ROLL OP_0 <18> OP_NUM2BIN OP_CAT OP_ROT OP_CAT OP_EQUALVERIFY \\n//       require(tx.outputs[1].nftCommitment == pubkeyhash + bytes18(0) + stakeLength);\\n\\n//       // get current locking fee from masterBadger's commitment\\n         OP_0 OP_UTXOTOKENCOMMITMENT OP_2 OP_SPLIT OP_DROP \\n//       bytes2 stakeFee = bytes2(tx.inputs[0].nftCommitment.split(2)[0]);\\n\\n//       // add locking fee to current masterBadger balance\\n         OP_0 OP_OUTPUTVALUE OP_0 OP_UTXOVALUE OP_ROT OP_BIN2NUM OP_ADD OP_NUMEQUALVERIFY \\n//       require(tx.outputs[0].value == tx.inputs[0].value + int(stakeFee));\\n\\n//       // output0 sent to contract (recreate masterBadger)\\n         OP_0 OP_OUTPUTBYTECODE OP_0 OP_UTXOBYTECODE OP_EQUALVERIFY \\n//       require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\\n\\n//       // carry forward masterBadger tokenCategory + capability\\n         OP_0 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY OP_EQUALVERIFY \\n//       require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\\n\\n//       // carry forward masterBadger commitment\\n         OP_0 OP_OUTPUTTOKENCOMMITMENT OP_0 OP_UTXOTOKENCOMMITMENT OP_EQUALVERIFY \\n//       require(tx.outputs[0].nftCommitment == tx.inputs[0].nftCommitment);\\n\\n//       calculate amount of BadgerCoins user will earn (amount * blocks / 1BCH)\\n         OP_OVER OP_3 OP_ROLL OP_MUL <100000000> OP_DIV \\n//       int stakeReward = amount * stakeBlocks / 100000000;\\n\\n//       // require at least 1 BadgerCoin will be earned\\n         OP_DUP OP_1 OP_GREATERTHANOREQUAL OP_VERIFY \\n//       require(stakeReward >= 1);\\n\\n//       // deduct earned BadgerCoins from masterBadger\\n         OP_0 OP_OUTPUTTOKENAMOUNT OP_0 OP_UTXOTOKENAMOUNT OP_2 OP_PICK OP_SUB OP_NUMEQUALVERIFY \\n//       require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount - stakeReward);\\n\\n//       // output1 sent to contract (lockNFT)\\n         OP_1 OP_OUTPUTBYTECODE OP_0 OP_UTXOBYTECODE OP_EQUALVERIFY \\n//       require(tx.outputs[1].lockingBytecode == tx.inputs[0].lockingBytecode);\\n\\n//       // lockNFT is a mutable NFT of masterBadger categoryID\\n         OP_1 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY <32> OP_SPLIT OP_DROP OP_1 OP_CAT OP_EQUALVERIFY \\n//       require(tx.outputs[1].tokenCategory == tx.inputs[0].tokenCategory.split(32)[0] + 0x01);\\n\\n//       // lockNFT has BCH equal to users amount parameter\\n         OP_1 OP_OUTPUTVALUE OP_3 OP_ROLL OP_NUMEQUALVERIFY\\n//       require(tx.outputs[1].value == amount);\\n\\n//       // lockNFT has BadgerCoin equal to calculated amount to be earned\\n         OP_1 OP_OUTPUTTOKENAMOUNT OP_NUMEQUALVERIFY \\n//       require(tx.outputs[1].tokenAmount == stakeReward);\\n\\n//       // if output2 exists (change)\\n         OP_TXOUTPUTCOUNT OP_3 OP_NUMEQUAL OP_IF \\n//       if (tx.outputs.length == 3) {\\n//          // change must be sent to users address\\n            OP_2 OP_OUTPUTBYTECODE OP_1 OP_UTXOBYTECODE OP_EQUALVERIFY \\n//          require(tx.outputs[2].lockingBytecode == tx.inputs[1].lockingBytecode);\\n\\n//          // change must not have tokens\\n            OP_2 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUALVERIFY OP_ENDIF \\n//          require(tx.outputs[2].tokenCategory == 0x);\\n//       }\\n//     }\\n      OP_DROP OP_1 OP_ELSE \\n\\n//    /////////////////////////////////////////////\\n//    //inputs:\\n//    //  0   lockUTXO            [NFT]   (from contract)\\n//    //      <20-byte owner_pkh> <18-byte 00s> <2-byte fee>\\n//    //\\n//    //outputs:\\n//    //  0   BadgerCoins         [FUN]   (to user)\\n//    //  1   Honey               [NFT]   (to user)\\n//    //  2   {optional} change   [BCH]   (to user)\\n//    /////////////////////////////////////////////\\n      OP_DUP OP_1 OP_NUMEQUAL OP_IF \\n//     function unlock() {\\n\\n//       // this contract must be input0\\n         OP_INPUTINDEX OP_0 OP_NUMEQUALVERIFY \\n//       require(this.activeInputIndex == 0);\\n\\n//       // must have exactly 1 input\\n         OP_TXINPUTCOUNT OP_1 OP_NUMEQUALVERIFY \\n//       require(tx.inputs.length == 1);\\n\\n//       // must have exactly 3 outputs\\n         OP_TXOUTPUTCOUNT OP_3 OP_NUMEQUALVERIFY \\n//       require(tx.outputs.length == 3);\\n\\n//       // input0 must be a lockNFT (masterBadger categoryID + mutable)\\n         OP_0 OP_UTXOTOKENCATEGORY <authentication_category> OP_1 OP_CAT OP_EQUALVERIFY \\n//       require(tx.inputs[0].tokenCategory == 0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24 + 0x01);\\n\\n//       // get number of blocks locked for from lockNFT's commitment\\n         OP_0 OP_UTXOTOKENCOMMITMENT <38> OP_SPLIT OP_NIP \\n//       bytes stakeBlocks = bytes2(tx.inputs[0].nftCommitment.split(38)[1]);\\n\\n//       // require the number of blocks locked for has been passed\\n         OP_BIN2NUM OP_CHECKSEQUENCEVERIFY \\n//       require(tx.age >= int(stakeBlocks));\\n\\n//       // get the pubkeyhash in lockNFT it was created with\\n         OP_DROP OP_0 OP_UTXOTOKENCOMMITMENT <20> OP_SPLIT OP_DROP \\n//       bytes20 payoutAddress = bytes20(tx.inputs[0].nftCommitment.split(20)[0]);\\n\\n//       // create the lockingBytecode for that pubkeyhash\\n         <0x76a914> OP_SWAP OP_CAT <0x88ac> OP_CAT \\n//       bytes payoutBytecode = new LockingBytecodeP2PKH(payoutAddress);\\n\\n//       // output0 (BadgerCoins) goes to the resulting wallet address (user who created the lock)\\n         OP_0 OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY \\n//       require(tx.outputs[0].lockingBytecode == payoutBytecode);\\n\\n//       // output0 is a masterBadger categoryID but no capability\\n         OP_0 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY <32> OP_SPLIT OP_DROP OP_EQUALVERIFY \\n//       require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory.split(32)[0]);\\n\\n//       // output0 has 1000 dust satoshis so it can exist\\n         OP_0 OP_OUTPUTVALUE <1000> OP_NUMEQUALVERIFY \\n//       require(tx.outputs[0].value == 1000);\\n\\n         OP_0 OP_OUTPUTTOKENAMOUNT OP_0 OP_UTXOTOKENAMOUNT OP_NUMEQUALVERIFY \\n//       require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount);\\n\\n//       // output1 (HoneyNFT) goes to the resulting wallet address (user who created the lock)\\n         OP_1 OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY \\n//       require(tx.outputs[1].lockingBytecode == payoutBytecode);\\n\\n//       // output1 is a masterBadger categoryID but no capability\\n         OP_1 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY <32> OP_SPLIT OP_DROP OP_EQUALVERIFY \\n//       require(tx.outputs[1].tokenCategory == tx.inputs[0].tokenCategory.split(32)[0]);\\n\\n//       // output1 has 1000 satoshis so it can exist\\n         OP_1 OP_OUTPUTVALUE <1000> OP_NUMEQUALVERIFY \\n//       require(tx.outputs[1].value == 1000);\\n\\n//       // create commitment of ID0 + amount of BadgerCoins earned\\n         <0x0000> OP_0 OP_UTXOTOKENAMOUNT OP_CAT \\n//       bytes commitment = 0x0000 + bytes(tx.inputs[0].tokenAmount);\\n\\n//       // output1 has above commitment\\n         OP_1 OP_OUTPUTTOKENCOMMITMENT OP_EQUALVERIFY \\n//       require(tx.outputs[1].nftCommitment == commitment);\\n\\n//       // output2 (unlocked BCH) goes to the extracted wallet address (user who created the lock)\\n         OP_2 OP_OUTPUTBYTECODE OP_EQUALVERIFY \\n//       require(tx.outputs[2].lockingBytecode == payoutBytecode);\\n\\n//       // output2 has no tokens\\n         OP_2 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUALVERIFY \\n//       require(tx.outputs[2].tokenCategory == 0x);\\n\\n//       // output2 has original locked BCH minus 3000sats (miner fee + BadgerCoin utxo + Honey utxo)\\n         OP_2 OP_OUTPUTVALUE OP_0 OP_UTXOVALUE <3000> OP_SUB OP_NUMEQUAL \\n//       require(tx.outputs[2].value == tx.inputs[0].value - 3000);\\n//     }\\n\\n//     /////////////////////////////////////////////\\n//     //inputs:\\n//     //  0   masterBadger        [NFT]   (from contract)\\n//     //      <2-byte fee> <18-byte 00s> <20-byte admin_pkh>\\n//     //      \\n//     //  1   adminUTXO           [BCH]   (from admin)\\n//     //outputs:\\n//     //  0   masterBadger        [NFT]   (to contract)\\n//     //  1   withdrawUTXO        [BCH]   (to admin)\\n//     /////////////////////\\n//     //parameters:\\n//     //  newFee: sets the masterBadger's locking fee (0 to 65536)\\n//     /////////////////////////////////////////////\\n      OP_NIP OP_ELSE OP_2 OP_NUMEQUALVERIFY \\n//     function withdraw(int newFee) {\\n\\n//       // this contract must be input0\\n         OP_INPUTINDEX OP_0 OP_NUMEQUALVERIFY \\n//       require(this.activeInputIndex == 0);\\n\\n//       // must have exactly 2 inputs\\n         OP_TXINPUTCOUNT OP_2 OP_NUMEQUALVERIFY \\n//       require(tx.inputs.length == 2);\\n\\n//       // must have exactly 2 outputs\\n         OP_TXOUTPUTCOUNT OP_2 OP_NUMEQUALVERIFY \\n//       require(tx.outputs.length == 2);\\n\\n//       // input0 must be masterBadger NFT\\n         OP_0 OP_UTXOTOKENCATEGORY <authentication_category> OP_2 OP_CAT OP_EQUALVERIFY \\n//       require(tx.inputs[0].tokenCategory == 0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24 + 0x02);\\n\\n//       // input1 must be BCH with no tokens\\n         OP_1 OP_UTXOTOKENCATEGORY OP_0 OP_EQUALVERIFY \\n//       require(tx.inputs[1].tokenCategory == 0x);\\n\\n//       // get admins pubkeyhash stored in masterBadger commitment\\n         OP_0 OP_UTXOTOKENCOMMITMENT <20> OP_SPLIT OP_NIP \\n//       bytes20 adminAddress = bytes20(tx.inputs[0].nftCommitment.split(20)[1]);\\n\\n//       // create the lockingBytecode for that pubkeyhash\\n         <0x76a914> OP_SWAP OP_CAT <0x88ac> OP_CAT \\n//       bytes payoutBytecode = new LockingBytecodeP2PKH(adminAddress);\\n\\n//       // require the resulting lockingBytecode matches input1 (input1 is from admin address)\\n         OP_1 OP_UTXOBYTECODE OP_EQUALVERIFY \\n//       require(tx.inputs[1].lockingBytecode == payoutBytecode);\\n\\n//       // output1 has no tokens\\n         OP_1 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUALVERIFY \\n//       require(tx.outputs[1].tokenCategory == 0x);\\n\\n//       // output1 takes masterBadger's BCH balance minus 2000sats (miner fee + masterBadger dust)\\n         OP_1 OP_OUTPUTVALUE OP_0 OP_UTXOVALUE OP_1 OP_UTXOVALUE OP_ADD <2000> OP_SUB OP_NUMEQUALVERIFY \\n//       require(tx.outputs[1].value == tx.inputs[0].value + tx.inputs[1].value - 2000);\\n\\n//       // output0 sent to contract (recreate masterBadger)\\n         OP_0 OP_OUTPUTBYTECODE OP_0 OP_UTXOBYTECODE OP_EQUALVERIFY \\n//       require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\\n\\n//       // masterBadger retains its tokenCategory + capability\\n         OP_0 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY OP_EQUALVERIFY \\n//       require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\\n\\n//       // masterBadger set to 1000sats so it can exist\\n         OP_0 OP_OUTPUTVALUE <1000> OP_NUMEQUALVERIFY \\n//       require(tx.outputs[0].value == 1000);\\n\\n//       // masterBadger retains its remaining BadgerCoins\\n         OP_0 OP_OUTPUTTOKENAMOUNT OP_0 OP_UTXOTOKENAMOUNT OP_NUMEQUALVERIFY \\n//       require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount);\\n\\n//       // get last 38bytes of masterBadgers commitment\\n         OP_0 OP_UTXOTOKENCOMMITMENT OP_2 OP_SPLIT OP_NIP \\n//       bytes restCommitment = tx.inputs[0].nftCommitment.split(2)[1];\\n\\n//       // update masterBadger's commitment to newFee + rest of its commitment\\n         OP_0 OP_OUTPUTTOKENCOMMITMENT OP_ROT OP_2 OP_NUM2BIN OP_ROT OP_CAT OP_EQUAL\\n//       require(tx.outputs[0].nftCommitment == bytes2(newFee) + restCommitment);\\n//    }\\n   OP_ENDIF \\n// }\\nOP_ENDIF"}}`),xs=["BCH_2023_05","BCH_SPEC"],Rs={$schema:Bs,description:As,name:Ns,entities:Is,scenarios:Cs,scripts:ws,supported:xs},Fs="@unspent/badgers",Ss={name:Fs},Ht=J("242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7"),Ls=J("7003b9e854d2abc855b2c20c9734c3dfe4ec3a4de573f7ebb9ce1be527a5bb36");class Ce{static USER_AGENT=Ss.name;static tokenAware=!0;static template=Rs;static compiler=Nn(this.template);static vm=Vn();static getLockingBytecode(e=Ht){typeof e=="string"&&(e=J(e));const n=this.compiler.generateBytecode({data:{bytecode:{authentication_category:new Uint8Array(e).reverse()}},scriptId:"lock"});if(!n.success)throw new Error("Failed to generate bytecode, script: , "+JSON.stringify(n,null,"  "));return n.bytecode}static getScriptHash(e,n=!0){return Ca(this.getLockingBytecode(e),n)}static getAddress(e=Ht,n="bitcoincash"){return In(this.getLockingBytecode(e),n,this.tokenAware)}static parseNFT(e){if(e.token_data?.nft?.capability=="mutable")return{user_pkh:J(e.token_data?.nft?.commitment.slice(0,40)),stake:_a(J(e.token_data?.nft?.commitment.slice(-4))),amount:parseInt(e.token_data?.amount)};if(e.token_data?.nft?.capability=="minting")return{admin_pkh:J(e.token_data?.nft?.commitment.slice(-40)),fee:_a(J(e.token_data?.nft?.commitment.slice(0,4))),amount:parseInt(e.token_data?.amount)};throw Error("Nft was not minting nor mutable")}static encodeNFT(e){return e.user_pkh!==void 0?(e=e,new Uint8Array([...e.user_pkh,...new Uint8Array(18),...pa(e.stake)])):(e=e,new Uint8Array([...pa(e.fee),...new Uint8Array(18),...e.admin_pkh]))}static encodeCommemorativeNFT(e){return new Uint8Array([...new Uint8Array(2),...Rt(e)])}static getSourceOutput(e){return{lockingBytecode:this.getLockingBytecode(e.token_data?.category),valueSatoshis:BigInt(e.value),token:e.token_data?{category:J(e.token_data.category),amount:BigInt(e.token_data.amount),nft:e.token_data.nft?{commitment:J(e.token_data.nft.commitment),capability:e.token_data.nft.capability}:void 0}:void 0}}static getAuthInput(e,n){let p=new Uint8Array(J(e.token_data?.category)).reverse();return{outpointIndex:e.tx_pos,outpointTransactionHash:J(e.tx_hash),sequenceNumber:0,unlockingBytecode:{data:{bytecode:{authentication_category:p,amount:Rt(BigInt(Math.floor(n.amount))),stake_blocks:Rt(BigInt(n.stake)),user_pkh:n.user_pkh}},compiler:this.compiler,script:"stake",valueSatoshis:BigInt(e.value),token:e.token_data?{category:J(e.token_data.category),amount:BigInt(e.token_data.amount),nft:e.token_data.nft?{commitment:J(e.token_data.nft.commitment),capability:e.token_data.nft.capability}:void 0}:void 0}}}static getAuthOutput(e,n,p,v){return{lockingBytecode:this.getLockingBytecode(e.token_data?.category),valueSatoshis:BigInt(e.value+v),token:e.token_data?{category:J(e.token_data.category),amount:BigInt(e.token_data.amount)-BigInt(Math.floor(n/1e8*p)),nft:e.token_data.nft?{commitment:J(e.token_data.nft.commitment),capability:e.token_data.nft.capability}:void 0}:void 0}}static getWalletSourceOutput(e,n,p=0){return{lockingBytecode:n?ma({addressIndex:p,hdPrivateKey:n,throwErrors:!0}):Uint8Array.from(Array(33)),valueSatoshis:BigInt(e.value)}}static getWalletInput(e,n,p=0){let v=n?{compiler:this.compiler,data:{hdKeys:{addressIndex:p,hdPrivateKeys:{wallet:n}}},script:"wallet_unlock",valueSatoshis:BigInt(e.value)}:Uint8Array.from(Array());return{outpointIndex:e.tx_pos,outpointTransactionHash:J(e.tx_hash),sequenceNumber:0,unlockingBytecode:v}}static getUnlockInput(e){let n=this.parseNFT(e);return{outpointIndex:e.tx_pos,outpointTransactionHash:J(e.tx_hash),sequenceNumber:n.stake,unlockingBytecode:{data:{bytecode:{authentication_category:new Uint8Array(J(e.token_data.category)).reverse()}},compiler:this.compiler,script:"unlock",valueSatoshis:BigInt(e.value),token:e.token_data?{category:J(e.token_data.category),amount:BigInt(e.token_data.amount),nft:e.token_data.nft?{commitment:J(e.token_data.nft.commitment),capability:e.token_data.nft.capability}:void 0}:void 0}}}static getLockOutput(e,n){return{lockingBytecode:this.getLockingBytecode(e.token_data?.category),valueSatoshis:BigInt(n.amount),token:{category:J(e.token_data?.category),amount:BigInt(Math.floor(n.amount/1e8*n.stake)),nft:{commitment:Ce.encodeNFT(n),capability:"mutable"}}}}static getUnlockOutputs(e){let n=this.parseNFT(e),p=Cn(n.user_pkh);return[{lockingBytecode:p,valueSatoshis:1000n,token:e.token_data?{category:J(e.token_data.category),amount:BigInt(e.token_data.amount),nft:void 0}:void 0},{lockingBytecode:p,valueSatoshis:1000n,token:e.token_data?{category:J(e.token_data.category),amount:BigInt(0),nft:e.token_data.nft?{commitment:this.encodeCommemorativeNFT(BigInt(e.token_data.amount)),capability:wn.none}:void 0}:void 0},{lockingBytecode:p,valueSatoshis:BigInt(e.value-3e3)}]}static getWalletInputs(e,n,p,v=[]){let i=[],_=[];if(e=e.filter(f=>!f.token_data&&f.value>n),e.length==0)throw Error("no suitable output is large enough for the stake.");const h=Math.floor(Math.random()*e.length),d=e[h];return e.splice(h,1),i.push(this.getWalletInput(d,p)),v.push(this.getWalletSourceOutput(d,p)),{inputs:i,outputs:_,sourceOutputs:v}}static getChangeOutput(e,n,p=0){return{lockingBytecode:n?{compiler:this.compiler,data:{hdKeys:{addressIndex:p,hdPublicKeys:{wallet:xn(n).hdPublicKey}}},script:"wallet_lock"}:Uint8Array.from(Array(33)),valueSatoshis:e}}static lock(e,n,p,v,i,_=0,h=1){const d=[],f=[],b=i?ma({addressIndex:_,hdPrivateKey:i,throwErrors:!0}):Uint8Array.from(Array(33));let A={locktime:0,version:2,inputs:d,outputs:f},le=Ce.parseNFT(e),g={user_pkh:Rn(b).payload,amount:n,stake:p};A.inputs.push(this.getAuthInput(e,g)),A.outputs.push(this.getAuthOutput(e,n,p,le.fee));const c=[this.getSourceOutput(e)];A.outputs.push(this.getLockOutput(e,g));const k=this.getWalletInputs(v,BigInt(n),i);A.inputs.push(...k.inputs),c.push(...k.sourceOutputs);let s=Fn(A.outputs),D=Ft(c);A.outputs.push(this.getChangeOutput(D-s,i));let M=St(A);if(!M.success)throw new Error("generate transaction failed!, errors: "+JSON.stringify(M.errors,null,"  "));const ne=Sn(M.transaction,h),se=A.outputs.length-1;if(A.outputs[se].valueSatoshis=A.outputs[se].valueSatoshis-ne,M=St(A),!M.success)throw new Error("generate transaction failed!, errors: "+JSON.stringify(M.errors,null,"  "));const x=M.transaction,ue=ga(x,c,{maximumTokenCommitmentLength:40});if(ue!==!0&&h>0)throw ue;let C=this.vm.verify({sourceOutputs:c,transaction:x});if(typeof C=="string")throw Error(C);let N=e.token_data?.category,w=Ft(c)-Ft(x.outputs);if(w>1e4)throw Error(`Excessive fees ${w}`);Lt(c,N)==0n&&(C="Error checking token input");let Q=Lt(c,N)-Lt(x.outputs,N);if(Q!==0n)throw Error(`Claiming should not create destroy tokens, token difference: ${Q}`);return{sourceOutputs:c,transaction:x,verify:C}}static unlock(e){let v={locktime:0,version:2,inputs:[],outputs:[]};v.inputs.push(this.getUnlockInput(e)),v.outputs.push(...this.getUnlockOutputs(e));let i=St(v);if(!i.success)throw new Error("generate transaction failed!, errors: "+JSON.stringify(i.errors,null,"  "));const _=[this.getSourceOutput(e)],h=i.transaction,d=ga(h,_,{maximumTokenCommitmentLength:40});if(d!==!0)throw d;let f=this.vm.verify({sourceOutputs:_,transaction:h});if(typeof f=="string")throw f;return{sourceOutputs:_,transaction:h,verify:f}}}var Ms=E('<div class="svelte-lha1zv"><!> <!></div>'),Vs=(r,e)=>{e.unlock({tx_hash:e.tx_hash,tx_pos:e.tx_pos,value:e.value,token_data:e.token_data})},Ds=E('<button class="svelte-lha1zv">unlock</button>'),Ys=E('<img height="32px" class="svelte-lha1zv"/>'),qs=E('<div class="container svelte-lha1zv"><div class="stake svelte-lha1zv"><div class="balance"><div class="fill svelte-lha1zv"><!></div> <div><div> <b>BCH</b> <img width="20px"/></div> <div class="auth svelte-lha1zv"><!> <!></div></div></div> <div class="header svelte-lha1zv"><div class="timestamp svelte-lha1zv"> </div> <div class="fill svelte-lha1zv"></div> <div class="timestamp svelte-lha1zv"> </div></div></div></div>');function Hs(r,e){At(e,!0);let n=Yt(()=>e.height>0&&e.height+e.stake<=e.now),p=Yt(()=>e.isMainnet?Na:Ia);var v=qs(),i=y(v),_=y(i),h=y(_),d=y(h);{var f=N=>{var w=Ms(),Q=y(w);Kn(Q,{get amount(){return e.token_data.amount},get category(){return e.token_data.category}});var me=B(Q,2);Aa(me,{size:20,get category(){return e.token_data.category}}),T(w),O(N,w)};I(d,N=>{e.token_data&&N(f)})}T(h);var b=B(h,2),A=y(b),le=y(A),g=B(le,3);T(A);var c=B(A,2),k=y(c);{var s=N=>{var w=Ds();w.__click=[Vs,e],O(N,w)};I(k,N=>{t(n)&&N(s)})}var D=B(k,2);{var M=N=>{var w=Ys();V((Q,me)=>{W(w,"src",Q),W(w,"alt",me)},[()=>Hn(mt(e.user_pkh),16),()=>mt(e.user_pkh)]),O(N,w)};I(D,N=>{e.user_pkh&&N(M)})}T(c),T(b),T(_);var ne=B(_,2),se=y(ne),x=y(se,!0);T(se);var ue=B(se,4),C=y(ue,!0);T(ue),T(ne),T(i),T(v),V(N=>{ee(le,`${N??""} `),W(g,"src",t(p)),ee(x,e.stake),ee(C,e.height)},[()=>Number(e.value/1e8).toLocaleString(void 0,{})]),O(r,v),Nt()}Ua(["click"]);var Ks=E('<meta name="description" content="Stake coins for Badgers."/>'),Qs=E("<img/>"),Xs=E('<img alt="Disconnected"/>'),Gs=E('<span style="font-size:large; color: red;">Min stake is 0.00005 BCH!</span>'),zs=E("<h3> <!></h3>"),Ws=E("<h3> </h3>"),js=E('<span style="font-size:large; color: red;">Max duration is 32,767 blocks!</span>'),Js=E('<span style="font-size:large; color: red;">Min duration is one block</span>'),Zs=(r,e)=>{e()},$s=E('<button class="svelte-1tuu9m1">stake</button>'),er=E('<button disabled class="svelte-1tuu9m1">stake</button> <br/> <span style="font-size:large; color: red;"></span>',1),tr=E('<div class="stakeForm svelte-1tuu9m1"><div class="svelte-1tuu9m1"><!></div> <div class="purple-theme svelte-1tuu9m1"><label for="stakeValue" class="svelte-1tuu9m1">BCH to Lock</label> <!> </div> <div class="purple-theme svelte-1tuu9m1"><label for="stakeBlock" class="svelte-1tuu9m1"># Blocks</label> <!> <!></div> <div class="stake svelte-1tuu9m1"><!></div></div>'),ar=E('<div class="stakeForm svelte-1tuu9m1"><p><a href="/wallet">Deposit funds</a> to stake coins.</p></div>'),nr=E('<div class="row svelte-1tuu9m1"><!></div>'),sr=E("<p>No staked coins?</p> ",1),rr=E('<h3>Current Stakes</h3> <div class="grid svelte-1tuu9m1"><!></div>',1),or=E('<section class="svelte-1tuu9m1"><div class="status svelte-1tuu9m1"> <!> <!></div> <h1>Stake Coins for Badgers</h1> <div class="swap svelte-1tuu9m1"><div class="svelte-1tuu9m1"><img width="50"/> <br/> </div></div> <!> <!> <!></section>');function Fr(r,e){At(e,!0);let n=ke(0),p=ke(""),v=ke(""),i=ke(ua([])),_=ke(ua([])),h=ke(""),d=ke(""),f=ke(void 0),b=ke(""),A=ke(""),le=ke(""),g=ke(0),c=ke(void 0),k=ke(1);const s=kn.url.hostname=="vox.cash",D=s?mt(Ht):mt(Ls),M=s?"BCH":"tBCH",ne=s?"BADGER":"tBADGER",se=s?"bitcoincash":"bchtest",x=An(s),ue=s?Na:Ia;P(b,Ce.getScriptHash(D),!0),P(A,Ce.getAddress(D,se),!0);let C;const N=async function(u){if(P(p,fa[t(f).status],!0),u.method==="blockchain.headers.subscribe"){let l=u.params[0];P(n,l.height,!0),me()}else u.method==="blockchain.scripthash.subscribe"?u.params[1]!==t(v)&&(P(v,u.params[1],!0),me(),w()):console.log(u)},w=async function(){let u=await t(f).request("blockchain.scripthash.listunspent",t(le),"include_tokens");if(u instanceof Error)throw u;P(_,u,!0),P(g,Mn(t(_),!0),!0)},Q=async function(u){let l=await t(f).request("blockchain.transaction.broadcast",u);if(l instanceof Error)throw P(p,fa[t(f).status],!0),l},me=async function(){let u=await t(f).request("blockchain.scripthash.listunspent",t(b),"include_tokens");if(u instanceof Error)throw u;P(i,u.filter(l=>l.token_data.nft.capability=="mutable").map(l=>({...l,...Ce.parseNFT(l),now:t(n)})),!0),t(i).sort((l,K)=>l.stake+l.height-(K.stake+K.height)),P(h,u.filter(l=>l.token_data.nft.capability=="minting").map(l=>({...l,...Ce.parseNFT(l),now:t(n)}))[0],!0)},Ue=async function(u){let l=Ce.unlock(u),K=mt(Oa(l.transaction));console.log(K),await Q(K)},tt=async function(){if(t(k)<32767&&t(c)&&t(c)>5e-4){let u=Ce.lock(t(h),Math.floor(t(c)*1e8),t(k),t(_),t(d)),l=mt(Oa(u.transaction));console.log(l),await Q(l)}};ya(async()=>{Bn.StorageProvider=Un,C=s?await yn.named("vox"):await Tn.named("vox"),P(d,En(C.mnemonic,C.derivationPath.slice(0,-2),C.isTestnet),!0);let u=Ln(C.getDepositAddress());if(typeof u=="string")throw u;P(le,Ca(u.bytecode),!0),P(f,new da(Ce.USER_AGENT,"1.4.1",x),!0),await t(f).connect(),t(f).on("notification",N),await t(f).subscribe("blockchain.scripthash.subscribe",t(b)),await t(f).subscribe("blockchain.scripthash.subscribe",t(le)),await t(f).subscribe("blockchain.headers.subscribe")}),on(async()=>{await new da(Ce.USER_AGENT,"1.4.1",x).disconnect()});var _e=or();pn(u=>{var l=Ks();_n.title=" Badgers",O(u,l)});var Se=y(_e),qe=y(Se),de=B(qe);Dn(de,{get template(){return Ce.template}});var Pe=B(de,2);{var be=u=>{var l=Qs();V(()=>{W(l,"src",Yn),W(l,"alt",t(p))}),O(u,l)},we=u=>{var l=Xs();V(()=>W(l,"src",qn)),O(u,l)};I(Pe,u=>{t(p)=="CONNECTED"?u(be):u(we,!1)})}T(Se);var ye=B(Se,4),Le=y(ye),at=y(Le),pt=B(at,3);T(Le),T(ye);var G=B(ye,2);{var Y=u=>{var l=tr(),K=y(l),oe=y(K);{var j=X=>{var fe=Gs();O(X,fe)},z=(X,fe)=>{{var je=pe=>{var Te=zs(),Je=y(Te),He=B(Je);Aa(He,{get category(){return D},size:16,get isMainnet(){return s}}),T(Te),V(Ve=>ee(Je,`Earn ${Ve??""}
						${ne} `),[()=>Math.floor(t(c)*t(k)).toLocaleString()]),O(pe,Te)},Ot=pe=>{var Te=Ws(),Je=y(Te);T(Te),V(()=>ee(Je,`Adjust controls to stake ${ne}`)),O(pe,Te)};I(X,pe=>{t(c)>0&&t(k)>0?pe(je):pe(Ot,!1)},fe)}};I(oe,X=>{t(c)>0&&t(c)<5e-5?X(j):X(z,!1)})}T(K);var S=B(K,2),H=B(y(S),2);const F=Yt(()=>t(g)/1e8);ba(H,{id:"stakeValue",float:!0,min:0,step:.01,get max(){return t(F)},get value(){return t(c)},set value(X){P(c,X,!0)}});var Z=B(H);T(S);var ie=B(S,2),Be=B(y(ie),2);ba(Be,{id:"stakeBlock",float:!0,min:1,max:32767,get value(){return t(k)},set value(X){P(k,X,!0)}});var ve=B(Be,2);{var dt=X=>{var fe=js();O(X,fe)},gt=(X,fe)=>{{var je=pe=>{var Te=Js();O(pe,Te)},Ot=(pe,Te)=>{{var Je=He=>{var Ve=sn();V(It=>ee(Ve,`= ${It??""} days`),[()=>Number(t(k)/144).toLocaleString(void 0,{minimumFractionDigits:0,maximumFractionDigits:3})]),O(He,Ve)};I(pe,He=>{t(k)>0&&He(Je)},Te)}};I(X,pe=>{t(k)<1?pe(je):pe(Ot,!1)},fe)}};I(ve,X=>{t(k)>32767?X(dt):X(gt,!1)})}T(ie);var ze=B(ie,2),Ae=y(ze);{var Ne=X=>{var fe=$s();fe.__click=[Zs,tt],O(X,fe)},We=X=>{var fe=er();Ta(4),O(X,fe)};I(Ae,X=>{t(c)*t(k)>=1?X(Ne):X(We,!1)})}T(ze),T(l),V(()=>ee(Z,` ${t(c)??""}
				${M}`)),O(u,l)},re=u=>{var l=ar();O(u,l)};I(G,u=>{t(g)>0?u(Y):u(re,!1)})}var xe=B(G,2);{var Me=u=>{var l=rr(),K=B(ut(l),2),oe=y(K);{var j=S=>{var H=Bt(),F=ut(H);Kt(F,17,()=>t(i),Qt,(Z,ie)=>{var Be=nr(),ve=y(Be);Hs(ve,vn({unlock:Ue,get isMainnet(){return s}},()=>t(ie))),T(Be),O(Z,Be)}),O(S,H)},z=S=>{var H=sr(),F=B(ut(H));V(()=>ee(F,` ${t(A)??""}`)),O(S,H)};I(oe,S=>{t(i).length>0?S(j):S(z,!1)})}T(K),O(u,l)};I(xe,u=>{t(i).length&&u(Me)})}var q=B(xe,2);Wn(q),T(_e),V((u,l)=>{ee(qe,`${u??""} `),W(at,"src",ue),W(at,"alt",M),ee(pt,` ${l??""}
			${M}`)},[()=>t(n).toLocaleString(),()=>(t(g)/1e8).toLocaleString()]),O(r,_e),Nt()}Ua(["click"]);export{Fr as component,Rr as universal};
//# sourceMappingURL=4.Cph0N3LK.js.map
