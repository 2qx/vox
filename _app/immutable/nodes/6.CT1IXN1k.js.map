{"version":3,"file":"6.CT1IXN1k.js","sources":["../../../../../../../../node_modules/.pnpm/svelte@5.33.18/node_modules/svelte/src/internal/client/dom/elements/bindings/select.js","../../../../../../src/lib/Transaction.svelte","../../../../../../src/routes/cat/+page.ts","../../../../../../src/lib/CatDexOrder.svelte","../../../../../../../catdex/out/index.js","../../../../../../src/routes/cat/+page.svelte"],"sourcesContent":["import { effect } from '../../../reactivity/effects.js';\nimport { listen_to_event_and_reset_event } from './shared.js';\nimport { untrack } from '../../../runtime.js';\nimport { is } from '../../../proxy.js';\nimport { is_array } from '../../../../shared/utils.js';\nimport * as w from '../../../warnings.js';\n\n/**\n * Selects the correct option(s) (depending on whether this is a multiple select)\n * @template V\n * @param {HTMLSelectElement} select\n * @param {V} value\n * @param {boolean} [mounting]\n */\nexport function select_option(select, value, mounting) {\n\tif (select.multiple) {\n\t\t// If value is null or undefined, keep the selection as is\n\t\tif (value == undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If not an array, warn and keep the selection as is\n\t\tif (!is_array(value)) {\n\t\t\treturn w.select_multiple_invalid_value();\n\t\t}\n\n\t\t// Otherwise, update the selection\n\t\tfor (var option of select.options) {\n\t\t\toption.selected = value.includes(get_option_value(option));\n\t\t}\n\n\t\treturn;\n\t}\n\n\tfor (option of select.options) {\n\t\tvar option_value = get_option_value(option);\n\t\tif (is(option_value, value)) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!mounting || value !== undefined) {\n\t\tselect.selectedIndex = -1; // no option should be selected\n\t}\n}\n\n/**\n * Selects the correct option(s) if `value` is given,\n * and then sets up a mutation observer to sync the\n * current selection to the dom when it changes. Such\n * changes could for example occur when options are\n * inside an `#each` block.\n * @template V\n * @param {HTMLSelectElement} select\n * @param {() => V} [get_value]\n */\nexport function init_select(select, get_value) {\n\tlet mounting = true;\n\teffect(() => {\n\t\tif (get_value) {\n\t\t\tselect_option(select, untrack(get_value), mounting);\n\t\t}\n\t\tmounting = false;\n\n\t\tvar observer = new MutationObserver(() => {\n\t\t\t// @ts-ignore\n\t\t\tvar value = select.__value;\n\t\t\tselect_option(select, value);\n\t\t\t// Deliberately don't update the potential binding value,\n\t\t\t// the model should be preserved unless explicitly changed\n\t\t});\n\n\t\tobserver.observe(select, {\n\t\t\t// Listen to option element changes\n\t\t\tchildList: true,\n\t\t\tsubtree: true, // because of <optgroup>\n\t\t\t// Listen to option element value attribute changes\n\t\t\t// (doesn't get notified of select value changes,\n\t\t\t// because that property is not reflected as an attribute)\n\t\t\tattributes: true,\n\t\t\tattributeFilter: ['value']\n\t\t});\n\n\t\treturn () => {\n\t\t\tobserver.disconnect();\n\t\t};\n\t});\n}\n\n/**\n * @param {HTMLSelectElement} select\n * @param {() => unknown} get\n * @param {(value: unknown) => void} set\n * @returns {void}\n */\nexport function bind_select_value(select, get, set = get) {\n\tvar mounting = true;\n\n\tlisten_to_event_and_reset_event(select, 'change', (is_reset) => {\n\t\tvar query = is_reset ? '[selected]' : ':checked';\n\t\t/** @type {unknown} */\n\t\tvar value;\n\n\t\tif (select.multiple) {\n\t\t\tvalue = [].map.call(select.querySelectorAll(query), get_option_value);\n\t\t} else {\n\t\t\t/** @type {HTMLOptionElement | null} */\n\t\t\tvar selected_option =\n\t\t\t\tselect.querySelector(query) ??\n\t\t\t\t// will fall back to first non-disabled option if no option is selected\n\t\t\t\tselect.querySelector('option:not([disabled])');\n\t\t\tvalue = selected_option && get_option_value(selected_option);\n\t\t}\n\n\t\tset(value);\n\t});\n\n\t// Needs to be an effect, not a render_effect, so that in case of each loops the logic runs after the each block has updated\n\teffect(() => {\n\t\tvar value = get();\n\t\tselect_option(select, value, mounting);\n\n\t\t// Mounting and value undefined -> take selection from dom\n\t\tif (mounting && value === undefined) {\n\t\t\t/** @type {HTMLOptionElement | null} */\n\t\t\tvar selected_option = select.querySelector(':checked');\n\t\t\tif (selected_option !== null) {\n\t\t\t\tvalue = get_option_value(selected_option);\n\t\t\t\tset(value);\n\t\t\t}\n\t\t}\n\n\t\t// @ts-ignore\n\t\tselect.__value = value;\n\t\tmounting = false;\n\t});\n\n\t// don't pass get_value, we already initialize it in the effect above\n\tinit_select(select);\n}\n\n/** @param {HTMLOptionElement} option */\nfunction get_option_value(option) {\n\t// __value only exists if the <option> has a value attribute\n\tif ('__value' in option) {\n\t\treturn option.__value;\n\t} else {\n\t\treturn option.value;\n\t}\n}\n","<script lang=\"ts\">\n\timport { binToHex } from '@bitauth/libauth';\n\timport { sumSourceOutputValue, sumSourceOutputTokenAmounts } from '@unspent/tau';\n\tlet { transaction, sourceOutputs, category } = $props();\n</script>\n\nLocktime: {transaction.locktime}<br />\nVersion: {transaction.version}\n<div class=\"twoUp\">\n\t<div>\n\t\t<h4>Inputs</h4>\n\t\t<table>\n\t\t\t<thead class=\"r\">\n\t\t\t\t<tr>\n\t\t\t\t\t<td>Sats </td>\n\t\t\t\t\t<td> Tokens</td>\n\t\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<tbody>\n\t\t\t\t{#each sourceOutputs as i}\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td class=\"r sats\">\n\t\t\t\t\t\t\t{i.valueSatoshis.toLocaleString()}\n\t\t\t\t\t\t</td>\n\n\t\t\t\t\t\t<td class=\"r sats\">\n\t\t\t\t\t\t\t{#if i.token}\n\t\t\t\t\t\t\t\t<i>{i.token.amount.toLocaleString()}</i>\n\t\t\t\t\t\t\t{:else}\n\t\t\t\t\t\t\t\t<i>0</i>\n\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\t\t\t\t{/each}\n\t\t\t</tbody>\n\t\t\t<tfoot>\n\t\t\t\t<tr>\n\t\t\t\t\t<td class=\"r\">\n\t\t\t\t\t\t{sumSourceOutputValue(sourceOutputs).toLocaleString()}\n\t\t\t\t\t</td>\n\t\t\t\t\t<td class=\"r\">\n\t\t\t\t\t\t<i>\n\t\t\t\t\t\t\t{sumSourceOutputTokenAmounts(sourceOutputs, category).toLocaleString()}\n\t\t\t\t\t\t</i>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t</tfoot>\n\t\t</table>\n\t</div>\n\t<div>\n\t\t<h4>Outputs</h4>\n\t\t<table>\n\t\t\t<thead class=\"r\">\n\t\t\t\t<tr>\n\t\t\t\t\t<td>Sats </td>\n\t\t\t\t\t<td> Tokens</td>\n\t\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<tbody>\n\t\t\t\t{#each transaction.outputs as o}\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td class=\"r sats\">\n\t\t\t\t\t\t\t{o.valueSatoshis.toLocaleString()}\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"r sats\">\n\t\t\t\t\t\t\t{#if o.token}\n\t\t\t\t\t\t\t\t<i>{o.token.amount.toLocaleString()}</i>\n\t\t\t\t\t\t\t{:else}\n\t\t\t\t\t\t\t\t<i>0</i>\n\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\t\t\t\t{/each}\n\t\t\t</tbody>\n\t\t\t<tfoot>\n\t\t\t\t<tr>\n\t\t\t\t\t<td class=\"r\">\n\t\t\t\t\t\t{sumSourceOutputValue(transaction.outputs).toLocaleString()}\n\t\t\t\t\t</td>\n\t\t\t\t\t<td class=\"r\">\n\t\t\t\t\t\t<i>\n\t\t\t\t\t\t\t{sumSourceOutputTokenAmounts(transaction.outputs, category).toLocaleString()}\n\t\t\t\t\t\t</i>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t</tfoot>\n\t\t</table>\n\t</div>\n</div>\n\n<h4>Difference</h4>\n<table>\n\t<thead class=\"r\">\n\t\t<tr>\n\t\t\t<td>Sats </td>\n\t\t\t<td> Tokens </td>\n\t\t</tr>\n\t</thead>\n\n\t<tfoot>\n\t\t<tr>\n\t\t\t<td class=\"r\">\n\t\t\t\tFee:\n\t\t\t\t{(\n\t\t\t\t\tsumSourceOutputValue(sourceOutputs) - sumSourceOutputValue(transaction.outputs)\n\t\t\t\t).toLocaleString()}\n\t\t\t</td>\n\t\t\t<td class=\"r\">\n\t\t\t\t<i\n\t\t\t\t\t>Burned:\n\t\t\t\t\t{(\n\t\t\t\t\t\tsumSourceOutputTokenAmounts(sourceOutputs, category) -\n\t\t\t\t\t\tsumSourceOutputTokenAmounts(transaction.outputs, category)\n\t\t\t\t\t).toLocaleString()}\n\t\t\t\t</i>\n\t\t\t</td>\n\t\t</tr>\n\t</tfoot>\n</table>\n\n<style>\n\t.twoUp {\n\t\tdisplay: flex;\n\t}\n\t.twoUp div {\n\t\twidth: 50%;\n\t}\n\n\ttable {\n\t\twidth: 100%;\n\t}\n\t.r {\n\t\tmin-width: 50%;\n\t\ttext-align: right;\n\t}\n\t.sats {\n\t\tfont-size: x-small;\n\t}\n\n\ttfoot {\n\t\tfont-weight: 700;\n\t}\n\tthead tr td {\n\t\t\n\t\tborder: 2px ridge rgba(247, 202, 248, 0.6);\n\t\tbackground-color: #ffffff5b;\n\t}\n\n\tthead tr:nth-child(odd) {\n\t\ttext-align: center;\n\n\t\tfont-weight: 900;\n\t}\n\ttbody tr:nth-child(odd) {\n\t\tbackground-color: #ff33cc1f;\n\t}\n\ttbody tr:nth-child(even) {\n\t\tbackground-color: #e495e41a;\n\t}\n</style>\n","import type { PageLoad } from './$types';\n\nexport const prerender = true;\n\nexport const load: PageLoad = ({ params,url }) => {\n    return {\n        asset: url.searchParams.get('asset')\n    };\n};","<script lang=\"ts\">\n\timport BCH from '$lib/images/BCH.svg';\n\timport tBCH from '$lib/images/tBCH.svg';\n\n\timport { binToHex } from '@bitauth/libauth';\n\timport TokenNftData from './TokenNftData.svelte';\n\timport Ticker from './Ticker.svelte';\n\timport TokenIcon from './TokenIcon.svelte';\n\tlet {\n\t\tauthCategory,\n\t\tassetCategory,\n\t\torderUtxo,\n\t\tassetUtxo,\n\t\tprice,\n\t\tamount,\n\t\tquantity,\n\t\tvalue,\n\t\tisMainnet\n\t} = $props();\n\tlet bid = $derived(quantity > 0);\n\n\tlet bchIcon = isMainnet ? BCH : tBCH;\n</script>\n\n<div class={['container', { bid }]}>\n\t<div class=\"post\">\n\t\t<div class=\"balance\">\n\t\t\t<div class=\"order\">\n\t\t\t\t{#if orderUtxo}\n\t\t\t\t\t<div class=\"auth\">\n\t\t\t\t\t\t<TokenIcon size={20} category={orderUtxo.token_data.category}></TokenIcon>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"price\">\n\t\t\t\t\t\t{Number(price).toLocaleString(undefined, {\n\t\t\t\t\t\t\tminimumFractionDigits: 0,\n\t\t\t\t\t\t\tmaximumFractionDigits: 6\n\t\t\t\t\t\t})}\n\t\t\t\t\t</div>\n\n\t\t\t\t\t<div class=\"quantity\">\n\t\t\t\t\t\t{Number(quantity).toLocaleString(undefined, {}).padStart(12)}\n\t\t\t\t\t\t<TokenIcon size={20} category={assetCategory} {isMainnet} />\n\t\t\t\t\t</div>\n\t\t\t\t{/if}\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n\n<style>\n\t.container {\n\t\tbackground-color: #f29cf7;\n\t\tborder-radius: 10px;\n\t\tdisplay: flex;\n\t}\n\t.post {\n\t\tborder-radius: 10px;\n\t\tpadding: 0px;\n\t\tbackground-color: #ffffffdd;\n\t\tmargin: auto;\n\t\twidth: 100%;\n\t\tborder: #bbb solid;\n\t\tborder-width: 1px;\n\t}\n\n\t.bid {\n\t\tbackground-color: #9ef79e;\n\t}\n\n\t.quantity {\n\t\twhite-space: pre-wrap;\n\t\tfont-size: small;\n\t\tfont-weight: 500;\n\t\ttext-align: end;\n\t}\n\t.price {\n\t\tmin-width: 40px;\n\t\tfont-size: medium;\n\t\tfont-weight: 600;\n\t\ttext-align: end;\n\t}\n\t.balance {\n\t\tdisplay: flex;\n\t}\n\t\n\t.order {\n\t\talign-items: center;\n\t\tflex: 1;\n\t\tword-break: break-all;\n\t\tdisplay: flex;\n\t\tjustify-content: space-between;\n\t\talign-items: center;\n\t}\n\n\t\n\t.order div {\n\t\tpadding: 2px;\n\t}\n\t\n\t.auth {\n\t\tdisplay: flex;\n\t\topacity: 0.9;\n\t\talign-content: center;\n\t}\n\n\t\n</style>\n","import template from './template.v3.json' with { type: \"json\" };\nimport packageInfo from '../package.json' with { type: \"json\" };\nimport { binToHex, bigIntToVmNumber, createVirtualMachineBch, deriveHdPublicKey, generateTransaction, hdPrivateKeyToP2pkhLockingBytecode, hexToBin, padMinimallyEncodedVmNumber, verifyTransactionTokens, vmNumberToBigInt } from '@bitauth/libauth';\nimport { getAddress, getLibauthCompiler, getScriptHash, getTransactionFees, listUnspentTokensWrap, promiseAllInBatches, sumSourceOutputTokenAmounts, sumSourceOutputValue, sumOutputValue, sumOutputTokenAmounts } from '@unspent/tau';\nconst PRICE_MULTIPLIER = 100_000_000;\nexport default class CatDex {\n    static USER_AGENT = packageInfo.name;\n    static PROTOCOL_IDENTIFIER = \"U3X\";\n    static tokenAware = true;\n    static template = template;\n    static compiler = getLibauthCompiler(this.template);\n    static vm = createVirtualMachineBch();\n    static getLockingBytecode(authCat, assetCat) {\n        if (typeof authCat == \"string\")\n            authCat = hexToBin(authCat);\n        if (typeof assetCat == \"string\")\n            assetCat = hexToBin(assetCat);\n        const lockingBytecodeResult = this.compiler.generateBytecode({\n            data: {\n                \"bytecode\": {\n                    \"auth_category\": new Uint8Array(authCat).reverse(),\n                    \"asset_category\": new Uint8Array(assetCat).reverse()\n                }\n            },\n            scriptId: 'lock'\n        });\n        if (!lockingBytecodeResult.success)\n            throw new Error('Failed to generate bytecode, script: , ' + JSON.stringify(lockingBytecodeResult, null, '  '));\n        return lockingBytecodeResult.bytecode;\n    }\n    /**\n     * Get ScriptHash\n     *\n     * @param authCat - the authentication category\n     * @param assetCat - the asset category\n     * @param reversed - whether to reverse the hash.\n     * @throws {Error} if transaction generation fails.\n     * @returns a scripthash.\n     */\n    static getScriptHash(authCat, assetCat, reversed = true) {\n        return getScriptHash(this.getLockingBytecode(authCat, assetCat), reversed);\n    }\n    /**\n     * Get cashaddress\n     *\n     * @param authCat - the authentication category\n     * @param assetCat - the asset category\n     * @param prefix - cashaddress prefix.\n     * @throws {Error} if transaction generation fails.\n     * @returns a cashaddress.\n     */\n    static getAddress(authCat, assetCat, prefix = \"bitcoincash\") {\n        return getAddress(this.getLockingBytecode(authCat, assetCat), prefix, this.tokenAware);\n    }\n    static getCatDexOrdersFromUtxos(assetCat, utxos, excludeCompleted = true) {\n        if (typeof assetCat != \"string\")\n            assetCat = binToHex(assetCat);\n        let orderUtxos = utxos.filter((u) => u.token_data && u.token_data?.category != assetCat);\n        let dexOrders = orderUtxos.map((u) => {\n            let orderData = this.parseNFT(u.token_data?.nft?.commitment);\n            return {\n                authCategory: hexToBin(u.token_data?.category),\n                assetCategory: hexToBin(assetCat),\n                orderUtxo: u,\n                assetUtxo: undefined,\n                price: orderData.price,\n                quantity: orderData.quantity,\n                value: u.value,\n                amount: undefined\n            };\n        });\n        dexOrders.sort((a, b) => Number(b.price) - Number(a.price));\n        if (excludeCompleted)\n            dexOrders = dexOrders.filter((o) => o.quantity != 0n);\n        let matchedOrders = [];\n        for (let order of dexOrders) {\n            let matchingIdx = utxos.findIndex((u) => u.tx_hash == order.orderUtxo.tx_hash && u.tx_pos == (order.orderUtxo.tx_pos + 1));\n            if (matchingIdx == -1)\n                throw (\"Couldn't find matching asset thread\");\n            let assetInfo = {};\n            assetInfo = {\n                assetUtxo: utxos[matchingIdx],\n                amount: utxos[matchingIdx]?.token_data ? utxos[matchingIdx].token_data.amount : 0n\n            };\n            matchedOrders.push({ ...order, ...assetInfo });\n        }\n        return matchedOrders;\n    }\n    static getSourceOutput(authCat, assetCat, utxo) {\n        return {\n            lockingBytecode: this.getLockingBytecode(authCat, assetCat),\n            valueSatoshis: BigInt(utxo.value),\n            token: utxo.token_data ? {\n                category: hexToBin(utxo.token_data.category),\n                amount: BigInt(utxo.token_data.amount),\n                nft: utxo.token_data.nft ? {\n                    commitment: hexToBin(utxo.token_data.nft.commitment),\n                    capability: utxo.token_data.nft.capability,\n                } : undefined\n            } : undefined\n        };\n    }\n    /**\n     * Parse nft commitment\n     *\n     * @param commitment - nft commitment\n     * @returns an order.\n     */\n    static parseNFT(commitment) {\n        if (typeof commitment == \"string\")\n            commitment = hexToBin(commitment);\n        let quantity = vmNumberToBigInt(commitment.slice(0, 16), { requireMinimalEncoding: false });\n        let encodedPrice = vmNumberToBigInt(commitment.slice(-16), { requireMinimalEncoding: false });\n        return {\n            quantity: BigInt(quantity),\n            price: (Number(encodedPrice) / PRICE_MULTIPLIER)\n        };\n    }\n    /**\n     * Encode an order on for an nft commitment\n     *\n     * @param commitment - nft commitment\n     * @returns the new commitment as a 32-byte order data.\n     */\n    static encodeNFT(order) {\n        return new Uint8Array([\n            ...padMinimallyEncodedVmNumber(bigIntToVmNumber(BigInt(order.quantity)), 16),\n            ...padMinimallyEncodedVmNumber(bigIntToVmNumber(BigInt(Math.trunc(order.price * PRICE_MULTIPLIER))), 16)\n        ]);\n    }\n    static getInput(authCat, assetCat, utxo) {\n        if (typeof authCat == \"string\")\n            authCat = hexToBin(authCat);\n        if (typeof assetCat == \"string\")\n            assetCat = hexToBin(assetCat);\n        return {\n            outpointIndex: utxo.tx_pos,\n            outpointTransactionHash: hexToBin(utxo.tx_hash),\n            sequenceNumber: 0,\n            unlockingBytecode: {\n                data: {\n                    \"bytecode\": {\n                        \"auth_category\": new Uint8Array(authCat).reverse(),\n                        \"asset_category\": new Uint8Array(assetCat).reverse()\n                    }\n                },\n                compiler: this.compiler,\n                script: 'unlock',\n                valueSatoshis: BigInt(utxo.value),\n                token: utxo.token_data ? {\n                    category: hexToBin(utxo.token_data.category),\n                    amount: BigInt(utxo.token_data.amount),\n                    nft: utxo.token_data.nft ? {\n                        commitment: hexToBin(utxo.token_data.nft.commitment),\n                        capability: utxo.token_data.nft.capability,\n                    } : undefined\n                } : undefined\n            },\n        };\n    }\n    static getOrderOutput(order, amount) {\n        let lockingBytecode = this.getLockingBytecode(order.authCategory, order.assetCategory);\n        let tokensOut = 0n;\n        if (order.amount > 0) {\n            tokensOut = BigInt(order.assetUtxo.token_data.amount) - amount;\n        }\n        else {\n            tokensOut = -amount;\n        }\n        let out = [\n            {\n                lockingBytecode: lockingBytecode,\n                valueSatoshis: BigInt(order.orderUtxo.value) + BigInt(Number(amount) * order.price),\n                token: {\n                    amount: 0n,\n                    category: hexToBin(order.orderUtxo.token_data.category),\n                    nft: {\n                        commitment: CatDex.encodeNFT({\n                            quantity: order.quantity + amount,\n                            price: order.price\n                        }),\n                        capability: 'mutable'\n                    }\n                }\n            },\n            {\n                lockingBytecode: lockingBytecode,\n                valueSatoshis: BigInt(800n),\n                token: tokensOut != 0n ? {\n                    category: order.assetCategory,\n                    amount: BigInt(tokensOut)\n                } : undefined\n            }\n        ];\n        return out;\n    }\n    static orderRequestToOutputs(authCat, assetCat, order) {\n        let lockingBytecode = this.getLockingBytecode(authCat, assetCat);\n        if (typeof authCat == \"string\")\n            authCat = hexToBin(authCat);\n        if (typeof assetCat == \"string\")\n            assetCat = hexToBin(assetCat);\n        let cashReserves = 800n;\n        let tokenReserves = 0n;\n        // If buying, have cash on hand\n        if (order.quantity > 0n)\n            cashReserves += BigInt(Math.trunc(order.price * Number(order.quantity)));\n        // If selling, have tokens on hand to satisfy the negative order\n        if (order.quantity < 0n)\n            tokenReserves = -BigInt(order.quantity);\n        const orderCommitment = this.encodeNFT(order);\n        let outputs = [\n            {\n                lockingBytecode: lockingBytecode,\n                valueSatoshis: cashReserves,\n                token: {\n                    category: authCat,\n                    amount: 0n,\n                    nft: {\n                        commitment: orderCommitment,\n                        capability: 'mutable'\n                    }\n                }\n            }\n        ];\n        // If the order is to sell tokens, add the correlated tokens to a utxo,\n        // otherwise, create an empty 800 say dust utxo to receive tokens.\n        outputs.push({\n            lockingBytecode: lockingBytecode,\n            valueSatoshis: 800n,\n            token: tokenReserves > 0n ? {\n                category: assetCat,\n                amount: tokenReserves\n            } : undefined\n        });\n        return outputs;\n    }\n    static getWalletSourceOutput(utxo, key, addressIndex = 0) {\n        const lockingBytecode = key ? hdPrivateKeyToP2pkhLockingBytecode({\n            addressIndex: addressIndex,\n            hdPrivateKey: key,\n            throwErrors: true\n        }) : Uint8Array.from(Array(33));\n        return {\n            lockingBytecode: lockingBytecode,\n            valueSatoshis: BigInt(utxo.value),\n            token: utxo.token_data ? {\n                category: hexToBin(utxo.token_data.category),\n                amount: BigInt(utxo.token_data.amount),\n                nft: utxo.token_data.nft ? {\n                    commitment: hexToBin(utxo.token_data.nft.commitment),\n                    capability: utxo.token_data.nft.capability,\n                } : undefined\n            } : undefined\n        };\n    }\n    static getWalletInput(utxo, privateKey, addressIndex = 0) {\n        let unlockingData = privateKey ? {\n            compiler: this.compiler,\n            data: {\n                hdKeys: {\n                    addressIndex: addressIndex,\n                    hdPrivateKeys: {\n                        'wallet': privateKey\n                    },\n                }\n            },\n            script: 'wallet_unlock',\n            valueSatoshis: BigInt(utxo.value),\n            token: utxo.token_data ? {\n                category: hexToBin(utxo.token_data.category),\n                amount: BigInt(utxo.token_data.amount),\n                nft: utxo.token_data.nft ? {\n                    commitment: hexToBin(utxo.token_data.nft.commitment),\n                    capability: utxo.token_data.nft.capability,\n                } : undefined\n            } : undefined\n        } : Uint8Array.from(Array());\n        return {\n            outpointIndex: utxo.tx_pos,\n            outpointTransactionHash: hexToBin(utxo.tx_hash),\n            sequenceNumber: 0,\n            unlockingBytecode: unlockingData,\n        };\n    }\n    static getAuthWalletOutput(utxo, privateKey, addressIndex = 0) {\n        const lockingBytecode = privateKey ? {\n            compiler: this.compiler,\n            data: {\n                hdKeys: {\n                    addressIndex: addressIndex,\n                    hdPublicKeys: {\n                        'wallet': deriveHdPublicKey(privateKey).hdPublicKey\n                    },\n                },\n            },\n            script: 'wallet_lock'\n        } : Uint8Array.from(Array(33));\n        return {\n            lockingBytecode: lockingBytecode,\n            valueSatoshis: BigInt(utxo.value),\n            token: utxo.token_data ? {\n                category: hexToBin(utxo.token_data.category),\n                amount: BigInt(utxo.token_data.amount),\n                nft: utxo.token_data.nft ? {\n                    commitment: hexToBin(utxo.token_data.nft.commitment),\n                    capability: utxo.token_data.nft.capability,\n                } : undefined\n            } : undefined\n        };\n    }\n    static getChangeOutput(value, amount, category, privateKey, addressIndex = 0) {\n        if (category && typeof category !== \"string\")\n            category = binToHex(category);\n        const lockingBytecode = privateKey ? {\n            compiler: this.compiler,\n            data: {\n                hdKeys: {\n                    addressIndex: addressIndex,\n                    hdPublicKeys: {\n                        'wallet': deriveHdPublicKey(privateKey).hdPublicKey\n                    },\n                },\n            },\n            script: 'wallet_lock'\n        } : Uint8Array.from(Array(33));\n        return {\n            lockingBytecode: lockingBytecode,\n            valueSatoshis: value,\n            token: amount > 0 && category ? {\n                category: hexToBin(category),\n                amount: amount,\n            } : undefined\n        };\n    }\n    static getAuthLayers(authUtxo, privateKey, addressIndex = 0) {\n        let inputs = [];\n        let outputs = [];\n        let sourceOutputs = [];\n        sourceOutputs.push(this.getWalletSourceOutput(authUtxo, privateKey, addressIndex));\n        inputs.push(this.getWalletInput(authUtxo, privateKey, addressIndex));\n        outputs.push(this.getAuthWalletOutput(authUtxo, privateKey, addressIndex));\n        return { inputs, outputs, sourceOutputs };\n    }\n    static setBlackBoardLayers(authCat, assetCat, utxos, orders, sourceOutputs = []) {\n        let inputs = [];\n        let outputs = [];\n        inputs.push(...utxos.map(u => this.getInput(authCat, assetCat, u)));\n        sourceOutputs.push(...utxos.map(u => this.getSourceOutput(authCat, assetCat, u)));\n        outputs.push(...orders.map(o => this.orderRequestToOutputs(authCat, assetCat, o)).flat());\n        return { inputs, outputs, sourceOutputs };\n    }\n    static getBlackBoardLayers(orders, tradeAmount, sourceOutputs = []) {\n        let inputs = [];\n        let outputs = [];\n        // Filter available orders to match direction of trade\n        orders = orders.filter(o => Math.sign(Number(o.quantity)) != Math.sign(Number(tradeAmount)));\n        // Check if we still have a market\n        if (orders.length == 0)\n            throw Error(\"no orders left, maximum recursion depth reached.\");\n        const sortFn = tradeAmount > 0 ?\n            ((a, b) => Number(a.price - b.price)) :\n            ((a, b) => Number(a.price + b.price));\n        // sort orders by price\n        orders.sort(sortFn);\n        // pop the best order\n        const best = orders.shift();\n        if (!best)\n            throw Error(\"No matching best order found.\");\n        if (!best.assetUtxo)\n            throw Error(\"Order missing asset utxo\");\n        // Push order thread inputs\n        inputs.push(this.getInput(best.authCategory, best.assetCategory, best.orderUtxo));\n        inputs.push(this.getInput(best.authCategory, best.assetCategory, best.assetUtxo));\n        // Push source outputs\n        sourceOutputs.push(this.getSourceOutput(best.authCategory, best.assetCategory, best.orderUtxo));\n        sourceOutputs.push(this.getSourceOutput(best.authCategory, best.assetCategory, best.assetUtxo));\n        // The best priced order satisfies the amount needed, and we go no further\n        if (Math.abs(Number(tradeAmount)) <= Math.abs(Number(best.quantity))) {\n            outputs.push(...this.getOrderOutput(best, tradeAmount));\n        }\n        // The best priced order cannot satisfy the quantity needed, \n        // so liquidate it and try again.\n        else {\n            // liquidate the best order\n            outputs.push(...this.getOrderOutput(best, -best.quantity));\n            tradeAmount += best.quantity;\n            // and try again\n            let nextTry = this.getBlackBoardLayers([...orders], tradeAmount, [...sourceOutputs]);\n            inputs.push(...nextTry.inputs);\n            outputs.push(...nextTry.outputs);\n            sourceOutputs = nextTry.sourceOutputs;\n        }\n        return { inputs, outputs, sourceOutputs };\n    }\n    static getWalletInputs(utxos, amount, privateKey, category, sourceOutputs = []) {\n        let inputs = [];\n        let outputs = [];\n        if (category && typeof category !== \"string\")\n            category = binToHex(category);\n        // Only use straight sat utxos if placing Bch\n        if (!category) {\n            utxos = utxos.filter(u => !u.token_data);\n        }\n        else {\n            console.log(utxos);\n            utxos = utxos\n                .filter(u => u.token_data && u.token_data?.category == category)\n                // Must not contain NFTs\n                .filter(u => u.token_data && !u.token_data.nft);\n            console.log(utxos);\n        }\n        // TODO: sort by highest value first\n        if (utxos.length == 0)\n            throw Error(\"no wallet utxos left, maximum recursion depth reached.\");\n        // get a random utxo.\n        const randomIdx = Math.floor(Math.random() * utxos.length);\n        const randomUtxo = utxos[randomIdx];\n        // remove the random utxo in place\n        utxos.splice(randomIdx, 1);\n        // spend the utxo\n        inputs.push(this.getWalletInput(randomUtxo, privateKey));\n        sourceOutputs.push(this.getWalletSourceOutput(randomUtxo, privateKey));\n        let sumSats = sumSourceOutputValue(sourceOutputs);\n        let sumTokenAmounts = sumSourceOutputTokenAmounts(sourceOutputs, category);\n        if (\n        // collecting tokens, but the amount is not sufficient\n        (category && sumTokenAmounts < amount) ||\n            // or collecting sats and not enough sats inputs \n            (!category && sumSats < amount)) {\n            // to it again\n            let nextTry = this.getWalletInputs([...utxos], amount, privateKey, category, [...sourceOutputs]);\n            inputs.push(...nextTry.inputs);\n            outputs.push(...nextTry.outputs);\n            sourceOutputs = nextTry.sourceOutputs;\n        }\n        return { inputs, outputs, sourceOutputs };\n    }\n    static getWalletLayers(assetCat, config, sourceOutputs, walletUtxos, privateKey) {\n        // Calculate excess cash and tokens required to fund the exchange\n        let sumSatsOut = sumOutputValue(config.outputs);\n        let sumSatsIn = sumSourceOutputValue(sourceOutputs);\n        let satsRequired = sumSatsOut - sumSatsIn;\n        const satsIn = this.getWalletInputs(walletUtxos, satsRequired, privateKey);\n        config.inputs.push(...satsIn.inputs);\n        sourceOutputs.push(...satsIn.sourceOutputs);\n        let sumTokenAmountsOut = sumOutputTokenAmounts(config.outputs, assetCat);\n        let sumTokenAmountsIn = sumSourceOutputTokenAmounts(sourceOutputs, assetCat);\n        let tokensRequired = sumTokenAmountsOut - sumTokenAmountsIn;\n        console.log(\"Tokens required:\", tokensRequired);\n        if (tokensRequired > 0n) {\n            const tokensIn = this.getWalletInputs(walletUtxos, tokensRequired, privateKey, assetCat);\n            config.inputs.push(...tokensIn.inputs);\n            sourceOutputs.push(...tokensIn.sourceOutputs);\n        }\n        // Calculate excess cash and tokens to be returned as change\n        sumSatsOut = sumOutputValue(config.outputs);\n        sumSatsIn = sumSourceOutputValue(sourceOutputs);\n        let cashChange = sumSatsIn - sumSatsOut;\n        sumTokenAmountsOut = sumOutputTokenAmounts(config.outputs, assetCat);\n        sumTokenAmountsIn = sumSourceOutputTokenAmounts(sourceOutputs, assetCat);\n        let tokenChange = sumTokenAmountsIn - sumTokenAmountsOut;\n        if (tokenChange > 0) {\n            config.outputs.push(this.getChangeOutput(800n, tokenChange, assetCat, privateKey));\n            cashChange -= 800n;\n        }\n        config.outputs.push(this.getChangeOutput(cashChange, 0n, undefined, privateKey));\n        return config;\n    }\n    /**\n     * Administer CatDex Blackboard\n     *\n     * Create, rebalance, or withdraw assets from a contract.\n     *\n     * To create an exchange, specify a list of new orders against an empty contract utxo state.\n     *\n     * To rebalance the orders on an existing exchange, provide the complete list of\n     * current contract utxos and the desired new order state.\n     *\n     * To withdraw, specify the current utxos without new orders.\n     *\n     * @param assetCat - Category of the asset traded\n     * @param authUtxo - Exchange authentication (minting) baton\n     * @param contractUtxos - Current utxo state.\n     * @param orders - List of next desired order state.\n     * @param walletUtxos - wallet outputs to use as input.\n     * @param privateKey - private key to sign transaction wallet inputs.\n     * @param fee - transaction fee to pay (per byte).\n     *\n     * @throws {Error} if transaction generation fails.\n     * @returns a transaction template.\n     */\n    static administer(authUtxo, assetCat, contractUtxos, orders, walletUtxos, privateKey, addressIndex = 0, fee = 1) {\n        const inputs = [];\n        const outputs = [];\n        let config = {\n            locktime: 0,\n            version: 2,\n            inputs,\n            outputs\n        };\n        let authCat = authUtxo.token_data.category;\n        // Build authentication baton layer\n        const authLayers = this.getAuthLayers(authUtxo, privateKey, addressIndex);\n        config.inputs.push(...authLayers.inputs);\n        config.outputs.push(...authLayers.outputs);\n        let sourceOutputs = authLayers.sourceOutputs;\n        const blackBoardLayers = this.setBlackBoardLayers(authCat, assetCat, contractUtxos, orders);\n        config.inputs.push(...blackBoardLayers.inputs);\n        config.outputs.push(...blackBoardLayers.outputs);\n        sourceOutputs.push(...blackBoardLayers.sourceOutputs);\n        config = this.getWalletLayers(assetCat, config, sourceOutputs, walletUtxos, privateKey);\n        let result = generateTransaction(config);\n        if (!result.success)\n            throw new Error('generate transaction failed!, errors: ' + JSON.stringify(result.errors, null, '  '));\n        const estimatedFee = getTransactionFees(result.transaction, fee);\n        const lastIdx = config.outputs.length - 1;\n        config.outputs[lastIdx].valueSatoshis = config.outputs[lastIdx].valueSatoshis - estimatedFee;\n        result = generateTransaction(config);\n        if (!result.success)\n            throw new Error('generate transaction failed!, errors: ' + JSON.stringify(result.errors, null, '  '));\n        const transaction = result.transaction;\n        const tokenValidationResult = verifyTransactionTokens(transaction, sourceOutputs, { maximumTokenCommitmentLength: 40 });\n        if (tokenValidationResult !== true && fee > 0)\n            throw tokenValidationResult;\n        let verify = this.vm.verify({\n            sourceOutputs: sourceOutputs,\n            transaction: transaction,\n        });\n        if (typeof verify == \"string\")\n            throw Error(verify);\n        let feeEstimate = sumSourceOutputValue(sourceOutputs) - sumSourceOutputValue(transaction.outputs);\n        if (feeEstimate > 5000)\n            verify = `Excessive fees ${feeEstimate}`;\n        if (sumSourceOutputTokenAmounts(sourceOutputs, assetCat) == 0n)\n            verify = `Error checking token input`;\n        let tokenDiff = sumSourceOutputTokenAmounts(sourceOutputs, assetCat) -\n            sumSourceOutputTokenAmounts(transaction.outputs, assetCat);\n        if (tokenDiff !== 0n)\n            verify = `Swapping should not create destroy tokens, token difference: ${tokenDiff}`;\n        return {\n            sourceOutputs: sourceOutputs,\n            transaction: transaction,\n            verify: verify\n        };\n    }\n    /**\n     * Swap\n     *\n     * Build a transaction (with best execution) for the given amount of tokens.\n     *\n     * Buy tokens by specifying a positive amount, and a negative amount to sell.\n     *\n     *\n     * @param amount - token amount to buy, or sell negative (-).\n     * @param catDexOrders - A multi-exchange list of available catdex orders for a token.\n     * @param walletUtxos - wallet outputs to use as input.\n     * @param privateKey - private key to sign transaction wallet inputs.\n     * @param fee - transaction fee to pay (per byte).\n     *\n     * @throws {Error} if transaction generation fails.\n     * @returns a transaction template.\n     */\n    static swap(tradeAmount, catDexOrders, walletUtxos, privateKey, fee = 1) {\n        const inputs = [];\n        const outputs = [];\n        let sourceOutputs = [];\n        let assetCat = binToHex(catDexOrders[0]?.assetCategory);\n        let assetTypes = new Set(catDexOrders.map(o => binToHex(o.assetCategory)));\n        if (assetTypes.size > 1)\n            throw (\"A catdex swap may only trade one asset at a time, mixed assets found.\");\n        // Check all catDex\n        let config = {\n            locktime: 0,\n            version: 2,\n            inputs,\n            outputs\n        };\n        // if selling tokens for Bch for tokens, don't use utxos with other tokens\n        walletUtxos = walletUtxos.filter(u => u.token_data?.category == assetCat || !u.token_data);\n        let vaultLayers = this.getBlackBoardLayers(catDexOrders, tradeAmount, sourceOutputs);\n        config.inputs.push(...vaultLayers.inputs);\n        config.outputs.push(...vaultLayers.outputs);\n        sourceOutputs = vaultLayers.sourceOutputs;\n        config = this.getWalletLayers(assetCat, config, sourceOutputs, walletUtxos, privateKey);\n        let result = generateTransaction(config);\n        if (!result.success)\n            throw new Error('generate transaction failed!, errors: ' + JSON.stringify(result.errors, null, '  '));\n        const estimatedFee = getTransactionFees(result.transaction, fee);\n        const lastIdx = config.outputs.length - 1;\n        config.outputs[lastIdx].valueSatoshis = config.outputs[lastIdx].valueSatoshis - estimatedFee;\n        result = generateTransaction(config);\n        if (!result.success)\n            throw new Error('generate transaction failed!, errors: ' + JSON.stringify(result.errors, null, '  '));\n        const transaction = result.transaction;\n        const tokenValidationResult = verifyTransactionTokens(transaction, sourceOutputs, { maximumTokenCommitmentLength: 40 });\n        if (tokenValidationResult !== true && fee > 0)\n            throw tokenValidationResult;\n        let verify = this.vm.verify({\n            sourceOutputs: sourceOutputs,\n            transaction: transaction,\n        });\n        let feeEstimate = sumSourceOutputValue(sourceOutputs) - sumSourceOutputValue(transaction.outputs);\n        if (feeEstimate > 5000)\n            verify = `Excessive fees ${feeEstimate}`;\n        if (sumSourceOutputTokenAmounts(sourceOutputs, assetCat) == 0n)\n            verify = `Error checking token input`;\n        let tokenDiff = sumSourceOutputTokenAmounts(sourceOutputs, assetCat) -\n            sumSourceOutputTokenAmounts(transaction.outputs, assetCat);\n        if (tokenDiff !== 0n)\n            verify = `Swapping should not create destroy tokens, token difference: ${tokenDiff}`;\n        return {\n            sourceOutputs: sourceOutputs,\n            transaction: transaction,\n            verify: verify\n        };\n    }\n}\nexport async function getAllMarketOrders(electrumClient, scriptHashes) {\n    let allUnspent = (await promiseAllInBatches(listUnspentTokensWrap, scriptHashes.map(a => [electrumClient, a]))).flat();\n    var map = new Map();\n    allUnspent.map((obj) => map.set(obj.tx_hash + \":\" + obj.tx_pos, obj));\n    return map;\n}\n//# sourceMappingURL=index.js.map","<script lang=\"ts\">\n\timport { onMount, onDestroy } from 'svelte';\n\timport { goto } from '$app/navigation';\n\timport { page } from '$app/state';\n\timport type { PageProps } from './$types';\n\n\timport Chat from '$lib/Chat.svelte';\n\timport Transaction from '$lib/Transaction.svelte';\n\timport CatDexOrder from '$lib/CatDexOrder.svelte';\n\timport Utxo from '$lib/Utxo.svelte';\n\n\timport BCMR from '$lib/bitcoin-cash-metadata-registry.json' with { type: 'json' };\n\timport tBCMR from '$lib/chipnet-metadata-registry.json' with { type: 'json' };\n\n\timport Readme from './README.md';\n\n\timport { default as CatDex, getAllMarketOrders } from '@unspent/catdex';\n\n\timport SmallIndex from '@unspent/small';\n\n\timport BitauthLink from '$lib/BitauthLink.svelte';\n\timport CONNECTED from '$lib/images/connected.svg';\n\timport DISCONNECTED from '$lib/images/disconnected.svg';\n\n\timport {\n\t\tbinToHex,\n\t\tcashAddressToLockingBytecode,\n\t\tencodeTransactionBch,\n\t\tstringify\n\t} from '@bitauth/libauth';\n\n\timport { ElectrumClient, ConnectionStatus } from '@electrum-cash/network';\n\timport { BaseWallet, Wallet, TestNetWallet, NFTCapability, TokenMintRequest } from 'mainnet-js';\n\n\timport { IndexedDBProvider } from '@mainnet-cash/indexeddb-storage';\n\n\timport BCH from '$lib/images/BCH.svg';\n\timport tBCH from '$lib/images/tBCH.svg';\n\n\timport {\n\t\tcashAssemblyToHex,\n\t\tgetScriptHash,\n\t\tgetHdPrivateKey,\n\t\tsumUtxoValue,\n\t\tsumTokenAmounts,\n\t\ttype UtxoI\n\t} from '@unspent/tau';\n\timport TokenIcon from '$lib/TokenIcon.svelte';\n\timport Ticker from '$lib/Ticker.svelte';\n\n\tlet { data }: PageProps = $props();\n\tlet selectedAsset = $state(data.asset);\n\n\tlet now: number = $state(0);\n\n\tlet key = $state('');\n\tlet coupons: any[] | undefined = $state();\n\tlet electrumClient: any;\n\tlet walletScriptHash = $state('');\n\tlet amount = $state(0n);\n\tlet connectionStatus = $state('');\n\tlet contractState = $state('');\n\tlet timer: any;\n\n\tlet unspent: any[] = $state([]);\n\tlet walletUnspent: any[] = $state([]);\n\tlet orders: any[] = $state([]);\n\tlet myOrders: any[] = $state([]);\n\tlet myOrderBook: any[] = $state([]);\n\tlet myMarketRecord: any = $state();\n\tlet myMarketTokens: any = $state();\n\tlet myMarketSatoshis: any = $state();\n\tlet myMembership: any = $state(0);\n\tlet myAuthBatons: any[] = $state([]);\n\tlet myDexUtxos: any[] = $state([]);\n\tlet authBatons: any[] = $state([]);\n\tlet showSettings = $state(false);\n\tlet showChat = $state(false);\n\n\tlet transaction_hex = '';\n\tlet transaction: any = $state(undefined);\n\tlet transactionValid = $state(false);\n\tlet sourceOutputs: any = $state();\n\tlet transactionError: string | boolean = $state('');\n\n\tlet balance = $state(0);\n\tlet assetBalance = $state(0n);\n\n\tconst isMainnet = page.url.hostname == 'vox.cash';\n\tconst prefix = isMainnet ? 'bitcoincash' : 'bchtest';\n\tconst baseTicker = isMainnet ? 'BCH' : 'tBCH';\n\tconst server = isMainnet ? 'bch.imaginary.cash' : 'chipnet.bch.ninja';\n\tconst metadata = isMainnet ? BCMR : tBCMR;\n\tconst bchIcon = isMainnet ? BCH : tBCH;\n\n\tif (typeof selectedAsset !== 'string') {\n\t\tselectedAsset = isMainnet\n\t\t\t? '7fe0cd5197494e47ade81eb164dcdbd51859ffbe581fe4a818085d56b2f3062c'\n\t\t\t: 'ffc9d3b3488e890ef113b1c74f40e1f5eb1147a7d4191cecac89fd515721a271';\n\t}\n\n\tconst protocol_prefix = cashAssemblyToHex(`OP_RETURN <\"${CatDex.PROTOCOL_IDENTIFIER}\">`);\n\n\tlet wallet: any;\n\n\tconst bcmr = Object.entries(metadata.identities)\n\t\t.map((o) => {\n\t\t\treturn Object.values(Object.values(o[1]));\n\t\t})\n\t\t.flat()\n\t\t.filter(o => o.extensions && o.extensions.exchanges == \"catdex\")\n\t\t.reduce((acc, o) => {\n\t\t\tacc.set(o.token.category, o);\n\t\t\treturn acc;\n\t\t}, new Map());\n\n\tconst debounceUpdateWallet = () => {\n\t\tclearTimeout(timer);\n\t\ttimer = setTimeout(() => {\n\t\t\tupdateWallet();\n\t\t\tupdateOrders();\n\t\t}, 1500);\n\t};\n\n\tasync function updateOrders() {\n\t\tif (electrumClient && now > 1000) {\n\t\t\tlet marketMakers = await electrumClient.request(\n\t\t\t\t'blockchain.scripthash.listunspent',\n\t\t\t\tSmallIndex.getScriptHash(CatDex.PROTOCOL_IDENTIFIER),\n\t\t\t\t'include_tokens'\n\t\t\t);\n\n\t\t\tauthBatons = marketMakers\n\t\t\t\t.map((u: UtxoI) => {\n\t\t\t\t\treturn u.token_data?.category;\n\t\t\t\t})\n\t\t\t\t.filter((v: number, i: number, array: string[]) => array.indexOf(v) === i);\n\n\t\t\tlet marketScriptHashes = authBatons.map((authCat: string) => {\n\t\t\t\treturn CatDex.getScriptHash(authCat, selectedAsset);\n\t\t\t});\n\n\t\t\tlet rawOrders = await getAllMarketOrders(electrumClient, marketScriptHashes);\n\t\t\tlet utxos = Array.from(rawOrders.values());\n\t\t\torders = CatDex.getCatDexOrdersFromUtxos(selectedAsset, utxos);\n\n\t\t\tif (myAuthBatons.length > 0) {\n\t\t\t\tlet myRawOrders = await getAllMarketOrders(electrumClient, [\n\t\t\t\t\tCatDex.getScriptHash(myAuthBatons[0].token_data.category, selectedAsset)\n\t\t\t\t]);\n\n\t\t\t\tmyDexUtxos = Array.from(myRawOrders.values());\n\n\t\t\t\tmyMarketTokens = sumTokenAmounts(myDexUtxos, selectedAsset);\n\t\t\t\tmyMarketSatoshis = sumUtxoValue(myDexUtxos);\n\t\t\t\tmyOrders = CatDex.getCatDexOrdersFromUtxos(selectedAsset, myDexUtxos);\n\t\t\t}\n\t\t}\n\t}\n\n\tconst updateWallet = async function () {\n\t\tlet response = await electrumClient.request(\n\t\t\t'blockchain.scripthash.listunspent',\n\t\t\twalletScriptHash,\n\t\t\t'include_tokens'\n\t\t);\n\t\tif (response instanceof Error) throw response;\n\n\t\tmyAuthBatons = response.filter(\n\t\t\t(u: UtxoI) =>\n\t\t\t\tu.token_data && u.token_data.nft && u.token_data.nft.commitment.startsWith(protocol_prefix)\n\t\t);\n\n\t\tif (typeof selectedAsset == 'string') {\n\t\t\twalletUnspent = response.filter(\n\t\t\t\t(u: UtxoI) => !u.token_data || u.token_data.category == selectedAsset\n\t\t\t);\n\t\t\tassetBalance = sumTokenAmounts(walletUnspent, selectedAsset);\n\t\t} else {\n\t\t\twalletUnspent = response.filter((u: UtxoI) => !u.token_data);\n\t\t\tassetBalance = 0n;\n\t\t}\n\t\tbalance = sumUtxoValue(walletUnspent, true);\n\t};\n\n\tconst newAuthBaton = async function () {\n\t\tawait wallet.sendMax(wallet.getDepositAddress());\n\t\tlet uname = cashAssemblyToHex(\n\t\t\t`OP_RETURN <\"${CatDex.PROTOCOL_IDENTIFIER}\"> <\"markets are made\">`\n\t\t);\n\t\tlet sendResponse = await wallet.tokenGenesis({\n\t\t\tcashaddr: wallet.getTokenDepositAddress()!, // token UTXO recipient, if not specified will default to sender's address\n\t\t\tcommitment: uname, // NFT Commitment message\n\t\t\tcapability: NFTCapability.minting, // NFT capability\n\t\t\tvalue: 800 // Satoshi value\n\t\t});\n\t};\n\n\tconst announceAuthBaton = async function (duration: number) {\n\t\tlet message = cashAssemblyToHex(`OP_RETURN <\"markets are made\">`);\n\t\tlet sendResponse = await wallet.tokenMint(myAuthBatons[0].token_data.category, [\n\t\t\tnew TokenMintRequest({\n\t\t\t\tcashaddr: SmallIndex.getAddress(CatDex.PROTOCOL_IDENTIFIER)!,\n\t\t\t\tcommitment: message,\n\t\t\t\tcapability: NFTCapability.none,\n\t\t\t\tvalue: duration\n\t\t\t})\n\t\t]);\n\t};\n\n\tconst updateAsset = async function () {\n\t\tawait updateWallet();\n\t\tawait updateOrders();\n\t\tif (typeof selectedAsset == 'string') {\n\t\t\tgoto(`?asset=${selectedAsset}`, { keepFocus: true });\n\t\t\tassetBalance = sumTokenAmounts(walletUnspent, selectedAsset);\n\t\t} else {\n\t\t\tassetBalance = 0n;\n\t\t}\n\t};\n\n\tconst addMyOrder = function (i: number) {\n\t\tif (myOrderBook.length + 1 == i) {\n\t\t\tmyOrderBook.splice(i, 0, { quantity: undefined, price: undefined });\n\t\t} else if (myOrderBook.length >= 2) {\n\t\t\tlet o = myOrderBook.slice(-2);\n\t\t\tmyOrderBook.push({\n\t\t\t\tquantity: o[1].quantity - (o[0].quantity - o[1].quantity),\n\t\t\t\tprice: o[1].price - (o[0].price - o[1].price)\n\t\t\t});\n\t\t} else {\n\t\t\tmyOrderBook.push({ quantity: undefined, price: undefined });\n\t\t}\n\t};\n\n\tconst dropOrder = function (i) {\n\t\tmyOrderBook.splice(i, 1);\n\t};\n\n\tconst postOrders = async function (replace = false) {\n\t\tlet oldOrders = replace ? myDexUtxos : [];\n\n\t\tlet tx = CatDex.administer(\n\t\t\tmyAuthBatons[0],\n\t\t\tselectedAsset!,\n\t\t\toldOrders,\n\t\t\tmyOrderBook,\n\t\t\twalletUnspent,\n\t\t\tkey\n\t\t);\n\t\tlet transaction_hex = binToHex(encodeTransactionBch(tx.transaction));\n\t\tlet response = await broadcast(transaction_hex);\n\t\tif (response.length == 64) myOrderBook = [];\n\t};\n\n\tconst updateSwap = function () {\n\t\tif (amount) {\n\t\t\ttry {\n\t\t\t\tlet result = CatDex.swap(BigInt(amount), orders, walletUnspent, key);\n\t\t\t\ttransaction = result.transaction;\n\t\t\t\tsourceOutputs = result.sourceOutputs;\n\t\t\t\ttransaction_hex = binToHex(encodeTransactionBch(transaction));\n\t\t\t\ttransactionValid = result.verify === true ? true : false;\n\t\t\t\tif (result.verify === true) transactionError = '';\n\t\t\t} catch (error: any) {\n\t\t\t\ttransaction = undefined;\n\t\t\t\tsourceOutputs = undefined;\n\t\t\t\ttransaction_hex = '';\n\t\t\t\ttransactionValid = false;\n\t\t\t\ttransactionError = error;\n\t\t\t}\n\t\t}\n\t};\n\n\tconst broadcast = async function (raw_tx: string) {\n\t\tlet response = await electrumClient.request('blockchain.transaction.broadcast', raw_tx);\n\t\tif (response instanceof Error) {\n\t\t\tconnectionStatus = ConnectionStatus[electrumClient.status];\n\t\t\ttransactionError = response.message;\n\t\t\tthrow response;\n\t\t}\n\t\tresponse as any[];\n\t\ttransaction = undefined;\n\t\tsourceOutputs = undefined;\n\t\ttransaction_hex = '';\n\t\ttransactionValid = false;\n\t\treturn response;\n\t};\n\n\tconst handleNotifications = function (data: any) {\n\t\tconnectionStatus = ConnectionStatus[electrumClient.status];\n\t\tif (data.method === 'blockchain.headers.subscribe') {\n\t\t\tlet d = data.params[0];\n\t\t\tnow = d.height;\n\t\t\tupdateOrders();\n\t\t\tupdateWallet();\n\t\t} else if (data.method === 'blockchain.scripthash.subscribe') {\n\t\t\t// data.params[0]\n\t\t\t// TODO: only update matching utxos\n\t\t\tdebounceUpdateWallet();\n\t\t} else {\n\t\t\tconsole.log(data);\n\t\t}\n\t};\n\n\tonMount(async () => {\n\t\tBaseWallet.StorageProvider = IndexedDBProvider;\n\t\twallet = isMainnet ? await Wallet.named(`vox`) : await TestNetWallet.named(`vox`);\n\n\t\tkey = getHdPrivateKey(wallet.mnemonic!, wallet.derivationPath.slice(0, -2), wallet.isTestnet);\n\t\tlet lockcodeResult = cashAddressToLockingBytecode(wallet.getDepositAddress());\n\t\tif (typeof lockcodeResult == 'string') throw lockcodeResult;\n\t\twalletScriptHash = getScriptHash(lockcodeResult.bytecode);\n\n\t\t// Initialize an electrum client.\n\t\telectrumClient = new ElectrumClient(CatDex.USER_AGENT, '1.4.1', server);\n\n\t\t// Wait for the client to connect.\n\t\tawait electrumClient.connect();\n\t\t// Set up a callback function to handle new blocks.\n\n\t\t// Listen for notifications.\n\t\telectrumClient.on('notification', handleNotifications);\n\n\t\t// Set up a subscription for new block headers.\n\t\tawait electrumClient.subscribe('blockchain.headers.subscribe');\n\n\t\tawait electrumClient.subscribe('blockchain.scripthash.subscribe', walletScriptHash);\n\n\t\t// Get a list of\n\t\tlet marketMakers = await electrumClient.request(\n\t\t\t'blockchain.scripthash.listunspent',\n\t\t\tSmallIndex.getScriptHash(CatDex.PROTOCOL_IDENTIFIER),\n\t\t\t'include_tokens'\n\t\t);\n\n\t\tauthBatons = marketMakers.map((u: UtxoI) => {\n\t\t\treturn u.token_data?.category;\n\t\t});\n\n\t\tmyMarketRecord = marketMakers\n\t\t\t.filter((u) => u.token_data?.category == myAuthBatons[0].token_data.category)\n\t\t\t.pop();\n\t\tmyMembership =\n\t\t\tmyMarketRecord && myMarketRecord.height > 0\n\t\t\t\t? myMarketRecord.height + myMarketRecord.value - now\n\t\t\t\t: 0;\n\t\tlet marketScriptHashes = authBatons.map((authCat: string) => {\n\t\t\treturn CatDex.getScriptHash(authCat, selectedAsset);\n\t\t});\n\n\t\tmarketScriptHashes.map(async (s) => {\n\t\t\tawait electrumClient.subscribe('blockchain.scripthash.subscribe', s);\n\t\t});\n\n\t\tawait electrumClient.subscribe(\n\t\t\t'blockchain.scripthash.subscribe',\n\t\t\tSmallIndex.getScriptHash(CatDex.PROTOCOL_IDENTIFIER)\n\t\t);\n\t});\n\n\tonDestroy(async () => {\n\t\tawait wallet!.provider.disconnect();\n\t\tawait electrumClient.disconnect();\n\t});\n</script>\n\n{#if showChat}\n\t<div class=\"trollbox\">\n\t\t<Chat topic={CatDex.PROTOCOL_IDENTIFIER} />\n\t\t<label class=\"switch\">\n\t\t\tHide\n\t\t\t<input type=\"checkbox\" bind:checked={showChat} />\n\t\t\t<span class=\"slider round\"></span>\n\t\t</label>\n\t</div>\n{/if}\n\n<svelte:head>\n\t<title> CatDex</title>\n\t<meta\n\t\tname=\"description\"\n\t\tcontent=\"CatDex - a decentralized limit order exchange and dex aggregator on Bitcoin Cash.\"\n\t/>\n</svelte:head>\n\n<section>\n\t<div class=\"status\">\n\t\t<BitauthLink template={CatDex.template} />\n\t\t{#if connectionStatus == 'CONNECTED'}\n\t\t\t<img src={CONNECTED} alt={connectionStatus} />\n\t\t{:else}\n\t\t\t<img src={DISCONNECTED} alt=\"Disconnected\" />\n\t\t{/if}\n\t</div>\n\n\t<h1>Trade CashTokens</h1>\n\t{#if connectionStatus == 'CONNECTED'}\n\t\t<b>Asset:</b>\n\t\t<select bind:value={selectedAsset} onchange={() => updateAsset()}>\n\t\t\t{#each bcmr.keys() as token}\n\t\t\t\t<option value={token}>\n\t\t\t\t\t{bcmr.get(token).name}\n\t\t\t\t</option>\n\t\t\t{/each}\n\t\t</select>\n\t\t<br />\n\t\t{#if selectedAsset}\n\t\t\t<div class=\"swap\">\n\t\t\t\t<div>\n\t\t\t\t\t<img width=\"50\" src={bchIcon} alt={baseTicker} />\n\t\t\t\t\t<br />\n\t\t\t\t\t{balance.toLocaleString()} sats {baseTicker}\n\t\t\t\t</div>\n\t\t\t\t<div>\n\t\t\t\t\t<img\n\t\t\t\t\t\twidth=\"50\"\n\t\t\t\t\t\tsrc={bcmr.get(selectedAsset).uris.icon}\n\t\t\t\t\t\talt={bcmr.get(selectedAsset).token.symbol}\n\t\t\t\t\t/>\n\t\t\t\t\t<br />\n\t\t\t\t\t{(\n\t\t\t\t\t\tassetBalance / BigInt(Math.pow(10, bcmr.get(selectedAsset).token.decimals))\n\t\t\t\t\t).toLocaleString()}\n\t\t\t\t\t{bcmr.get(selectedAsset).token.symbol}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t{/if}\n\t\t<br />\n\n\t\t{#if balance > 0}\n\t\t\t<div class=\"swap\">\n\t\t\t\t<label>Swap amount: </label>\n\t\t\t\t<input type=\"number\" bind:value={amount} min=\"0\" max=\"10\" onchange={() => updateSwap()} />\n\t\t\t</div>\n\t\t{:else}\n\t\t\t<div class=\"swap\">\n\t\t\t\t<p><a href=\"/wallet\">Deposit funds</a> to trade assets.</p>\n\t\t\t</div>\n\t\t{/if}\n\t\t<br />\n\t\t{#if transaction && transactionValid}\n\t\t\t<div class=\"swap\">\n\t\t\t\t<button onclick={() => broadcast(transaction_hex)}>Broadcast</button>\n\t\t\t</div>\n\t\t\t<Transaction {transaction} {sourceOutputs} category={selectedAsset} />\n\t\t{/if}\n\t\t{transactionError}\n\n\t\t<div class=\"orderBooks\">\n\t\t\t<div>\n\t\t\t\t{#each orders.filter((o) => o.quantity > 0) as o}\n\t\t\t\t\t<CatDexOrder {...o} assetCategory={selectedAsset} {...{ isMainnet: isMainnet }} />\n\t\t\t\t{/each}\n\t\t\t</div>\n\t\t\t<div class=\"askBook\">\n\t\t\t\t{#each orders.filter((o) => o.quantity < 0).toReversed() as o}\n\t\t\t\t\t<CatDexOrder {...o} assetCategory={selectedAsset} {...{ isMainnet: isMainnet }} />\n\t\t\t\t{/each}\n\t\t\t</div>\n\t\t</div>\n\n\t\t<h3>Advanced</h3>\n\n\t\t<label class=\"switch\">\n\t\t\t<input type=\"checkbox\" bind:checked={showSettings} />\n\t\t\t<span class=\"slider round\"></span>\n\t\t</label>\n\t\t<br />\n\n\t\t{#if showSettings}\n\t\t\t<br />\n\t\t\t<div>\n\t\t\t\t{#if myMembership < 1000}\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\tYou have a CatDex baton. <br />\n\t\t\t\t\t\t\tFor others to can find your orders, announce your membership in the CatDex.\n\t\t\t\t\t\t</p>\n\t\t\t\t\t\t<button onclick={() => announceAuthBaton(4364)}>Month (4364 sats)</button>\n\t\t\t\t\t\t<button onclick={() => announceAuthBaton(52596)}>Year (52596 sats) </button>\n\t\t\t\t\t\t<p>Membership fees are non-refundable and are claimed by miners.</p>\n\t\t\t\t\t\t{#if myMembership > 0}\n\t\t\t\t\t\t\t<b\n\t\t\t\t\t\t\t\t>Membership expires in {myMembership} blocks. Renew now to have your orders discoverable.</b\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t{:else}\n\t\t\t\t\t\t\t<b\n\t\t\t\t\t\t\t\t>Membership expired {myMembership} blocks ago. Renew now to keep your orders discoverable.</b\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t{/if}\n\t\t\t\t\t</div>\n\n\t\t\t\t\t<br />\n\t\t\t\t{/if}\n\n\t\t\t\t{#if balance < 1000 && walletUnspent.length == 0}\n\t\t\t\t\t<a href=\"/wallet\">Deposit funds</a> to create a CatDex authentication baton.\n\t\t\t\t{:else if myAuthBatons.length == 0}\n\t\t\t\t\t<p>To write orders, you need to create a CatDex Authentication Baton (1000 sats).</p>\n\t\t\t\t\t<button onclick={() => newAuthBaton()}>Create a new Baton</button>\n\t\t\t\t{:else}\n\t\t\t\t\t<h3>Your Decentralized Listing</h3>\n\t\t\t\t\t{#each myAuthBatons as authBaton}\n\t\t\t\t\t\t<TokenIcon size={24} category={authBaton.token_data.category}></TokenIcon>\n\t\t\t\t\t{/each}\n\t\t\t\t\t<div class=\"swap\">\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t<img width=\"24\" src={bchIcon} alt={baseTicker} />\n\t\t\t\t\t\t\t<br />\n\t\t\t\t\t\t\t{myMarketSatoshis.toLocaleString()} sats {baseTicker}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t<img\n\t\t\t\t\t\t\t\twidth=\"24\"\n\t\t\t\t\t\t\t\tsrc={bcmr.get(selectedAsset).uris.icon}\n\t\t\t\t\t\t\t\talt={bcmr.get(selectedAsset).token.symbol}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t<br />\n\t\t\t\t\t\t\t{(\n\t\t\t\t\t\t\t\tmyMarketTokens / BigInt(Math.pow(10, bcmr.get(selectedAsset).token.decimals))\n\t\t\t\t\t\t\t).toLocaleString()}\n\t\t\t\t\t\t\t{bcmr.get(selectedAsset).token.symbol}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t{#each myOrders as o}\n\t\t\t\t\t\t<CatDexOrder {...o} assetCategory={selectedAsset} {...{ isMainnet: isMainnet }} />\n\t\t\t\t\t{/each}\n\n\t\t\t\t\t<br />\n\t\t\t\t\t{#if myOrderBook.length > 0}\n\t\t\t\t\t\t<button onclick={() => postOrders(true)}>Replace Orders</button>\n\n\t\t\t\t\t\t<button onclick={() => postOrders()}>Append Orders</button>\n\t\t\t\t\t{:else}\n\t\t\t\t\t\t<button onclick={() => postOrders(true)}> Clear Orders </button>\n\t\t\t\t\t\t<button onclick={() => addMyOrder(0)}>New Orders</button><br />\n\t\t\t\t\t{/if}\n\n\t\t\t\t\t{#if myOrderBook.length > 0}\n\t\t\t\t\t\t<div class=\"orders\">\n\t\t\t\t\t\t\t<div class=\"in\">\n\t\t\t\t\t\t\t\t<b>type</b>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"in\">\n\t\t\t\t\t\t\t\t<b>price</b>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"in\">\n\t\t\t\t\t\t\t\t<b>quantity</b>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"in\"></div>\n\t\t\t\t\t\t\t<div class=\"listButtons\"></div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t{/if}\n\t\t\t\t\t{#each myOrderBook as o, i}\n\t\t\t\t\t\t<div class=\"orders\">\n\t\t\t\t\t\t\t<div class=\"in\">\n\t\t\t\t\t\t\t\t{#if o.quantity > 0}\n\t\t\t\t\t\t\t\t\tBID\n\t\t\t\t\t\t\t\t{:else if o.quantity < 0}\n\t\t\t\t\t\t\t\t\tASK\n\t\t\t\t\t\t\t\t{:else}\n\t\t\t\t\t\t\t\t\t-\n\t\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"in\">\n\t\t\t\t\t\t\t\t<input\n\t\t\t\t\t\t\t\t\ttype=\"number\"\n\t\t\t\t\t\t\t\t\tplaceholder=\"sats per\"\n\t\t\t\t\t\t\t\t\tbind:value={o.price}\n\t\t\t\t\t\t\t\t\tmin=\"1\"\n\t\t\t\t\t\t\t\t\tmax=\"100000\"\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"in\">\n\t\t\t\t\t\t\t\t<input name=\"quantity\" placeholder=\"qty\" type=\"number\" bind:value={o.quantity} />\n\t\t\t\t\t\t\t\t<TokenIcon size={24} category={selectedAsset}></TokenIcon>\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t<div class=\"in\">\n\t\t\t\t\t\t\t\t{#if o.quantity * o.price > 0}\n\t\t\t\t\t\t\t\t\t{Number(o.quantity * o.price).toLocaleString()} sats\n\t\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"listButtons\">\n\t\t\t\t\t\t\t\t<button onclick={() => addMyOrder(i + 1)}>+</button>\n\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\tonclick={() => {\n\t\t\t\t\t\t\t\t\t\tdropOrder(i);\n\t\t\t\t\t\t\t\t\t}}>-</button\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t{/each}\n\n\t\t\t\t\t{#if myOrderBook.length > 0}\n\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\tSell is negative quantity.<br />\n\t\t\t\t\t\t\tAll prices in satoshis\n\t\t\t\t\t\t</p>\n\t\t\t\t\t{/if}\n\t\t\t\t\t<br />\n\t\t\t\t{/if}\n\t\t\t</div>\n\t\t{/if}\n\t\t<br />\n\t\t<br />\n\t\t<h3>Makers</h3>\n\t\t<div class=\"grid\">\n\t\t\t{#each authBatons as authBaton}\n\t\t\t\t<div>\n\t\t\t\t\t<TokenIcon category={authBaton} size={24}></TokenIcon>\n\t\t\t\t</div>\n\t\t\t{/each}\n\t\t</div>\n\t{:else}\n\t\t<div class=\"swap\">\n\t\t\t<p>Not connected.</p>\n\t\t</div>\n\t{/if}\n\n\t<h3>Chat</h3>\n\t<label class=\"switch\">\n\t\t<input type=\"checkbox\" bind:checked={showChat} />\n\t\t<span class=\"slider round\"></span>\n\t</label>\n\n\t<Readme />\n</section>\n\n<style>\n\t.trollbox {\n\t\tposition: fixed;\n\t\tright: 0px;\n\t\tbottom: 0px;\n\t\tbackground: #ffffffbb;\n\t\tz-index: 1;\n\t}\n\t.swap {\n\t\tdisplay: flex;\n\t\tmargin: auto;\n\t\talign-items: center;\n\t\tjustify-content: center;\n\t}\n\t.swap div {\n\t\tpadding: 20px;\n\t\tjustify-content: center;\n\t\ttext-align: center;\n\t}\n\n\t.status {\n\t\ttext-align: end;\n\t}\n\n\t\n\n\t.orderBooks {\n\t\tdisplay: flex;\n\t\tjustify-content: center;\n\t\tflex-wrap: wrap;\n\t}\n\n\t.orderBooks div {\n\t\talign-items: center;\n\t}\n\n\n\t.orders {\n\t\tdisplay: flex;\n\t\tmargin: 5px;\n\t}\n\n\t.orders .in {\n\t\tdisplay: flex;\n\t\tflex: 1;\n\t\talign-items: center;\n\t}\n\n\t.orders .in input {\n\t\tmax-width: 110px;\n\t\tborder-radius: 5px;\n\t}\n\t.orders .listButtons {\n\t\tdisplay: flex;\n\t\tflex: 1;\n\t}\n\n\t.orders .listButtons button {\n\t\tpadding: 0px;\n\t\twidth: 40%;\n\t}\n\n\t.grid {\n\t\tdisplay: flex;\n\t\tflex-direction: row;\n\t\tflex-wrap: wrap;\n\t\talign-items: flex-start;\n\t\ttext-align: center;\n\t}\n\n\tbutton {\n\t\tbackground-color: #a45eb6; /* Green */\n\t\tborder: none;\n\t\tcolor: white;\n\t\tpadding: 10px;\n\t\tborder-radius: 20px;\n\t\ttext-align: center;\n\t\ttext-decoration: none;\n\t\tdisplay: inline-block;\n\t\tfont-size: 16px;\n\t}\n\n\t.switch {\n\t\tposition: relative;\n\t\tdisplay: inline-block;\n\t\twidth: 60px;\n\t\theight: 34px;\n\t}\n\n\t/* Hide default HTML checkbox */\n\t.switch input {\n\t\topacity: 0;\n\t\twidth: 0;\n\t\theight: 0;\n\t}\n\n\t/* The slider */\n\t.slider {\n\t\tposition: absolute;\n\t\tcursor: pointer;\n\t\ttop: 0;\n\t\tleft: 0;\n\t\tright: 0;\n\t\tbottom: 0;\n\t\tbackground-color: #ccc;\n\t\t-webkit-transition: 0.4s;\n\t\ttransition: 0.4s;\n\t}\n\n\t.slider:before {\n\t\tposition: absolute;\n\t\tcontent: '';\n\t\theight: 26px;\n\t\twidth: 26px;\n\t\tleft: 4px;\n\t\tbottom: 4px;\n\t\tbackground-color: white;\n\t\t-webkit-transition: 0.4s;\n\t\ttransition: 0.4s;\n\t}\n\n\tinput:checked + .slider {\n\t\tbackground-color: #a45eb6;\n\t}\n\n\tinput:focus + .slider {\n\t\tbox-shadow: 0 0 1px #a45eb6;\n\t}\n\n\tinput:checked + .slider:before {\n\t\t-webkit-transform: translateX(26px);\n\t\t-ms-transform: translateX(26px);\n\t\ttransform: translateX(26px);\n\t}\n\n\t/* Rounded sliders */\n\t.slider.round {\n\t\tborder-radius: 34px;\n\t}\n\n\t.slider.round:before {\n\t\tborder-radius: 50%;\n\t}\n</style>\n"],"names":["select_option","select","value","mounting","is_array","w.select_multiple_invalid_value","option","get_option_value","option_value","is","init_select","get_value","effect","observer","bind_select_value","get","set","listen_to_event_and_reset_event","is_reset","query","selected_option","i","$.get","$$render","consequent","alternate","$.each","tbody_1","$$props","o","consequent_1","alternate_1","sumSourceOutputValue","sumSourceOutputTokenAmounts","prerender","load","params","url","bid","BCH","tBCH","PRICE_MULTIPLIER","CatDex","packageInfo","template","getLibauthCompiler","createVirtualMachineBch","authCat","assetCat","hexToBin","lockingBytecodeResult","reversed","getScriptHash","prefix","getAddress","utxos","excludeCompleted","binToHex","dexOrders","u","orderData","a","b","matchedOrders","order","matchingIdx","assetInfo","utxo","commitment","quantity","vmNumberToBigInt","encodedPrice","padMinimallyEncodedVmNumber","bigIntToVmNumber","amount","lockingBytecode","tokensOut","cashReserves","tokenReserves","orderCommitment","outputs","key","addressIndex","hdPrivateKeyToP2pkhLockingBytecode","privateKey","unlockingData","deriveHdPublicKey","category","authUtxo","inputs","sourceOutputs","orders","tradeAmount","sortFn","best","nextTry","randomIdx","randomUtxo","sumSats","sumTokenAmounts","config","walletUtxos","sumSatsOut","sumOutputValue","sumSatsIn","satsRequired","satsIn","sumTokenAmountsOut","sumOutputTokenAmounts","sumTokenAmountsIn","tokensRequired","tokensIn","cashChange","tokenChange","contractUtxos","fee","authLayers","blackBoardLayers","result","generateTransaction","estimatedFee","getTransactionFees","lastIdx","transaction","tokenValidationResult","verifyTransactionTokens","verify","feeEstimate","tokenDiff","catDexOrders","vaultLayers","getAllMarketOrders","electrumClient","scriptHashes","allUnspent","promiseAllInBatches","listUnspentTokensWrap","map","obj","updateAsset","updateSwap","on_click","__2","announceAuthBaton","on_click_1","__3","newAuthBaton","on_click_3","__5","postOrders","on_click_5","__7","on_click_6","__8","addMyOrder","selectedAsset","now","walletScriptHash","connectionStatus","timer","$.proxy","walletUnspent","$.state","myOrders","myOrderBook","myMarketRecord","myMarketTokens","myMarketSatoshis","myMembership","myAuthBatons","myDexUtxos","authBatons","showSettings","showChat","transaction_hex","transactionValid","transactionError","balance","assetBalance","isMainnet","page","baseTicker","server","metadata","BCMR","tBCMR","bchIcon","$.set","protocol_prefix","cashAssemblyToHex","wallet","bcmr","acc","debounceUpdateWallet","updateWallet","updateOrders","marketMakers","SmallIndex","v","array","marketScriptHashes","rawOrders","myRawOrders","sumUtxoValue","response","uname","NFTCapability","duration","message","TokenMintRequest","goto","dropOrder","replace","oldOrders","tx","encodeTransactionBch","broadcast","error","raw_tx","ConnectionStatus","handleNotifications","data","d","onMount","BaseWallet","IndexedDBProvider","Wallet","TestNetWallet","getHdPrivateKey","lockcodeResult","cashAddressToLockingBytecode","ElectrumClient","s","onDestroy","$.bind_checked","input","$$value","CONNECTED","DISCONNECTED","$.index","$$anchor","token","consequent_2","$.bind_value","input_1","consequent_3","button","consequent_4","div_10","consequent_5","alternate_2","consequent_6","node_13","authBaton","node_14","consequent_9","alternate_5","consequent_10","node_17","consequent_12","alternate_7","consequent_11","alternate_6","consequent_13","button_9","input_3","input_4","consequent_14","consequent_8","alternate_4","consequent_7","alternate_3","consequent_15","div_23","$.bind_select_value","input_2","consequent_16","alternate_8","input_5"],"mappings":"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","x_google_ignoreList":[0]}