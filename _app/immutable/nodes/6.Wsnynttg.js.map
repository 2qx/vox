{"version":3,"file":"6.Wsnynttg.js","sources":["../../../../../../src/routes/cat/+page.ts","../../../../../../../catdex/out/index.js","../../../../../../src/routes/cat/+page.svelte"],"sourcesContent":["export const prerender = true;","import template from './template.v3.json' with { type: \"json\" };\nimport packageInfo from '../package.json' with { type: \"json\" };\nimport { binToHex, bigIntToVmNumber, createVirtualMachineBch, deriveHdPublicKey, generateTransaction, hdPrivateKeyToP2pkhLockingBytecode, hexToBin, padMinimallyEncodedVmNumber, swapEndianness, verifyTransactionTokens, vmNumberToBigInt } from '@bitauth/libauth';\nimport { getAddress, getLibauthCompiler, getScriptHash, getTransactionFees, sumSourceOutputTokenAmounts, sumSourceOutputValue, sumOutputValue, sumOutputTokenAmounts } from '@unspent/tau';\nconst PRICE_MULTIPLIER = 100_000_000;\nexport default class CatDex {\n    static USER_AGENT = packageInfo.name;\n    static PROTOCOL_IDENTIFIER = \"U3X\";\n    static tokenAware = true;\n    static template = template;\n    static compiler = getLibauthCompiler(this.template);\n    static vm = createVirtualMachineBch();\n    static getLockingBytecode(authCat, assetCat) {\n        if (typeof authCat == \"string\")\n            authCat = hexToBin(swapEndianness(authCat));\n        if (typeof assetCat == \"string\")\n            assetCat = hexToBin(swapEndianness(assetCat));\n        const lockingBytecodeResult = this.compiler.generateBytecode({\n            data: {\n                \"bytecode\": {\n                    \"auth_category\": authCat,\n                    \"asset_category\": assetCat\n                }\n            },\n            scriptId: 'lock'\n        });\n        if (!lockingBytecodeResult.success)\n            throw new Error('Failed to generate bytecode, script: , ' + JSON.stringify(lockingBytecodeResult, null, '  '));\n        return lockingBytecodeResult.bytecode;\n    }\n    /**\n     * Get ScriptHash\n     *\n     * @param authCat - the authentication category\n     * @param assetCat - the asset category\n     * @param reversed - whether to reverse the hash.\n     * @throws {Error} if transaction generation fails.\n     * @returns a scripthash.\n     */\n    static getScriptHash(authCat, assetCat, reversed = true) {\n        return getScriptHash(this.getLockingBytecode(authCat, assetCat), reversed);\n    }\n    /**\n     * Get cashaddress\n     *\n     * @param authCat - the authentication category\n     * @param assetCat - the asset category\n     * @param prefix - cashaddress prefix.\n     * @throws {Error} if transaction generation fails.\n     * @returns a cashaddress.\n     */\n    static getAddress(authCat, assetCat, prefix = \"bitcoincash\") {\n        return getAddress(this.getLockingBytecode(authCat, assetCat), prefix, this.tokenAware);\n    }\n    static getSourceOutput(authCat, assetCat, utxo) {\n        return {\n            lockingBytecode: this.getLockingBytecode(authCat, assetCat),\n            valueSatoshis: BigInt(utxo.value),\n            token: utxo.token_data ? {\n                category: hexToBin(utxo.token_data.category),\n                amount: BigInt(utxo.token_data.amount),\n                nft: utxo.token_data.nft ? {\n                    commitment: hexToBin(utxo.token_data.nft.commitment),\n                    capability: utxo.token_data.nft.capability,\n                } : undefined\n            } : undefined\n        };\n    }\n    /**\n     * Parse nft commitment\n     *\n     * @param commitment - nft commitment\n     * @returns an order.\n     */\n    static parseNFT(commitment) {\n        let amount = vmNumberToBigInt(commitment.slice(0, 16), { requireMinimalEncoding: false });\n        let price = vmNumberToBigInt(commitment.slice(-16), { requireMinimalEncoding: false });\n        return {\n            amount: BigInt(amount),\n            price: BigInt(price)\n        };\n    }\n    /**\n     * Encode an order on for an nft commitment\n     *\n     * @param commitment - nft commitment\n     * @returns the new commitment as a 32-byte order data.\n     */\n    static encodeNFT(order) {\n        return new Uint8Array([\n            ...padMinimallyEncodedVmNumber(bigIntToVmNumber(order.amount), 16),\n            ...padMinimallyEncodedVmNumber(bigIntToVmNumber(order.price), 16)\n        ]);\n    }\n    static getInput(authCat, assetCat, utxo) {\n        if (typeof authCat == \"string\")\n            authCat = hexToBin(swapEndianness(authCat));\n        if (typeof assetCat == \"string\")\n            assetCat = hexToBin(swapEndianness(assetCat));\n        return {\n            outpointIndex: utxo.tx_pos,\n            outpointTransactionHash: hexToBin(utxo.tx_hash),\n            sequenceNumber: 0,\n            unlockingBytecode: {\n                data: {\n                    \"bytecode\": {\n                        \"auth_category\": authCat,\n                        \"asset_category\": assetCat\n                    }\n                },\n                compiler: this.compiler,\n                script: 'unlock',\n                valueSatoshis: BigInt(utxo.value),\n                token: utxo.token_data ? {\n                    category: hexToBin(utxo.token_data.category),\n                    amount: BigInt(utxo.token_data.amount),\n                    nft: utxo.token_data.nft ? {\n                        commitment: hexToBin(utxo.token_data.nft.commitment),\n                        capability: utxo.token_data.nft.capability,\n                    } : undefined\n                } : undefined\n            },\n        };\n    }\n    static getOutput(authCat, assetCat, utxo, amount) {\n        return {\n            lockingBytecode: this.getLockingBytecode(authCat, assetCat),\n            valueSatoshis: BigInt(utxo.value) + amount,\n            token: {\n                category: hexToBin(utxo.token_data.category),\n                amount: BigInt(utxo.token_data?.amount) - BigInt(amount)\n            }\n        };\n    }\n    static orderRequestToOutputs(authCat, assetCat, order) {\n        let lockingBytecode = this.getLockingBytecode(authCat, assetCat);\n        if (typeof authCat == \"string\")\n            authCat = hexToBin(authCat);\n        if (typeof assetCat == \"string\")\n            assetCat = hexToBin(assetCat);\n        let cashReserves = 800n;\n        let tokenReserves = 0n;\n        if (order.amount < 0)\n            cashReserves += BigInt(order.price * -order.amount);\n        if (order.amount > 0)\n            tokenReserves += BigInt(order.amount);\n        const orderCommitment = this.encodeNFT(order);\n        return [\n            {\n                lockingBytecode: lockingBytecode,\n                valueSatoshis: cashReserves,\n                token: {\n                    category: authCat,\n                    amount: 0n,\n                    nft: {\n                        commitment: orderCommitment,\n                        capability: 'mutable'\n                    }\n                }\n            },\n            {\n                lockingBytecode: this.getLockingBytecode(authCat, assetCat),\n                valueSatoshis: 800n,\n                token: {\n                    category: assetCat,\n                    amount: tokenReserves\n                }\n            }\n        ];\n    }\n    static getWalletSourceOutput(utxo, key, addressIndex = 0) {\n        const lockingBytecode = key ? hdPrivateKeyToP2pkhLockingBytecode({\n            addressIndex: addressIndex,\n            hdPrivateKey: key,\n            throwErrors: true\n        }) : Uint8Array.from(Array(33));\n        return {\n            lockingBytecode: lockingBytecode,\n            valueSatoshis: BigInt(utxo.value),\n            token: utxo.token_data ? {\n                category: hexToBin(utxo.token_data.category),\n                amount: BigInt(utxo.token_data.amount),\n                nft: utxo.token_data.nft ? {\n                    commitment: hexToBin(utxo.token_data.nft.commitment),\n                    capability: utxo.token_data.nft.capability,\n                } : undefined\n            } : undefined\n        };\n    }\n    static getWalletInput(utxo, privateKey, addressIndex = 0) {\n        let unlockingData = privateKey ? {\n            compiler: this.compiler,\n            data: {\n                hdKeys: {\n                    addressIndex: addressIndex,\n                    hdPrivateKeys: {\n                        'wallet': privateKey\n                    },\n                }\n            },\n            script: 'wallet_unlock',\n            valueSatoshis: BigInt(utxo.value),\n            token: utxo.token_data ? {\n                category: hexToBin(utxo.token_data.category),\n                amount: BigInt(utxo.token_data.amount),\n                nft: utxo.token_data.nft ? {\n                    commitment: hexToBin(utxo.token_data.nft.commitment),\n                    capability: utxo.token_data.nft.capability,\n                } : undefined\n            } : undefined\n        } : Uint8Array.from(Array());\n        return {\n            outpointIndex: utxo.tx_pos,\n            outpointTransactionHash: hexToBin(utxo.tx_hash),\n            sequenceNumber: 0,\n            unlockingBytecode: unlockingData,\n        };\n    }\n    static getAuthWalletOutput(utxo, privateKey, addressIndex = 0) {\n        const lockingBytecode = privateKey ? {\n            compiler: this.compiler,\n            data: {\n                hdKeys: {\n                    addressIndex: addressIndex,\n                    hdPublicKeys: {\n                        'wallet': deriveHdPublicKey(privateKey).hdPublicKey\n                    },\n                },\n            },\n            script: 'wallet_lock'\n        } : Uint8Array.from(Array(33));\n        return {\n            lockingBytecode: lockingBytecode,\n            valueSatoshis: BigInt(utxo.value),\n            token: utxo.token_data ? {\n                category: hexToBin(utxo.token_data.category),\n                amount: BigInt(utxo.token_data.amount),\n                nft: utxo.token_data.nft ? {\n                    commitment: hexToBin(utxo.token_data.nft.commitment),\n                    capability: utxo.token_data.nft.capability,\n                } : undefined\n            } : undefined\n        };\n    }\n    static getChangeOutput(value, amount, category, privateKey, addressIndex = 0) {\n        if (category && typeof category !== \"string\")\n            category = binToHex(category);\n        const lockingBytecode = privateKey ? {\n            compiler: this.compiler,\n            data: {\n                hdKeys: {\n                    addressIndex: addressIndex,\n                    hdPublicKeys: {\n                        'wallet': deriveHdPublicKey(privateKey).hdPublicKey\n                    },\n                },\n            },\n            script: 'wallet_lock'\n        } : Uint8Array.from(Array(33));\n        return {\n            lockingBytecode: lockingBytecode,\n            valueSatoshis: value,\n            token: amount > 0 && category ? {\n                category: hexToBin(category),\n                amount: amount,\n            } : undefined\n        };\n    }\n    static getAuthLayers(authUtxo, privateKey, addressIndex = 0) {\n        let inputs = [];\n        let outputs = [];\n        let sourceOutputs = [];\n        sourceOutputs.push(this.getWalletSourceOutput(authUtxo, privateKey, addressIndex));\n        inputs.push(this.getWalletInput(authUtxo, privateKey, addressIndex));\n        outputs.push(this.getAuthWalletOutput(authUtxo, privateKey, addressIndex));\n        return { inputs, outputs, sourceOutputs };\n    }\n    static setBlackBoardLayers(authCat, assetCat, utxos, orders, sourceOutputs = []) {\n        let inputs = [];\n        let outputs = [];\n        inputs.push(...utxos.map(u => this.getInput(authCat, assetCat, u)));\n        sourceOutputs.push(...utxos.map(u => this.getSourceOutput(authCat, assetCat, u)));\n        outputs.push(...orders.map(o => this.orderRequestToOutputs(authCat, assetCat, o)).flat(1));\n        return { inputs, outputs, sourceOutputs };\n    }\n    static getBlackBoardLayers(orders, amount, sourceOutputs = []) {\n        let inputs = [];\n        let outputs = [];\n        // Filter available orders to match direction of trade\n        orders.filter(o => Math.sign(Number(o.amount)) == Math.sign(Number(amount)));\n        // Check if we still have a market\n        if (orders.length == 0)\n            throw Error(\"no orders left, maximum recursion depth reached.\");\n        const sortFn = amount > 0 ?\n            ((a, b) => a.price - b.price) :\n            ((a, b) => a.price + b.price);\n        // sort orders by price\n        orders.sort(sortFn);\n        // pop the best order\n        const best = orders.shift();\n        // Load the order threads\n        inputs.push(this.getInput(best.authCategory, best.assetCategory, best.orderUtxo));\n        sourceOutputs.push(this.getSourceOutput(best.authCategory, best.assetCategory, best.orderUtxo));\n        // Load the asset threads\n        inputs.push(this.getInput(best.authCategory, best.assetCategory, best.assetUtxo));\n        sourceOutputs.push(this.getSourceOutput(best.authCategory, best.assetCategory, best.assetUtxo));\n        // if the best order can satisfy the quantity requested token amount\n        if (best.amount < amount) {\n            outputs.push(this.getOutput(best.authCategory, best.assetCategory, best.assetUtxo, amount));\n            outputs.push(this.getOutput(best.authCategory, best.assetCategory, best.assetUtxo, amount));\n        }\n        else {\n            if (amount < 0 && amount < -(best.amount)) {\n                // liquidate the best order\n                outputs.push(this.getOutput(best.authCategory, best.assetCategory, best.assetUtxo, -amount));\n                amount += best.amount;\n            }\n            // and try again\n            let nextTry = this.getBlackBoardLayers([...orders], amount, [...sourceOutputs]);\n            inputs.push(...nextTry.inputs);\n            outputs.push(...nextTry.outputs);\n            sourceOutputs = nextTry.sourceOutputs;\n        }\n        return { inputs, outputs, sourceOutputs };\n    }\n    static getWalletInputs(utxos, amount, privateKey, category, sourceOutputs = []) {\n        let inputs = [];\n        let outputs = [];\n        if (category && typeof category !== \"string\")\n            category = binToHex(category);\n        // Only use straight sat utxos if placing Bch\n        if (!category) {\n            utxos = utxos.filter(u => !u.token_data);\n        }\n        else {\n            utxos = utxos.filter(u => u.token_data && u.token_data?.category == category);\n        }\n        // TODO: sort by highest value first\n        if (utxos.length == 0)\n            throw Error(\"no wallet utxos left, maximum recursion depth reached.\");\n        // get a random utxo.\n        const randomIdx = Math.floor(Math.random() * utxos.length);\n        const randomUtxo = utxos[randomIdx];\n        // remove the random utxo in place\n        utxos.splice(randomIdx, 1);\n        // spend the utxo\n        inputs.push(this.getWalletInput(randomUtxo, privateKey));\n        sourceOutputs.push(this.getWalletSourceOutput(randomUtxo, privateKey));\n        let sumSats = sumSourceOutputValue(sourceOutputs);\n        let sumTokenAmounts = sumSourceOutputTokenAmounts(sourceOutputs, category);\n        if (\n        // collecting tokens, but the amount is not sufficient\n        (category && sumTokenAmounts < amount) ||\n            // or collecting sats and not enough sats inputs \n            (!category && sumSats < amount)) {\n            // to it again\n            let nextTry = this.getWalletInputs([...utxos], amount, privateKey, category, [...sourceOutputs]);\n            inputs.push(...nextTry.inputs);\n            outputs.push(...nextTry.outputs);\n            sourceOutputs = nextTry.sourceOutputs;\n        }\n        return { inputs, outputs, sourceOutputs };\n    }\n    static getWalletLayers(assetCat, config, sourceOutputs, walletUtxos, privateKey) {\n        // Calculate excess cash and tokens required to fund the exchange\n        let sumSatsOut = sumOutputValue(config.outputs);\n        let sumSatsIn = sumSourceOutputValue(sourceOutputs);\n        let satsRequired = sumSatsOut - sumSatsIn;\n        let sumTokenAmountsOut = sumOutputTokenAmounts(config.outputs, assetCat);\n        let sumTokenAmountsIn = sumSourceOutputTokenAmounts(sourceOutputs, assetCat);\n        let tokensRequired = sumTokenAmountsOut - sumTokenAmountsIn;\n        const satsIn = this.getWalletInputs(walletUtxos, satsRequired, privateKey);\n        const tokensIn = this.getWalletInputs(walletUtxos, tokensRequired, privateKey, assetCat);\n        config.inputs.push(...satsIn.inputs);\n        sourceOutputs.push(...satsIn.sourceOutputs);\n        config.inputs.push(...tokensIn.inputs);\n        sourceOutputs.push(...tokensIn.sourceOutputs);\n        // Calculate excess cash and tokens to be returned as change\n        sumSatsOut = sumOutputValue(config.outputs);\n        sumSatsIn = sumSourceOutputValue(sourceOutputs);\n        let cashChange = sumSatsIn - sumSatsOut;\n        sumTokenAmountsOut = sumOutputTokenAmounts(config.outputs, assetCat);\n        sumTokenAmountsIn = sumSourceOutputTokenAmounts(sourceOutputs, assetCat);\n        let tokenChange = sumTokenAmountsIn - sumTokenAmountsOut;\n        if (tokenChange > 0) {\n            config.outputs.push(this.getChangeOutput(800n, tokenChange, assetCat, privateKey));\n            cashChange -= 800n;\n        }\n        config.outputs.push(this.getChangeOutput(cashChange, 0n, undefined, privateKey));\n        return config;\n    }\n    /**\n     * Administer CatDex Blackboard\n     *\n     * Create, rebalance, or withdraw assets from a contract.\n     *\n     * To create an exchange, specify a list of new orders against an empty contract utxo state.\n     *\n     * To rebalance the orders on an existing exchange, provide the complete list of\n     * current contract utxos and the desired new order state.\n     *\n     * To withdraw, specify the current utxos without new orders.\n     *\n     * @param assetCat - Category of the asset traded\n     * @param authUtxo - Exchange authentication (minting) baton\n     * @param contractUtxos - Current utxo state.\n     * @param orders - List of next desired order state.\n     * @param walletUtxos - wallet outputs to use as input.\n     * @param privateKey - private key to sign transaction wallet inputs.\n     * @param fee - transaction fee to pay (per byte).\n     *\n     * @throws {Error} if transaction generation fails.\n     * @returns a transaction template.\n     */\n    static administer(authUtxo, assetCat, contractUtxos, orders, walletUtxos, privateKey, addressIndex = 0, fee = 1) {\n        const inputs = [];\n        const outputs = [];\n        let config = {\n            locktime: 0,\n            version: 2,\n            inputs,\n            outputs\n        };\n        let authCat = authUtxo.token_data.category;\n        // Build authentication baton layer\n        const authLayers = this.getAuthLayers(authUtxo, privateKey, addressIndex);\n        config.inputs.push(...authLayers.inputs);\n        config.outputs.push(...authLayers.outputs);\n        let sourceOutputs = authLayers.sourceOutputs;\n        const blackBoardLayers = this.setBlackBoardLayers(authCat, assetCat, contractUtxos, orders);\n        config.inputs.push(...blackBoardLayers.inputs);\n        config.outputs.push(...blackBoardLayers.outputs);\n        sourceOutputs.push(...blackBoardLayers.sourceOutputs);\n        config = this.getWalletLayers(assetCat, config, sourceOutputs, walletUtxos, privateKey);\n        let result = generateTransaction(config);\n        if (!result.success)\n            throw new Error('generate transaction failed!, errors: ' + JSON.stringify(result.errors, null, '  '));\n        const estimatedFee = getTransactionFees(result.transaction, fee);\n        const lastIdx = config.outputs.length - 1;\n        config.outputs[lastIdx].valueSatoshis = config.outputs[lastIdx].valueSatoshis - estimatedFee;\n        result = generateTransaction(config);\n        if (!result.success)\n            throw new Error('generate transaction failed!, errors: ' + JSON.stringify(result.errors, null, '  '));\n        const transaction = result.transaction;\n        const tokenValidationResult = verifyTransactionTokens(transaction, sourceOutputs, { maximumTokenCommitmentLength: 40 });\n        if (tokenValidationResult !== true && fee > 0)\n            throw tokenValidationResult;\n        let verify = this.vm.verify({\n            sourceOutputs: sourceOutputs,\n            transaction: transaction,\n        });\n        let feeEstimate = sumSourceOutputValue(sourceOutputs) - sumSourceOutputValue(transaction.outputs);\n        if (feeEstimate > 5000)\n            verify = `Excessive fees ${feeEstimate}`;\n        if (sumSourceOutputTokenAmounts(sourceOutputs, assetCat) == 0n)\n            verify = `Error checking token input`;\n        let tokenDiff = sumSourceOutputTokenAmounts(sourceOutputs, assetCat) -\n            sumSourceOutputTokenAmounts(transaction.outputs, assetCat);\n        if (tokenDiff !== 0n)\n            verify = `Swapping should not create destroy tokens, token difference: ${tokenDiff}`;\n        return {\n            sourceOutputs: sourceOutputs,\n            transaction: transaction,\n            verify: verify\n        };\n    }\n    /**\n     * Swap\n     *\n     * Build a transaction (with best execution) for the given amount of tokens.\n     *\n     * Buy tokens by specifying a positive amount, and a negative amount to sell.\n     *\n     *\n     *\n     * @param amount - token amount to buy, negative (-) to sell.\n     * @param catDexOrders - A multi-exchange list of available catdex orders.\n     * @param walletUtxos - wallet outputs to use as input.\n     * @param privateKey - private key to sign transaction wallet inputs.\n     * @param fee - transaction fee to pay (per byte).\n     *\n     * @throws {Error} if transaction generation fails.\n     * @returns a transaction template.\n     */\n    static swap(amount, catDexOrders, walletUtxos, privateKey, fee = 1) {\n        const inputs = [];\n        const outputs = [];\n        let sourceOutputs = [];\n        let authCat = catDexOrders[0].orderUtxo.token_data?.category;\n        let assetCat = catDexOrders[0].assetUtxo.token_data?.category;\n        let config = {\n            locktime: 0,\n            version: 2,\n            inputs,\n            outputs\n        };\n        // if selling tokens for Bch for WBch, don't use utxos with tokens\n        walletUtxos = walletUtxos.filter(u => u.token_data.category == assetCat || !u.token_data);\n        let vaultLayers = this.getBlackBoardLayers(catDexOrders, amount, sourceOutputs);\n        config.inputs.push(...vaultLayers.inputs);\n        config.outputs.push(...vaultLayers.outputs);\n        sourceOutputs = vaultLayers.sourceOutputs;\n        config = this.getWalletLayers(assetCat, config, sourceOutputs, walletUtxos, privateKey);\n        let result = generateTransaction(config);\n        if (!result.success)\n            throw new Error('generate transaction failed!, errors: ' + JSON.stringify(result.errors, null, '  '));\n        const estimatedFee = getTransactionFees(result.transaction, fee);\n        const lastIdx = config.outputs.length - 1;\n        config.outputs[lastIdx].valueSatoshis = config.outputs[lastIdx].valueSatoshis - estimatedFee;\n        result = generateTransaction(config);\n        if (!result.success)\n            throw new Error('generate transaction failed!, errors: ' + JSON.stringify(result.errors, null, '  '));\n        const transaction = result.transaction;\n        const tokenValidationResult = verifyTransactionTokens(transaction, sourceOutputs, { maximumTokenCommitmentLength: 40 });\n        if (tokenValidationResult !== true && fee > 0)\n            throw tokenValidationResult;\n        let verify = this.vm.verify({\n            sourceOutputs: sourceOutputs,\n            transaction: transaction,\n        });\n        let feeEstimate = sumSourceOutputValue(sourceOutputs) - sumSourceOutputValue(transaction.outputs);\n        if (feeEstimate > 5000)\n            verify = `Excessive fees ${feeEstimate}`;\n        if (sumSourceOutputTokenAmounts(sourceOutputs, assetCat) == 0n)\n            verify = `Error checking token input`;\n        let tokenDiff = sumSourceOutputTokenAmounts(sourceOutputs, assetCat) -\n            sumSourceOutputTokenAmounts(transaction.outputs, assetCat);\n        if (tokenDiff !== 0n)\n            verify = `Swapping should not create destroy tokens, token difference: ${tokenDiff}`;\n        return {\n            sourceOutputs: sourceOutputs,\n            transaction: transaction,\n            verify: verify\n        };\n    }\n}\n//# sourceMappingURL=index.js.map","<script lang=\"ts\">\n\timport Readme from './README.md';\n\n\timport BitauthLink from '$lib/BitauthLink.svelte';\n\timport CONNECTED from '$lib/images/connected.svg';\n\timport DISCONNECTED from '$lib/images/disconnected.svg';\n\n\timport CatDex from '@unspent/catdex';\n\n\tlet connectionStatus = $state('');\n</script>\n\n<section>\n\t<div class=\"status\">\n\t\t<BitauthLink template={CatDex.template} />\n\t\t{#if connectionStatus == 'CONNECTED'}\n\t\t\t<img src={CONNECTED} alt={connectionStatus} />\n\t\t{:else}\n\t\t\t<img src={DISCONNECTED} alt=\"Disconnected\" />\n\t\t{/if}\n\t</div>\n\n\t<Readme />\n</section>\n\n<style>\n\t.status {\n\t\ttext-align: end;\n\t}\n</style>\n"],"names":["prerender","CatDex","packageInfo","template","getLibauthCompiler","createVirtualMachineBch","authCat","assetCat","hexToBin","swapEndianness","lockingBytecodeResult","reversed","getScriptHash","prefix","getAddress","utxo","commitment","amount","vmNumberToBigInt","price","order","padMinimallyEncodedVmNumber","bigIntToVmNumber","lockingBytecode","cashReserves","tokenReserves","orderCommitment","key","addressIndex","hdPrivateKeyToP2pkhLockingBytecode","privateKey","unlockingData","deriveHdPublicKey","value","category","binToHex","authUtxo","inputs","outputs","sourceOutputs","utxos","orders","u","o","sortFn","a","b","best","nextTry","randomIdx","randomUtxo","sumSats","sumSourceOutputValue","sumTokenAmounts","sumSourceOutputTokenAmounts","config","walletUtxos","sumSatsOut","sumOutputValue","sumSatsIn","satsRequired","sumTokenAmountsOut","sumOutputTokenAmounts","sumTokenAmountsIn","tokensRequired","satsIn","tokensIn","cashChange","tokenChange","contractUtxos","fee","authLayers","blackBoardLayers","result","generateTransaction","estimatedFee","getTransactionFees","lastIdx","transaction","tokenValidationResult","verifyTransactionTokens","verify","feeEstimate","tokenDiff","catDexOrders","vaultLayers","DISCONNECTED","$$render","alternate"],"mappings":"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"}