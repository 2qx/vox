import{f as _,a as O,d as rt}from"../chunks/DYbKDSXk.js";import{o as it,a as ct}from"../chunks/CPLxGhQo.js";import{au as ut,p as J,c as o,r,s as d,E as n,aF as Ot,t as S,a as Z,aG as h,ac as G,ad as E,f as W}from"../chunks/DlUVEpaU.js";import{i as B}from"../chunks/C6jlbT71.js";import{e as dt,i as _t}from"../chunks/CMKxWac-.js";import{s as N}from"../chunks/vpaS6ag4.js";import{s as mt}from"../chunks/jyPZu9FF.js";import{p as lt}from"../chunks/D_gM3vc7.js";import"../chunks/vmZ8CxnS.js";import{$ as j,a as Pt}from"../chunks/CRbVXWIV.js";import{W as pt,T as ft,I as Tt,B as kt}from"../chunks/PlXE8sTw.js";import{g as gt}from"../chunks/B2gQH3vd.js";import{l as w,k as ht,m as $,o as Et,B as z,v as bt,b as H,C as Ut,s as yt}from"../chunks/DLngWCRZ.js";import{g as vt}from"../chunks/CKFQkxAk.js";import{c as Bt}from"../chunks/BP7KE8cK.js";import{g as Nt}from"../chunks/4WAd-rdk.js";import{B as Ct,D as At}from"../chunks/DpKBRRcz.js";import"../chunks/l0sNRNKZ.js";import{C as xt}from"../chunks/B7hCbxZp.js";import{d as It,s as X}from"../chunks/DIwOIcma.js";import{b as Rt}from"../chunks/B8sppVjI.js";import{b as Lt}from"../chunks/C4jED5RM.js";import{T as wt,a as Ft}from"../chunks/Cfb3qDNx.js";const Yt=!0,Re=Object.freeze(Object.defineProperty({__proto__:null,prerender:Yt},Symbol.toStringTag,{value:"Module"}));var Mt=_('<h3>About BadgerStake</h3> <p>Badgers is a proof-of-ownership memecoin on BitcoinCash.</p> <p>More information at <a href="https://badgers.cash/FAQ" rel="nofollow">Badgers.Cash</a></p>',1);function St(b){var t=Mt();ut(4),O(b,t)}const qt="https://libauth.org/schemas/wallet-template-v0.schema.json",Vt="BadgerStake: a staking contract to earn Badger tokens.",Dt="BadgerStake",Qt={covenant:{description:"BadgerStake holds undistributed BadgerCoins on the MasterBadger NFT as well as staked coins.",name:"Badger Vault",scripts:["unlock","stake","lock","administer"],variables:{amount:{description:"Stake amount.",name:"Amount",type:"WalletData"},stake_blocks:{description:"The duration of the staking period (in blocks)",name:"Stake Blocks",type:"WalletData"},new_fee:{description:"The category of the asset being listed.",name:"Asset Category",type:"WalletData"},user_pkh:{description:"The key that controls user funds.",name:"User",type:"WalletData"},admin_pkh:{description:"The key administering this covenant.",name:"Admin",type:"WalletData"}}}},Kt={base:{data:{bytecode:{stake_blocks:"5000",amount:"100000000",new_fee:"1000"}},description:"",name:"Base Scenario"},stake:{data:{bytecode:{stake_blocks:"5000",amount:"400000",new_fee:"1000",user_pkh:"0xbe7f0bcf860657ce2fdb6f047141faa39e50f224"}},description:"Lock coins in the Badger Vault",extends:"base",name:"Lock Assets",transaction:{inputs:[{unlockingBytecode:["slot"]},{}],outputs:[{lockingBytecode:{script:"lock"},valueSatoshis:335e3,token:{amount:"9223372036854412287",category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",nft:{capability:"minting",commitment:"e8030000000000000000000000000000000000002770188a88f75360d1e956d7ff290ef1e0f56787"}}},{lockingBytecode:{script:"lock"},valueSatoshis:4e5,token:{amount:20,category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",nft:{capability:"mutable",commitment:"be7f0bcf860657ce2fdb6f047141faa39e50f2240000000000000000000000000000000000008813"}}},{lockingBytecode:"76a914be7f0bcf860657ce2fdb6f047141faa39e50f22488ac",valueSatoshis:2713641}],version:2},sourceOutputs:[{lockingBytecode:["slot"],valueSatoshis:334e3,token:{category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",amount:"9223372036854412307",nft:{commitment:"e8030000000000000000000000000000000000002770188a88f75360d1e956d7ff290ef1e0f56787",capability:"minting"}}},{valueSatoshis:42715641}]},unlock:{data:{bytecode:{stake_blocks:"5000",amount:"400000",new_fee:"1000",user_pkh:"0xbe7f0bcf860657ce2fdb6f047141faa39e50f224"}},description:"",extends:"base",name:"Release Assets",transaction:{inputs:[{unlockingBytecode:["slot"],sequenceNumber:5e3}],outputs:[{lockingBytecode:"76a914be7f0bcf860657ce2fdb6f047141faa39e50f22488ac",valueSatoshis:1e3,token:{amount:20,category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7"}},{lockingBytecode:"76a914be7f0bcf860657ce2fdb6f047141faa39e50f22488ac",valueSatoshis:1e3,token:{category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",amount:0,nft:{capability:"none",commitment:"000014"}}},{lockingBytecode:"76a914be7f0bcf860657ce2fdb6f047141faa39e50f22488ac",valueSatoshis:397e3}],version:2},sourceOutputs:[{lockingBytecode:["slot"],valueSatoshis:4e5,token:{category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",amount:20,nft:{commitment:"be7f0bcf860657ce2fdb6f047141faa39e50f2240000000000000000000000000000000000008813",capability:"mutable"}}}]},withdraw:{description:"Administer the current fee, ",extends:"base",name:"Withdraw accumulated fees and adjust anti-spam fee",transaction:{inputs:[{unlockingBytecode:["slot"],sequenceNumber:10},{unlockingBytecode:{script:["copy"]}}],outputs:[{lockingBytecode:{script:"lock"},valueSatoshis:1e3,token:{amount:"9223372036854412287",category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",nft:{capability:"minting",commitment:"e8030000000000000000000000000000000000002770188a88f75360d1e956d7ff290ef1e0f56787"}}},{lockingBytecode:"76a9142770188a88f75360d1e956d7ff290ef1e0f5678788ac",valueSatoshis:330800}],version:2},sourceOutputs:[{lockingBytecode:["slot"],valueSatoshis:332e3,token:{category:"242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7",amount:"9223372036854412287",nft:{commitment:"e8030000000000000000000000000000000000002770188a88f75360d1e956d7ff290ef1e0f56787",capability:"minting"}}},{lockingBytecode:"76a9142770188a88f75360d1e956d7ff290ef1e0f5678788ac",valueSatoshis:800}]}},Xt=JSON.parse(`{"stake":{"passes":["stake"],"name":"0: Lock","script":" <user_pkh> <stake_blocks> <amount>  OP_0","unlocks":"lock"},"unlock":{"passes":["unlock"],"name":"1: Unlock","script":"OP_1","unlocks":"lock"},"administer":{"passes":["withdraw"],"name":"2: Administer","script":"<new_fee> OP_2 ","unlocks":"lock"},"lock":{"lockingType":"p2sh32","name":"BadgerStake Covenant","script":"\\n// pragma cashscript ^0.10.0;\\n\\n// contract BadgerStake() {\\n\\n//     /////////////////////////////////////////////\\n//     //inputs:\\n//     //  0   masterBadger        [NFT]   (from contract)\\n//     //  1   userUTXO            [BCH]   (from user)\\n//     //outputs:\\n//     //  0   masterBadger        [NFT]   (to contract)\\n//     //  1   lockUTXO            [NFT]   (to contract)\\n//     //  2   {optional} change   [BCH]   (to user)\\n//     /////////////////////\\n//     //parameters:\\n//     //  amount: BCH amount user wants to lock up\\n//     //  stakeBlocks: number of blocks to be locked up for\\n//     //  pubkeyhash: a pubkeyhash, used to send the locked BCH back to the users address\\n//     /////////////////////////////////////////////\\n\\n       OP_DUP OP_0 OP_NUMEQUAL OP_IF \\n//     function lock(int amount, int stakeBlocks, bytes20 pubkeyhash) {\\n\\n//       // this contract must be input0\\n         OP_INPUTINDEX OP_0 OP_NUMEQUALVERIFY \\n//       require(this.activeInputIndex == 0);\\n\\n//       // must have exactly 2 inputs\\n         OP_TXINPUTCOUNT OP_2 OP_NUMEQUALVERIFY \\n//       require(tx.inputs.length == 2);\\n\\n//       // must have 3 or less outputs\\n         OP_TXOUTPUTCOUNT OP_3 OP_LESSTHANOREQUAL OP_VERIFY \\n//       require(tx.outputs.length <= 3);\\n\\n//       // cannot lock for longer than 65536 blocks\\n         OP_2 OP_PICK <65536> OP_LESSTHANOREQUAL OP_VERIFY \\n//       require(stakeBlocks <= 65536);\\n\\n//       // minimum 5000 sats to lock so have enough for unlock()\\n         OP_OVER <5000> OP_GREATERTHANOREQUAL OP_VERIFY \\n//       require(amount >= 5000);\\n\\n//       // input0 must be masterBadger NFT\\n         OP_0 OP_UTXOTOKENCATEGORY <0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24> OP_2 OP_CAT OP_EQUALVERIFY\\n//       require(tx.inputs[0].tokenCategory == 0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24 + 0x02);\\n\\n//       // input1 must be BCH with no tokens\\n         OP_1 OP_UTXOTOKENCATEGORY OP_0 OP_EQUALVERIFY \\n//       require(tx.inputs[1].tokenCategory == 0x);\\n\\n//       // provided pubkeyhash must be the pubkeyhash of input1 (users address)\\n         OP_1 OP_UTXOBYTECODE <0x76a914> OP_5 OP_PICK OP_CAT <0x88ac> OP_CAT OP_EQUALVERIFY \\n//       require(tx.inputs[1].lockingBytecode == new LockingBytecodeP2PKH(pubkeyhash));\\n\\n//       // convert stakeBlocks to bytes for inclusion into commitment\\n         OP_2 OP_PICK OP_2 OP_NUM2BIN \\n//       bytes stakeLength = bytes2(stakeBlocks);\\n\\n//       // save payout address and length of lock into output1 commitment (lockNFT)\\n         OP_1 OP_OUTPUTTOKENCOMMITMENT OP_5 OP_ROLL OP_0 <18> OP_NUM2BIN OP_CAT OP_ROT OP_CAT OP_EQUALVERIFY \\n//       require(tx.outputs[1].nftCommitment == pubkeyhash + bytes18(0) + stakeLength);\\n\\n//       // get current locking fee from masterBadger's commitment\\n         OP_0 OP_UTXOTOKENCOMMITMENT OP_2 OP_SPLIT OP_DROP \\n//       bytes2 stakeFee = bytes2(tx.inputs[0].nftCommitment.split(2)[0]);\\n\\n//       // add locking fee to current masterBadger balance\\n         OP_0 OP_OUTPUTVALUE OP_0 OP_UTXOVALUE OP_ROT OP_BIN2NUM OP_ADD OP_NUMEQUALVERIFY \\n//       require(tx.outputs[0].value == tx.inputs[0].value + int(stakeFee));\\n\\n//       // output0 sent to contract (recreate masterBadger)\\n         OP_0 OP_OUTPUTBYTECODE OP_0 OP_UTXOBYTECODE OP_EQUALVERIFY \\n//       require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\\n\\n//       // carry forward masterBadger tokenCategory + capability\\n         OP_0 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY OP_EQUALVERIFY \\n//       require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\\n\\n//       // carry forward masterBadger commitment\\n         OP_0 OP_OUTPUTTOKENCOMMITMENT OP_0 OP_UTXOTOKENCOMMITMENT OP_EQUALVERIFY \\n//       require(tx.outputs[0].nftCommitment == tx.inputs[0].nftCommitment);\\n\\n//       calculate amount of BadgerCoins user will earn (amount * blocks / 1BCH)\\n         OP_OVER OP_3 OP_ROLL OP_MUL <100000000> OP_DIV \\n//       int stakeReward = amount * stakeBlocks / 100000000;\\n\\n//       // require at least 1 BadgerCoin will be earned\\n         OP_DUP OP_1 OP_GREATERTHANOREQUAL OP_VERIFY \\n//       require(stakeReward >= 1);\\n\\n//       // deduct earned BadgerCoins from masterBadger\\n         OP_0 OP_OUTPUTTOKENAMOUNT OP_0 OP_UTXOTOKENAMOUNT OP_2 OP_PICK OP_SUB OP_NUMEQUALVERIFY \\n//       require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount - stakeReward);\\n\\n//       // output1 sent to contract (lockNFT)\\n         OP_1 OP_OUTPUTBYTECODE OP_0 OP_UTXOBYTECODE OP_EQUALVERIFY \\n//       require(tx.outputs[1].lockingBytecode == tx.inputs[0].lockingBytecode);\\n\\n//       // lockNFT is a mutable NFT of masterBadger categoryID\\n         OP_1 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY <32> OP_SPLIT OP_DROP OP_1 OP_CAT OP_EQUALVERIFY \\n//       require(tx.outputs[1].tokenCategory == tx.inputs[0].tokenCategory.split(32)[0] + 0x01);\\n\\n//       // lockNFT has BCH equal to users amount parameter\\n         OP_1 OP_OUTPUTVALUE OP_3 OP_ROLL OP_NUMEQUALVERIFY\\n//       require(tx.outputs[1].value == amount);\\n\\n//       // lockNFT has BadgerCoin equal to calculated amount to be earned\\n         OP_1 OP_OUTPUTTOKENAMOUNT OP_NUMEQUALVERIFY \\n//       require(tx.outputs[1].tokenAmount == stakeReward);\\n\\n//       // if output2 exists (change)\\n         OP_TXOUTPUTCOUNT OP_3 OP_NUMEQUAL OP_IF \\n//       if (tx.outputs.length == 3) {\\n//          // change must be sent to users address\\n            OP_2 OP_OUTPUTBYTECODE OP_1 OP_UTXOBYTECODE OP_EQUALVERIFY \\n//          require(tx.outputs[2].lockingBytecode == tx.inputs[1].lockingBytecode);\\n\\n//          // change must not have tokens\\n            OP_2 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUALVERIFY OP_ENDIF \\n//          require(tx.outputs[2].tokenCategory == 0x);\\n//       }\\n//     }\\n      OP_DROP OP_1 OP_ELSE \\n\\n//    /////////////////////////////////////////////\\n//    //inputs:\\n//    //  0   lockUTXO            [NFT]   (from contract)\\n//    //      <20-byte owner_pkh> <18-byte 00s> <2-byte fee>\\n//    //\\n//    //outputs:\\n//    //  0   BadgerCoins         [FUN]   (to user)\\n//    //  1   Honey               [NFT]   (to user)\\n//    //  2   {optional} change   [BCH]   (to user)\\n//    /////////////////////////////////////////////\\n      OP_DUP OP_1 OP_NUMEQUAL OP_IF \\n//     function unlock() {\\n\\n//       // this contract must be input0\\n         OP_INPUTINDEX OP_0 OP_NUMEQUALVERIFY \\n//       require(this.activeInputIndex == 0);\\n\\n//       // must have exactly 1 input\\n         OP_TXINPUTCOUNT OP_1 OP_NUMEQUALVERIFY \\n//       require(tx.inputs.length == 1);\\n\\n//       // must have exactly 3 outputs\\n         OP_TXOUTPUTCOUNT OP_3 OP_NUMEQUALVERIFY \\n//       require(tx.outputs.length == 3);\\n\\n//       // input0 must be a lockNFT (masterBadger categoryID + mutable)\\n         OP_0 OP_UTXOTOKENCATEGORY <0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24> OP_1 OP_CAT OP_EQUALVERIFY \\n//       require(tx.inputs[0].tokenCategory == 0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24 + 0x01);\\n\\n//       // get number of blocks locked for from lockNFT's commitment\\n         OP_0 OP_UTXOTOKENCOMMITMENT <38> OP_SPLIT OP_NIP \\n//       bytes stakeBlocks = bytes2(tx.inputs[0].nftCommitment.split(38)[1]);\\n\\n//       // require the number of blocks locked for has been passed\\n         OP_BIN2NUM OP_CHECKSEQUENCEVERIFY \\n//       require(tx.age >= int(stakeBlocks));\\n\\n//       // get the pubkeyhash in lockNFT it was created with\\n         OP_DROP OP_0 OP_UTXOTOKENCOMMITMENT <20> OP_SPLIT OP_DROP \\n//       bytes20 payoutAddress = bytes20(tx.inputs[0].nftCommitment.split(20)[0]);\\n\\n//       // create the lockingBytecode for that pubkeyhash\\n         <0x76a914> OP_SWAP OP_CAT <0x88ac> OP_CAT \\n//       bytes payoutBytecode = new LockingBytecodeP2PKH(payoutAddress);\\n\\n//       // output0 (BadgerCoins) goes to the resulting wallet address (user who created the lock)\\n         OP_0 OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY \\n//       require(tx.outputs[0].lockingBytecode == payoutBytecode);\\n\\n//       // output0 is a masterBadger categoryID but no capability\\n         OP_0 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY <32> OP_SPLIT OP_DROP OP_EQUALVERIFY \\n//       require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory.split(32)[0]);\\n\\n//       // output0 has 1000 dust satoshis so it can exist\\n         OP_0 OP_OUTPUTVALUE <1000> OP_NUMEQUALVERIFY \\n//       require(tx.outputs[0].value == 1000);\\n\\n         OP_0 OP_OUTPUTTOKENAMOUNT OP_0 OP_UTXOTOKENAMOUNT OP_NUMEQUALVERIFY \\n//       require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount);\\n\\n//       // output1 (HoneyNFT) goes to the resulting wallet address (user who created the lock)\\n         OP_1 OP_OUTPUTBYTECODE OP_OVER OP_EQUALVERIFY \\n//       require(tx.outputs[1].lockingBytecode == payoutBytecode);\\n\\n//       // output1 is a masterBadger categoryID but no capability\\n         OP_1 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY <32> OP_SPLIT OP_DROP OP_EQUALVERIFY \\n//       require(tx.outputs[1].tokenCategory == tx.inputs[0].tokenCategory.split(32)[0]);\\n\\n//       // output1 has 1000 satoshis so it can exist\\n         OP_1 OP_OUTPUTVALUE <1000> OP_NUMEQUALVERIFY \\n//       require(tx.outputs[1].value == 1000);\\n\\n//       // create commitment of ID0 + amount of BadgerCoins earned\\n         <0x0000> OP_0 OP_UTXOTOKENAMOUNT OP_CAT \\n//       bytes commitment = 0x0000 + bytes(tx.inputs[0].tokenAmount);\\n\\n//       // output1 has above commitment\\n         OP_1 OP_OUTPUTTOKENCOMMITMENT OP_EQUALVERIFY \\n//       require(tx.outputs[1].nftCommitment == commitment);\\n\\n//       // output2 (unlocked BCH) goes to the extracted wallet address (user who created the lock)\\n         OP_2 OP_OUTPUTBYTECODE OP_EQUALVERIFY \\n//       require(tx.outputs[2].lockingBytecode == payoutBytecode);\\n\\n//       // output2 has no tokens\\n         OP_2 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUALVERIFY \\n//       require(tx.outputs[2].tokenCategory == 0x);\\n\\n//       // output2 has original locked BCH minus 3000sats (miner fee + BadgerCoin utxo + Honey utxo)\\n         OP_2 OP_OUTPUTVALUE OP_0 OP_UTXOVALUE <3000> OP_SUB OP_NUMEQUAL \\n//       require(tx.outputs[2].value == tx.inputs[0].value - 3000);\\n//     }\\n\\n//     /////////////////////////////////////////////\\n//     //inputs:\\n//     //  0   masterBadger        [NFT]   (from contract)\\n//     //      <2-byte fee> <18-byte 00s> <20-byte admin_pkh>\\n//     //      \\n//     //  1   adminUTXO           [BCH]   (from admin)\\n//     //outputs:\\n//     //  0   masterBadger        [NFT]   (to contract)\\n//     //  1   withdrawUTXO        [BCH]   (to admin)\\n//     /////////////////////\\n//     //parameters:\\n//     //  newFee: sets the masterBadger's locking fee (0 to 65536)\\n//     /////////////////////////////////////////////\\n      OP_NIP OP_ELSE OP_2 OP_NUMEQUALVERIFY \\n//     function withdraw(int newFee) {\\n\\n//       // this contract must be input0\\n         OP_INPUTINDEX OP_0 OP_NUMEQUALVERIFY \\n//       require(this.activeInputIndex == 0);\\n\\n//       // must have exactly 2 inputs\\n         OP_TXINPUTCOUNT OP_2 OP_NUMEQUALVERIFY \\n//       require(tx.inputs.length == 2);\\n\\n//       // must have exactly 2 outputs\\n         OP_TXOUTPUTCOUNT OP_2 OP_NUMEQUALVERIFY \\n//       require(tx.outputs.length == 2);\\n\\n//       // input0 must be masterBadger NFT\\n         OP_0 OP_UTXOTOKENCATEGORY <0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24> OP_2 OP_CAT OP_EQUALVERIFY \\n//       require(tx.inputs[0].tokenCategory == 0xd7ff0a63d5c1cbe1ced509314fe3caca563a73095be37734744c40dbce6e2f24 + 0x02);\\n\\n//       // input1 must be BCH with no tokens\\n         OP_1 OP_UTXOTOKENCATEGORY OP_0 OP_EQUALVERIFY \\n//       require(tx.inputs[1].tokenCategory == 0x);\\n\\n//       // get admins pubkeyhash stored in masterBadger commitment\\n         OP_0 OP_UTXOTOKENCOMMITMENT <20> OP_SPLIT OP_NIP \\n//       bytes20 adminAddress = bytes20(tx.inputs[0].nftCommitment.split(20)[1]);\\n\\n//       // create the lockingBytecode for that pubkeyhash\\n         <0x76a914> OP_SWAP OP_CAT <0x88ac> OP_CAT \\n//       bytes payoutBytecode = new LockingBytecodeP2PKH(adminAddress);\\n\\n//       // require the resulting lockingBytecode matches input1 (input1 is from admin address)\\n         OP_1 OP_UTXOBYTECODE OP_EQUALVERIFY \\n//       require(tx.inputs[1].lockingBytecode == payoutBytecode);\\n\\n//       // output1 has no tokens\\n         OP_1 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUALVERIFY \\n//       require(tx.outputs[1].tokenCategory == 0x);\\n\\n//       // output1 takes masterBadger's BCH balance minus 2000sats (miner fee + masterBadger dust)\\n         OP_1 OP_OUTPUTVALUE OP_0 OP_UTXOVALUE OP_1 OP_UTXOVALUE OP_ADD <2000> OP_SUB OP_NUMEQUALVERIFY \\n//       require(tx.outputs[1].value == tx.inputs[0].value + tx.inputs[1].value - 2000);\\n\\n//       // output0 sent to contract (recreate masterBadger)\\n         OP_0 OP_OUTPUTBYTECODE OP_0 OP_UTXOBYTECODE OP_EQUALVERIFY \\n//       require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\\n\\n//       // masterBadger retains its tokenCategory + capability\\n         OP_0 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY OP_EQUALVERIFY \\n//       require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\\n\\n//       // masterBadger set to 1000sats so it can exist\\n         OP_0 OP_OUTPUTVALUE <1000> OP_NUMEQUALVERIFY \\n//       require(tx.outputs[0].value == 1000);\\n\\n//       // masterBadger retains its remaining BadgerCoins\\n         OP_0 OP_OUTPUTTOKENAMOUNT OP_0 OP_UTXOTOKENAMOUNT OP_NUMEQUALVERIFY \\n//       require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount);\\n\\n//       // get last 38bytes of masterBadgers commitment\\n         OP_0 OP_UTXOTOKENCOMMITMENT OP_2 OP_SPLIT OP_NIP \\n//       bytes restCommitment = tx.inputs[0].nftCommitment.split(2)[1];\\n\\n//       // update masterBadger's commitment to newFee + rest of its commitment\\n         OP_0 OP_OUTPUTTOKENCOMMITMENT OP_ROT OP_2 OP_NUM2BIN OP_ROT OP_CAT OP_EQUAL\\n//       require(tx.outputs[0].nftCommitment == bytes2(newFee) + restCommitment);\\n//    }\\n   OP_ENDIF \\n// }\\nOP_ENDIF"}}`),Ht=["BCH_2023_05","BCH_SPEC"],Gt={$schema:qt,description:Vt,name:Dt,entities:Qt,scenarios:Kt,scripts:Xt,supported:Ht},Wt="@unspent/badgers",jt={name:Wt},zt=w("242f6ecedb404c743477e35b09733a56cacae34f3109d5cee1cbc1d5630affd7"),Jt=w("0000000000000000000000000000000000000000000000000000000000000000");class L{static USER_AGENT=jt.name;static tokenAware=!0;static template=Gt;static compiler=ht(this.template);static vm=Bt();static getLockingBytecode(){const t=this.compiler.generateBytecode({data:{},scriptId:"lock"});if(!t.success)throw new Error("Failed to generate bytecode, script: , "+JSON.stringify(t,null,"  "));return t.bytecode}static getScriptHash(t=!0){return $(this.getLockingBytecode(),t)}static getAddress(t="bitcoincash"){return Et(this.getLockingBytecode(),t,this.tokenAware)}static parseNFT(t){if(t.token_data?.nft?.capability=="mutable")return{amount:parseInt(t.token_data?.amount),stake:z(w(t.token_data?.nft?.commitment.slice(-4))),user_pkh:t.token_data?.nft?.commitment.slice(0,40)};if(t.token_data?.nft?.capability=="minting")return{amount:parseInt(t.token_data?.amount),stake:z(w(t.token_data?.nft?.commitment.slice(0,4))),user_pkh:t.token_data?.nft?.commitment.slice(-40)};throw Error("Nft was not minting nor mutable")}static getSourceOutput(t){return{lockingBytecode:this.getLockingBytecode(),valueSatoshis:BigInt(t.value)}}static getInput(t){return{outpointIndex:t.tx_pos,outpointTransactionHash:w(t.tx_hash),sequenceNumber:t.value,unlockingBytecode:{data:{},compiler:this.compiler,script:"unlock",valueSatoshis:BigInt(t.value)}}}static getOutput(){return{lockingBytecode:{data:{},compiler:this.compiler,script:"op_return"},valueSatoshis:BigInt(0)}}static getSourceOutputs(t){const p=[];return p.push(...t.map(m=>this.getSourceOutput(m))),p}static unlock(t){let P={locktime:0,version:2,inputs:[],outputs:[]};P.inputs.push(this.getInput(t)),P.outputs.push(this.getOutput());let c=Nt(P);if(!c.success)throw new Error("generate transaction failed!, errors: "+JSON.stringify(c.errors,null,"  "));const f=[this.getSourceOutput(t)],i=c.transaction,T=bt(i,f,{maximumTokenCommitmentLength:40});if(T!==!0)throw T;let k=this.vm.verify({sourceOutputs:f,transaction:i});if(typeof k=="string")throw k;return H(Ut(i))}}var Zt=_('<div class="svelte-1mqbhtw"><!> <!></div>'),$t=(b,t)=>{t.unlock({tx_hash:t.tx_hash,tx_pos:t.tx_pos})},te=_("<button>release</button>"),ee=_('<img height="32px" class="svelte-1mqbhtw"/>'),ne=_('<div class="container svelte-1mqbhtw"><div class="stake svelte-1mqbhtw"><div class="balance svelte-1mqbhtw"><div class="fill svelte-1mqbhtw"><!></div> <div><div> <b>BCH</b> <img width="20px"/></div> <div class="auth svelte-1mqbhtw"><!> <!></div></div></div> <div class="header svelte-1mqbhtw"><div class="timestamp svelte-1mqbhtw"> </div> <div class="fill svelte-1mqbhtw"></div> <div class="timestamp svelte-1mqbhtw"> </div></div></div></div>');function ae(b,t){J(t,!0);let p=Ot(()=>t.height+t.stake<t.now);var m=ne(),P=o(m),c=o(P),f=o(c),i=o(f);{var T=a=>{var u=Zt(),e=o(u);wt(e,{get amount(){return t.token_data.amount},get category(){return t.token_data.category}});var s=d(e,2);Ft(s,{size:"20",get category(){return t.token_data.category}}),r(u),O(a,u)};B(i,a=>{t.token_data&&a(T)})}r(f);var k=d(f,2),U=o(k),C=o(U),q=d(C,3);r(U);var g=d(U,2),F=o(g);{var V=a=>{var u=te();u.__click=[$t,t],O(a,u)};B(F,a=>{n(p)&&a(V)})}var A=d(F,2);{var x=a=>{var u=ee();S(e=>{N(u,"src",e),N(u,"alt",t.user_pkh)},[()=>Rt(t.user_pkh,16)]),O(a,u)};B(A,a=>{t.user_pkh&&a(x)})}r(g),r(k),r(c);var I=d(c,2),R=o(I),D=o(R,!0);r(R);var Y=d(R,4),M=o(Y,!0);r(Y),r(I),r(P),r(m),S(a=>{X(C,`${a??""} `),N(q,"src",Lt),X(D,t.stake),X(M,t.height)},[()=>Number(t.value/1e8).toLocaleString(void 0,{})]),O(b,m),Z()}It(["click"]);var se=_("<img/>"),oe=_('<img alt="Disconnected"/>'),re=_('<div class="row svelte-a2gs4s"><!></div>'),ie=_("<p>No staked coins?</p>"),ce=_('<h3>Current Stakes</h3> <div class="grid svelte-a2gs4s"><!></div>',1),ue=_('<section><div class="status svelte-a2gs4s"><!> <!></div> <!> <!></section>');function Le(b,t){J(t,!0);let p=h(0),m=h(""),P=h(""),c=h(G([]));G([]);let f=h(""),i=h(void 0),T=h(""),k=h("");E(T,L.getScriptHash(),!0);const U=lt.url.hostname=="vox.cash";U?H(zt):H(Jt);const C=gt(U);let q=new Set,g;const F=async function(e){if(e.method==="blockchain.headers.subscribe"){let s=e.params[0];E(p,s.height,!0),V()}else e.method==="blockchain.scripthash.subscribe"?e.params[1]!==n(P)&&(E(P,e.params[1],!0),E(m,Pt[n(i).status],!0)):console.log(e)},V=async function(){let e=await n(i).request("blockchain.scripthash.listunspent",n(T),"include_tokens");if(e instanceof Error)throw e;let s=new Set(e.map(l=>`${l.tx_hash}":"${l.tx_pos}`));(n(c).length==0||q.intersection(s).size==0)&&E(c,e.filter(l=>l.token_data.nft.capability=="mutable").map(l=>({...l,...L.parseNFT(l),now:n(p)})),!0)};it(async()=>{kt.StorageProvider=Tt,g=U?await pt.named("vox"):await ft.named("vox"),E(f,vt(g.mnemonic,g.derivationPath.slice(0,-2),g.isTestnet),!0);let e=yt(g.getDepositAddress());if(typeof e=="string")throw e;E(k,$(e.bytecode),!0),E(i,new j(L.USER_AGENT,"1.4.1",C),!0),await n(i).connect(),n(i).on("notification",F),await n(i).subscribe("blockchain.scripthash.subscribe",n(T)),await n(i).subscribe("blockchain.scripthash.subscribe",n(k)),await n(i).subscribe("blockchain.headers.subscribe")}),ct(async()=>{await new j(L.USER_AGENT,"1.4.1",C).disconnect()});var A=ue(),x=o(A),I=o(x);Ct(I,{get template(){return L.template}});var R=d(I,2);{var D=e=>{var s=se();S(()=>{N(s,"src",xt),N(s,"alt",n(m))}),O(e,s)},Y=e=>{var s=oe();S(()=>N(s,"src",At)),O(e,s)};B(R,e=>{n(m)=="CONNECTED"?e(D):e(Y,!1)})}r(x);var M=d(x,2);{var a=e=>{var s=ce(),l=d(W(s),2),tt=o(l);{var et=y=>{var v=rt(),at=W(v);dt(at,17,()=>n(c).filter(Q=>Q.height>0),_t,(Q,st)=>{var K=re(),ot=o(K);ae(ot,mt(()=>n(st))),r(K),O(Q,K)}),O(y,v)},nt=y=>{var v=ie();O(y,v)};B(tt,y=>{n(c).filter(v=>v.height>0).length>0?y(et):y(nt,!1)})}r(l),O(e,s)};B(M,e=>{n(c).length&&e(a)})}var u=d(M,2);St(u),r(A),O(b,A),Z()}export{Le as component,Re as universal};
//# sourceMappingURL=4.f7t2SB7A.js.map
