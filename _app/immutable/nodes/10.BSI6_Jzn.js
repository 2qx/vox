import{f as m,a as i,c as E}from"../chunks/DTc5U4eY.js";import{o as Se}from"../chunks/_R59KZhj.js";import{aA as Ae,p as Me,aB as r,ao as Ne,t as O,a as He,ay as $e,s as p,c as _,I as a,ak as o,r as k,f as F}from"../chunks/CQU5mOuk.js";import{h as We,s as te}from"../chunks/CF3aPdyL.js";import{i as S}from"../chunks/CZ0rTjPC.js";import{e as ae,i as oe}from"../chunks/CbL2L94E.js";import{s as w}from"../chunks/-rOGAMhN.js";import{s as De}from"../chunks/DBDCTY7c.js";import{p as Ie}from"../chunks/D9gdW5AE.js";import{U as Pe,L as Ue,F as Oe}from"../chunks/BaR9N2eR.js";import"../chunks/CuzQ0eOn.js";import{B as ze}from"../chunks/BzLj6JBc.js";import{C as Le}from"../chunks/B7hCbxZp.js";import{D as je}from"../chunks/DMvn4Q5j.js";import{$ as Ke,a as re}from"../chunks/BDt1pbpk.js";import{I as Re,B as qe,W as Ve,T as Ge,g as Qe}from"../chunks/BTBIn4-B.js";import{j as Je,d as Xe,s as Ye,b as Ze,k as et,l as tt}from"../chunks/BQUio51k.js";import{B as at,t as ot}from"../chunks/B2Xzehbr.js";import{V as A,T as rt,b as st}from"../chunks/Bt3MikUi.js";const it=!0,$t=Object.freeze(Object.defineProperty({__proto__:null,prerender:it},Symbol.toStringTag,{value:"Module"}));var nt=m("<h1>About Future Bitcoin Cash</h1> <h3>What is a <em>Future</em>?</h3> <p>A <em>Future</em> is a financial instrument representing some good or service to be delivered at some future date.</p> <p>Futures are a way to hedge risk by allowing a commodity producer to agree on a future price and date of delivery with a buyer.</p> <p>Financial futures allow parties to hedge risk or profit from stabilizing market volatility.</p> <h3>What is Future Bitcoin Cash (FBCH)?</h3> <p>Keeping with the philosophy of bitcoin, a trustless fully-backed currency should have a trustless fully-backed future. With CashTokens and a simple timelocked vault, a fully-backed trustless future token fairly simple easy.</p> <p>Futures are created by locking coins in a series vault corresponding to a future locktime. The corresponding token will then trade at a discount to the face value at maturity.</p> <h3>Why do people lock coins into futures?</h3> <p>Coupons are plain cash outputs that can be used to incentivize locking coins for futures.</p> <p>Coupons are not tokens, nor are they controlled by a central authority. Any one (or thing) that can send Bitcoin Cash to and address can create a coupon. Coupons are plain Bitcoin Cash unspent outputs, held by a contract.</p> <h3>Where do the coupons come from?</h3> <p>Future coupons can come from anywhere.  Writing a coupon is permissionless.</p> <p>Future coupon writers send bitcoin to a contract corresponding to a future vault and locking denomination.</p> <p>An individual may write many coupons at once, in the same transaction. A decentralized autonomous organization (DAO) may emit a stream of coupons according to some predetermined logic. Coupon writers may have differing or conflicting goals.</p> <p>Coupons are cash, and verifiable on-chain.</p>",1);function ct(M){var N=nt();Ae(30),i(M,N)}var lt=m('<meta name="description" content="Swap coins for Futures."/>'),ut=m("<img/>"),pt=m('<img alt="Disconnected"/>'),mt=m("<p>no coupons available</p>"),dt=m('<div style="text-align:center"><h2>loading coupons</h2> <!></div>'),ht=m(`<section><div class="status svelte-11bb5tr"> <!> <!></div> <h1>Stake coins for futures</h1> <div class="swap svelte-11bb5tr"><div class="svelte-11bb5tr"> <img width="20"/></div></div> <!> <div><p style="font-size:small"><i>sats (satoshis)</i>: one 100,000,000<sup>th</sup> of a whole coin.<br/> <i>spb</i>: rate in sats per coin per block of time remaining to maturation.<br/> <i>apy, coupon rate per annum</i>: effective non-compounding rate of annual return. Note:
			approximate rates assume 870 sats network transaction fees (550 swap, 320 redeem)â€•paid to
			miners.</p></div> <!></section>`);function Wt(M,N){Me(N,!0);let C=r(0),z=r(""),n=r(void 0),s,x,f=r(void 0),H=r(""),se=r(0),ie=r(0),ne=r(0),B=r(""),L=r(""),v=r([]),T=r(Ne([])),b=new Map([]),g=r(0);const d=Ie.url.hostname=="vox.cash",j=d?"BCH":"tBCH",ce=d?"bch.imaginary.cash":"chipnet.bch.ninja",le=d?rt:st,ue=d?at:ot;let y;const $=()=>{clearTimeout(x),x=setTimeout(()=>{R(),K()},5e3)},pe=async()=>{clearTimeout(x),x=setTimeout(async()=>{for(;a(T).length;){let e=a(T).shift();try{await de(e),await tt(400),console.log("broadcast")}catch(t){console.error(t),o(T,[],!0),o(v,[]),b=new Map([]),$()}}},500)};async function me(e){b.has(e.locktime)||b.set(e.locktime,await s.request("blockchain.scripthash.listunspent",A.getScriptHash(e.locktime),"include_tokens"));let t=b.get(e.locktime).filter(l=>l.token_data?.category==le.get(e.locktime)),c=A.swap(e.placement,t,a(v),e.locktime,a(z),e),P=Ze(et(c.transaction));a(T).push(P),pe(),o(n,a(n)?.filter(l=>!(l.tx_hash==e.tx_hash&&l.tx_pos==e.tx_pos))),o(f,Map.groupBy(a(n),({locktime:l,placement:u,value:h})=>`${l}-${u}-${h}`),!0),o(v,c.walletUtxos),b.set(e.locktime,c.contractUtxos),o(g,a(g)-e.placement)}const de=async function(e){let t=await s.request("blockchain.transaction.broadcast",e);if(t instanceof Error)throw o(B,re[s.status],!0),t};async function K(){s&&a(C)>1e3&&o(n,await A.getAllCouponUtxos(s,a(C))),a(n)&&(o(f,Map.groupBy(a(n),({locktime:e,placement:t,value:c})=>`${e}-${t}-${c}`),!0),a(n).sort((e,t)=>parseFloat(t.spb)-parseFloat(e.spb)),o(ie,Number(a(n).reduce((e,t)=>e+t.placement,0)/1e8),!0),o(ne,Number(a(n).reduce((e,t)=>e+t.value,0)),!0))}const R=async function(){let e=await s.request("blockchain.scripthash.listunspent",a(H),"include_tokens");if(e instanceof Error)throw e;o(v,e.filter(t=>!t.token_data?.nft)),o(g,Ye(a(v),!0),!0)},he=function(e){if(o(B,re[s.status],!0),e.method==="blockchain.headers.subscribe"){let t=e.params[0];o(C,t.height,!0),$()}else e.method==="blockchain.scripthash.subscribe"?e.params[1]!==a(L)&&(o(L,e.params[1],!0),o(se,0),$()):console.log(e)};Se(async()=>{qe.StorageProvider=Re,y=d?await Ve.named("vox"):await Ge.named("vox"),o(z,Qe(y.mnemonic,y.derivationPath.slice(0,-2),y.isTestnet),!0);let e=Je(y.getDepositAddress());if(typeof e=="string")throw e;o(H,Xe(e.bytecode),!0),s=new Ke(Pe,"1.4.1",ce),await s.connect(),s.on("notification",he),await s.subscribe("blockchain.headers.subscribe"),await s.subscribe("blockchain.scripthash.subscribe",a(H)),R(),K()});var W=ht();We(e=>{var t=lt();$e.title="ðŸ…µâ€‹ BCH",i(e,t)});var D=_(W),q=_(D),V=p(q);ze(V,{get template(){return A.template}});var fe=p(V,2);{var ve=e=>{var t=ut();O(()=>{w(t,"src",Le),w(t,"alt",a(B))}),i(e,t)},be=e=>{var t=pt();O(()=>w(t,"src",je)),i(e,t)};S(fe,e=>{a(B)=="CONNECTED"?e(ve):e(be,!1)})}k(D);var I=p(D,4),G=_(I),Q=_(G),J=p(Q);k(G),k(I);var X=p(I,2);{var ge=e=>{var t=E(),c=F(t);{var P=u=>{var h=E(),ke=F(h);ae(ke,17,()=>a(f).values(),oe,(we,Y)=>{var Z=E(),Ce=F(Z);ae(Ce,17,()=>a(Y),oe,(xe,Be,Te)=>{var ee=E(),Ee=F(ee);{var Fe=U=>{Oe(U,De({handlePlacement:me},()=>a(Be),{get isMainnet(){return d},get couponCount(){return a(Y).length},get balance(){return a(g)}}))};S(Ee,U=>{Te==0&&U(Fe)})}i(xe,ee)}),i(we,Z)}),i(u,h)},l=u=>{var h=mt();i(u,h)};S(c,u=>{a(f).size>0?u(P):u(l,!1)})}i(e,t)},ye=e=>{var t=dt(),c=p(_(t),2);Ue(c),k(t),i(e,t)};S(X,e=>{a(f)?e(ge):e(ye,!1)})}var _e=p(X,4);ct(_e),k(W),O((e,t)=>{te(q,`${e??""} `),te(Q,`${t??""}
			${j} `),w(J,"src",ue),w(J,"alt",j)},[()=>a(C).toLocaleString(),()=>Number(a(g)/1e8).toLocaleString(void 0,{maximumFractionDigits:1})]),i(M,W),He()}export{Wt as component,$t as universal};
//# sourceMappingURL=10.BSI6_Jzn.js.map
